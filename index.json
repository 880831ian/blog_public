[{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主題的全部內容和背後的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主題的全部內容和背後的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 準備 由於 Hugo 提供的便利性, Hugo 本身是這個主題唯一的依賴. 直接安裝滿足你操作系統 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.84.0). 為什麽不支持早期版本的 Hugo? 由於 Markdown 渲染鉤子函數 在 Hugo 聖誕節版本 中被引入 一些圖像資源使用的是0.84.0中引入的webp, 本主題只支持高於 0.84.0 的 Hugo 版本. 推薦使用 Hugo extended 版本 由於這個主題的一些特性需要將  SCSS 轉換為  CSS, 推薦使用 Hugo extended 版本來獲得更好的使用體驗. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安裝 以下步驟可幫助你初始化新網站. 如果你根本不了解 Hugo, 我們強烈建議你按照此 快速入門文檔 進一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 創建你的項目 Hugo 提供了一個 new 命令來創建一個新的網站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安裝主題 FeelIt 主題的倉庫是: https://github.com/khusika/FeelIt. 你可以下載主題的 最新版本  .zip 文件 並且解壓放到 themes 目錄. 另外, 也可以直接把這個主題克隆到 themes 目錄: git clone https://github.com/khusika/FeelIt.git themes/FeelIt 或者, 初始化你的項目目錄為 git 倉庫, 並且把主題倉庫作為你的網站目錄的子模塊: git init git submodule add https://github.com/khusika/FeelIt.git themes/FeelIt ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基礎配置 以下是 FeelIt 主題的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 設置默認的語言 defaultContentLanguage = \"zh-cn\" # 網站語言, 僅在這里 CN 大寫 languageCode = \"zh-CN\" # 是否包括中日韓文字 hasCJKLanguage = true # 網站標題 title = \"我的全新 Hugo 網站\" # 更改使用 Hugo 構建網站時使用的默認主題 theme = \"FeelIt\" [params] # FeelIt 主題版本 version = \"1.0.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名稱 (允許 HTML 格式) 之前添加其他信息, 例如圖標 pre = \"\" # 你可以在名稱 (允許 HTML 格式) 之後添加其他信息, 例如圖標 post = \"\" name = \"文章\" url = \"/posts/\" # 當你將鼠標懸停在此菜單鏈接上時, 將顯示的標題 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"標簽\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分類\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文檔的配置 [markup] # 語法高亮設置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的設置 (https://github.com/khusika/FeelIt/issues/158) noClasses = false 注意 在構建網站時, 你可以使用 --theme 選項設置主題. 但是, 我建議你修改配置文件 (config.toml) 將本主題設置為默認主題. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 創建你的第一篇文章 以下是創建第一篇文章的方法: hugo new posts/first_post.md 通過添加一些示例內容並替換文件開頭的標題, 你可以隨意編輯文章. 注意 默認情況下, 所有文章和頁面均作為草稿創建. 如果想要渲染這些頁面, 請從元數據中刪除屬性 draft: true, 設置屬性 draft: false 或者為 hugo 命令添加 -D/--buildDrafts 參數. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地啟動網站 使用以下命令啟動網站: hugo serve 去查看 http://localhost:1313. 基本配置下的預覽基本配置下的預覽 \" 基本配置下的預覽 技巧 當你運行 hugo serve 時, 當文件內容更改時, 頁面會隨著更改自動刷新. 注意 由於本主題使用了 Hugo 中的 .Scratch 來實現一些特性, 非常建議你為 hugo server 命令添加 --disableFastRender 參數來實時預覽你正在編輯的文章頁面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 構建網站 當你準備好部署你的網站時, 運行以下命令: hugo 會生成一個 public 目錄, 其中包含你網站的所有靜態內容和資源. 現在可以將其部署在任何 Web 服務器上. 技巧 網站內容可以通過 Netlify 自動發布和托管 (了解有關通過 Netlify 進行 HUGO 自動化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 網站配置 除了 Hugo 全局配置 和 菜單配置 之外, FeelIt 主題還允許您在網站配置中定義以下參數 (這是一個示例 config.toml, 其內容為默認值). 請打開下面的代碼塊查看完整的示例配置 : [params] # FeelIt 主題版本 version = \"1.0.X\" # 網站描述 description = \"這是我的全新 Hugo 網站\" # 網站關鍵詞 keywords = [\"Theme\", \"Hugo\"] # 網站默認主題樣式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 倉庫路徑，僅在 enableGitInfo 設為 true 時有效 gitRepo = \"\" # 哪種哈希函數用來 SRI, 為空時表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 網站圖片, 用於 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 是否啟用 CSS 和 JS 源映射 SourceMap = true # PWA config [params.pwa] # whether to enable PWA support enable = true # service-worker version version = \"1.0.1\" # 應用圖標配置 [params.app] # 當添加到 iOS 主屏幕或者 Android 啟動器時的標題, 覆蓋默認標題 title = \"FeelIt\" # 是否隱藏網站圖標資源鏈接 noFavicon = false # 更現代的 SVG 網站圖標, 可替代舊的 .png 和 .ico 文件 svgFavicon = \"\" # Android 瀏覽器主題色 themeColor = \"#ffffff\" # Safari 圖標顏色 iconColor = \"#5bbad5\" # Windows v8-10磁貼顏色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的類型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章內容最長索引長度 contentLength = 4000 # 搜索框的占位提示語 placeholder = \"\" # 最大結果數目 maxResultLength = 10 # 結果內容片段長度 snippetLength = 50 # 搜索結果中高亮部分的 HTML 標簽 highlightTag = \"em\" # 是否在搜索索引中使用基於 baseURL 的絕對路徑 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 頁面頭部導航欄配置 [params.header] # 桌面端導航欄模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移動端導航欄模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 頁面頭部導航欄標題配置 [params.header.title] # LOGO 的 URL logo = \"\" # 標題名稱 name = \"\" # 你可以在名稱 (允許 HTML 格式) 之前添加其他信息, 例如圖標 pre = \"\" # 你可以在名稱 (允許 HTML 格式) 之後添加其他信息, 例如圖標 post = \"\" # 是否為標題顯示打字機動畫 typeit = false # 是否顯示RSS圖標 rss = true # 頁面底部信息配置 [params.footer] enable = true # 自定義內容 (支持 HTML 格式) custom = '' # 是否顯示 Hugo 和主題信息 hugo = true # 是否顯示版權信息 copyright = true # 是否顯示作者 author = true # 網站創立年份 since = 2019 # ICP 備案信息，僅在中國使用 (支持 HTML 格式) icp = \"\" # 許可協議信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 頁面配置 [params.section] # section 頁面每頁顯示文章數量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章數目 rss = 10 # List (目錄或標簽) 頁面配置 [params.list] # list 頁面每頁顯示文章數量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章數目 rss = 10 # # 關於頁面配置 [params.about] # 是否啟用關於頁面的配置文件 # 依賴於取決於 .Site.Params.home.profile.enable enable = true # 是否啟用參數布局 param = true # 參數布局的標題 paramTitle = \"個人信息\" # 您網站的一般描述 # 可以用markdown樣式寫 description = \"[FeelIt](https://github.com/khusika/FeelIt) 是一個由 [Khusika](https://khusika.com) 開發的**簡潔**、**優雅**且**高效**的 [Hugo](https://gohugo.io/) 博客主題。 它的原型基於 [LoveIt 主題](https://github.com/dillonzq/LoveIt), [LeaveIt 主題](https://github.com/liuzc/LeaveIt), 和 [KeepIt 主題](https://github.com/Fastbyte01/KeepIt)。\" # 你的狀態描述 [[params.about.status]] faIcon = \"fas fa-building\" title = \"公司\" desc = \"FeelIt\" [[params.about.status]] faIcon = \"fas fa-briefcase fa-fw\" title = \"職業\" desc = \"自由職業者\" [[params.about.status]] title = \"地點\" faIcon = \"fas fa-map-marker-alt\" desc = \"地球\" # 參數說明 [[params.about.parameter]] language = \"UI/UX\" level = \"80\" [[params.about.parameter]] language = \"HTML\" level = \"70\" [[params.about.parameter]] language = \"Go\" level = \"60\" # 主頁配置 [params.home] # RSS 文章數目 rss = 10 # 主頁個人信息 [params.home.profile] enable = true # Gravatar 郵箱，用於優先在主頁顯示的頭像 gravatarEmail = \"\" # 主頁顯示頭像的 URL avatarURL = \"/images/avatar.png\" # 主頁顯示的網站標題 (支持 HTML 格式) title = \"\" # 主頁顯示的網站副標題 subtitle = \"這是我的全新 Hugo 網站\" # 是否為副標題顯示打字機動畫 typeit = true # 是否顯示社交賬號 social = true # 免責聲明 (支持 HTML 格式) disclaimer = \"\" # 主頁文章列表 [params.home.posts] enable = true # 主頁每頁顯示文章數量 paginate = 6 # display image-preview imagePreview = true # 被 params.page 中的 hiddenFromHomePage 替代 # 當你沒有在文章前置參數中設置 \"hiddenFromHomePage\" 時的默認行為 defaultHiddenFromHomePage = false # oEmbed config [params.oembed] # Privacy config (https://gohugo.io/about/hugo-and-gdpr/) privacy = false [params.oembed.facebook] # Facebook Aplication Identity and Cl","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 網站圖標, 瀏覽器配置, 網站清單 強烈建議你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目錄. 利用 https://realfavicongenerator.net/ 可以很容易地生成這些文件. 可以自定義 browserconfig.xml 和 site.webmanifest 文件來設置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定義樣式 注意 Hugo extended 版本對於自定義樣式是必需的. 通過定義自定義 .scss 樣式文件, FeelIt 主題支持可配置的樣式. 包含自定義 .scss 樣式文件的目錄相對於 你的項目根目錄 的路徑為 assets/css. 在 assets/css/_override.scss 中, 你可以覆蓋 themes/FeelIt/assets/css/_variables.scss 中的變量以自定義樣式. 這是一個例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 樣式代碼以自定義樣式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多語言和 i18n FeelIt 主題完全兼容 Hugo 的多語言模式, 並且支持在網頁上切換語言. 語言切換語言切換 \" 語言切換 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 語言 Hugo 代碼 HTML lang 屬性 主題文檔 Lunr.js 支持 德語 de de 英語 en en 西班牙語 es es 法語 fr fr 印度尼西亞 id id 意大利語 it it 波蘭語 pl pl 巴西葡萄牙語 pt-br pt-BR 羅馬尼亞語 ro ro 俄語 ru ru 塞爾維亞語 sr sr 越南語 vi vi 簡體中文 zh-cn zh-CN 波斯語 fa fa ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 學習了 Hugo如何處理多語言網站 之後, 請在 站點配置 中定義你的網站語言. 例如, 一個支持英語, 中文和法語的網站配置: # [en, zh-cn, fr, pl, ...] 設置默認的語言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 網站\" # 網站語言, 僅在這里 CN 大寫 languageCode = \"zh-CN\" languageName = \"簡體中文\" # 是否包括中日韓文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"標簽\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分類\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然後, 對於每個新頁面, 將語言代碼附加到文件名中. 單個文件 my-page.md 需要分為三個文件: 英語: my-page.en.md 中文: my-page.zh-cn.md 法語: my-page.fr.md 注意 請注意, 菜單中僅顯示翻譯的頁面. 它不會替換為默認語言內容. 技巧 也可以使用 文章前置參數 來翻譯網址. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默認的翻譯字符串 翻譯字符串用於在主題中使用的常見默認值. 目前提供一些語言的翻譯, 但你可能自定義其他語言或覆蓋默認值. 要覆蓋默認值, 請在你項目的 i18n 目錄 i18n/\u003clanguageCode\u003e.toml 中創建一個新文件，並從 themes/FeelIt/i18n/en.toml 中獲得提示. 另外, 由於你的翻譯可能會幫助到其他人, 請花點時間通過  創建一個 PR 來貢獻主題翻譯, 謝謝! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基於 Lunr.js 或 algolia, FeelIt 主題支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 輸出配置 為了生成搜索功能所需要的 index.json, 請在你的 網站配置 中添加 JSON 輸出文件類型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基於 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 這是你的 網站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的類型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章內容最長索引長度 contentLength = 4000 # 搜索框的占位提示語 placeholder = \"\" # 最大結果數目 maxResultLength = 10 # 結果內容片段長度 snippetLength = 50 # 搜索結果中高亮部分的 HTML 標簽 highlightTag = \"em\" # 是否在搜索索引中使用基於 baseURL 的絕對路徑 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎樣選擇搜索引擎? 以下是兩種搜索引擎的對比: lunr: 簡單, 無需同步 index.json, 沒有 contentLength 的限制, 但占用帶寬大且性能低 (特別是中文需要一個較大的分詞依賴庫) algolia: 高性能並且占用帶寬低, 但需要同步 index.json 且有 contentLength 的限制 文章內容被 h2 和 h3 HTML 標簽切分來提高查詢效果並且基本實現全文搜索. contentLength 用來限制 h2 和 h3 HTML 標簽開頭的內容部分的最大長度. 關於 algolia 的使用技巧 你需要上傳 index.json 到 algolia 來激活搜索功能. 你可以使用瀏覽器來上傳 index.json 文件但是一個自動化的腳本可能效果更好. Algolia Atomic 是一個不錯的選擇. 為了兼容 Hugo 的多語言模式, 你需要上傳不同語言的 index.json 文件到對應的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 FeelIt 主題中快速, 直觀地創建和組織內容.","date":"2020-03-05","objectID":"/theme-documentation-content/","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 FeelIt 主題中快速, 直觀地創建和組織內容. ","date":"2020-03-05","objectID":"/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"1 內容組織 以下是一些方便你清晰管理和生成文章的目錄結構建議: 保持博客文章存放在 content/posts 目錄, 例如: content/posts/我的第一篇文章.md 保持簡單的靜態頁面存放在 content 目錄, 例如: content/about.md 本地資源組織 本地資源引用 有三種方法來引用圖片和音樂等本地資源: 使用頁面包中的頁面資源. 你可以使用適用於 Resources.GetMatch 的值或者直接使用相對於當前頁面目錄的文件路徑來引用頁面資源. 將本地資源放在 assets 目錄中, 默認路徑是 /assets. 引用資源的文件路徑是相對於 assets 目錄的. 將本地資源放在 static 目錄中, 默認路徑是 /static. 引用資源的文件路徑是相對於 static 目錄的. 引用的優先級符合以上的順序. 在這個主題中的很多地方可以使用上面的本地資源引用, 例如 鏈接, 圖片, image shortcode, music shortcode 和前置參數中的部分參數. 頁面資源或者 assets 目錄中的圖片處理會在未來的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置參數 Hugo 允許你在文章內容前面添加 yaml, toml 或者 json 格式的前置參數. 注意 不是所有的以下前置參數都必須在你的每篇文章中設置. 只有在文章的參數和你的 網站設置 中的 page 部分不一致時才有必要這麽做. 這是一個前置參數例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位於 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位於 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章標題. subtitle: 文章副標題. date: 這篇文章創建的日期時間. 它通常是從文章的前置參數中的 date 字段獲取的, 但是也可以在 網站配置 中設置. lastmod: 上次修改內容的日期時間. draft: 如果設為 true, 除非 hugo 命令使用了 --buildDrafts/-D 參數, 這篇文章不會被渲染. author: 文章作者. authorLink: 文章作者的鏈接. description: 文章內容的描述. license: 這篇文章特殊的許可. images: 頁面圖片, 用於 Open Graph 和 Twitter Cards. tags: 文章的標簽. categories: 文章所屬的類別. featuredImage: 文章的特色圖片. featuredImagePreview: 用在主頁預覽的文章特色圖片. hiddenFromHomePage: 如果設為 true, 這篇文章將不會顯示在主頁上. hiddenFromSearch: 如果設為 true, 這篇文章將不會顯示在搜索結果中. twemoji: 如果設為 true, 這篇文章會使用 twemoji. lightgallery: 如果設為 true, 文章中的圖片將可以按照畫廊形式呈現. ruby: 如果設為 true, 這篇文章會使用 上標注釋擴展語法. fraction: 如果設為 true, 這篇文章會使用 分數擴展語法. fontawesome: 如果設為 true, 這篇文章會使用 Font Awesome 擴展語法. linkToMarkdown: 如果設為 true, 內容的頁腳將顯示指向原始 Markdown 文件的鏈接. rssFullText: 如果設為 true, 在 RSS 中將會顯示全文內容. toc: 和 網站配置 中的 params.page.toc 部分相同. code: 和 網站配置 中的 params.page.code 部分相同. math: 和 網站配置 中的 params.page.math 部分相同. mapbox: 和 網站配置 中的 params.page.mapbox 部分相同. share: 和 網站配置 中的 params.page.share 部分相同. comment: 和 網站配置 中的 params.page.comment 部分相同. library: 和 網站配置 中的 params.page.library 部分相同. seo: 和 網站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地資源引用的完整用法. 如果帶有在前置參數中設置了 name: featured-image 或 name: featured-image-preview 屬性的頁面資源, 沒有必要在設置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.webp- name:featured-image-previewsrc:featured-image-preview.jpg ","date":"2020-03-05","objectID":"/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"3 內容摘要 FeelIt 主題使用內容摘要在主頁中顯示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要預覽文章摘要預覽 \" 文章摘要預覽 ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"自動摘要拆分 默認情況下, Hugo 自動將內容的前 70 個單詞作為摘要. 你可以通過在 網站配置 中設置 summaryLength 來自定義摘要長度. 如果您要使用 CJK中文/日語/韓語 語言創建內容, 並且想使用 Hugo 的自動摘要拆分功能，請在 網站配置 中將 hasCJKLanguage 設置為 true. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"手動摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符來拆分文章生成摘要. 摘要分隔符之前的內容將用作該文章的摘要. 注意 請小心輸入\u003c!--more--\u003e ; 即全部為小寫且沒有空格. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"前置參數摘要 你可能希望摘要不是文章開頭的文字. 在這種情況下, 你可以在文章前置參數的 summary 變量中設置單獨的摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作為摘要 你可能希望將文章前置參數中的 description 變量的內容作為摘要. 你仍然需要在文章開頭添加 \u003c!--more--\u003e 摘要分割符. 將摘要分隔符之前的內容保留為空. 然後 FeelIt 主題會將你的文章描述作為摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要選擇的優先級順序 由於可以通過多種方式指定摘要, 因此了解順序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前沒有內容, 則使用描述作為摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 則將按照手動摘要拆分的方法獲得摘要. 如果文章前置參數中有摘要變量, 那麽將以該值作為摘要. 按照自動摘要拆分方法. 注意 不建議在摘要內容中包含富文本塊元素, 這會導致渲染錯誤. 例如代碼塊, 圖片, 表格等. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本語法 這部分內容在 Markdown 基本語法頁面 中介紹. ","date":"2020-03-05","objectID":"/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 擴展語法 FeelIt 主題提供了一些擴展的語法便於你撰寫文章. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 這部分內容在 Emoji 支持頁面 中介紹. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"數學公式 FeelIt 基於 $ \\KaTeX $ 提供數學公式的支持. 在你的 網站配置 中的 [params.math] 下面設置屬性 enable = true, 並在文章的前置參數中設置屬性 math: true來啟用數學公式的自動渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函數 清單. 公式塊 默認的公式塊分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈現的輸出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行內公式 默認的行內公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈現的輸出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 網站配置 中自定義公式塊和行內公式的分割符. Copy-tex Copy-tex 是一個 $ \\KaTeX $ 的插件. 通過這個擴展, 在選擇並覆制 $ \\KaTeX $ 渲染的公式時, 會將其 $ \\LaTeX $ 源代碼覆制到剪貼板. 在你的 網站配置 中的 [params.math] 下面設置屬性 copyTex = true 來啟用 Copy-tex. 選擇並覆制上一節中渲染的公式, 可以發現覆制的內容為 LaTeX 源代碼. mhchem mhchem 是一個 $ \\KaTeX $ 的插件. 通過這個擴展, 你可以在文章中輕松編寫漂亮的化學方程式. 在你的 網站配置 中的 [params.math] 下面設置屬性 mhchem = true 來啟用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈現的輸出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注釋 FeelIt 主題支持一種 字符注音或者注釋 Markdown 擴展語法: [Hugo]^(一個開源的靜態網站生成工具) 呈現的輸出效果如下: Hugo一個開源的靜態網站生成工具 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"分數 FeelIt 主題支持一種 分數 Markdown 擴展語法: [淺色]/[深色] [99]/[100] 呈現的輸出效果如下: 淺色/深色 90/100 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome FeelIt 主題使用 Font Awesome 作為圖標庫. 你同樣可以在文章中輕松使用這些圖標. 從 Font Awesome 網站 上獲取所需的圖標 class. 去露營啦! :(fas fa-campground fa-fw): 很快就回來. 真開心! :(far fa-grin-tears): 呈現的輸出效果如下: 去露營啦!  很快就回來. 真開心! ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"轉義字符 在某些特殊情況下 (編寫這個主題文檔時 ), 你的文章內容會與 Markdown 的基本或者擴展語法沖突, 並且無法避免. 轉義字符語法可以幫助你渲染出想要的內容: {?X} -\u003e X 例如, 兩個 : 會啟用 emoji 語法. 但有時候這不是你想要的結果. 可以像這樣使用轉義字符語法: {?:}joy: 呈現的輸出效果如下: :joy: 而不是 😂 技巧 這個方法可以間接解決一個還未解決的 Hugo 的 issue. 另一個例子是: [link{?]}(#escape-character) 呈現的輸出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔.","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔. Hugo 使用 Markdown 為其簡單的內容格式. 但是, Markdown 在很多方面都無法很好地支持. 你可以使用純 HTML 來擴展可能性. 但這恰好是一個壞主意. 大家使用 Markdown, 正是因為它即使不經過渲染也可以輕松閱讀. 應該盡可能避免使用 HTML 以保持內容簡潔. 為了避免這種限制, Hugo 創建了 shortcodes. shortcode 是一個簡單代碼段, 可以生成合理的 HTML 代碼, 並且符合 Markdown 的設計哲學. Hugo 附帶了一組預定義的 shortcodes, 它們實現了一些非常常見的用法. 提供這些 shortcodes 是為了方便保持你的 Markdown 內容簡潔. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文檔 一個 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" alt=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈現的輸出效果如下: Lighthouse (figure) 輸出的 HTML 看起來像這樣: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" alt=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文檔 一個 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈現的輸出效果如下: 輸出的 HTML 看起來像這樣: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文檔 一個 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈現的輸出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram At the moment, Hugo using deprecated oEmbed-legacy linked API endpoint. Those deprecated API causes an error when Hugo retrieving the data. The newest API has been included in the extended shortcode. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文檔 一個 param 示例: {{\u003c param description \u003e}} 呈現的輸出效果如下: Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文檔 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet This method was moved with the newest API in the extended shortcode documentation. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文檔 一個 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文檔 一個 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈現的輸出效果如下: Ctrl+A or Ctrl+V 總共有：3627 字 在線上修改圖片，相片，照片So Easy. 點此看 » 線上工具 | Sitemap | 聯絡我們 | 繪文字 | 許願樹 Copyright ©2022 Online Tools,All Rights Reserved. TOP GmailFacebookTwitterWhatsAppTelegramWeChatLine分享 讀取中… ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["codenotes"],"content":"本篇是我們進入 GCP 的第三篇文章，詳細的文章列表大家可以到這一篇查看 ～ 跟大家介紹一下今天的主題 Cloud Source Repositories，聽到 Source Repositories 是不是感覺跟什麼東西很像呀，沒錯，就跟我們的 GitHub or GitLab 一樣，可以用來存放我們的程式碼的儲存庫，我們來看看官方怎麼介紹他吧： 官方介紹 Cloud Source Repositories\" 官方介紹 Cloud Source Repositories 很好歐，非常簡單明瞭 🤣，沒錯，Cloud Source Repositories 就是託管在 Google Cloud 上功能齊全(？)的私有 Git 儲存庫。為什麼會打一個問號呢？是因為他其實沒有那麼好用，所以我們通常的做法，還是會依靠 GitHab 或是 GitLab 來存放程式碼，再透過鏡像 (mirror) 的方式到 Google Cloud Source Repositories。 那我們就開始囉～ ","date":"2022-07-01","objectID":"/gcp-gcsr/:0:0","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"Cloud Source Repositories 測試 ","date":"2022-07-01","objectID":"/gcp-gcsr/:1:0","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"建立 GitLab Project 首先，我們用 GitLab 來當示範，如何透過鏡像 (mirror) 到 Cloud Source Repositories 上面，我們先在 GitLab 上建立一個 Project： 建立 GitLab Project\" 建立 GitLab Project ","date":"2022-07-01","objectID":"/gcp-gcsr/:1:1","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"使用 gcloud 指令建立 Source Repo 首先，一定要先裝 gcloud 指令到本機，這個步驟，前面文章也有說過，這邊就不在說明，我們先使用一下指令來查看目前所在的 GCP 專案： gcloud config get-value project 正常來說，如果有先用 config 設定好，會直接跳出你目前的專案 ID，如果沒有跳出來，請使用下面指令來設定： gcloud config set project \u003cproject id\u003e 接著我們要啟動該專案的 Cloud Source Repositories API： gcloud services enable sourcerepo.googleapis.com 創建 Cloud Source Repositories gcloud source repos create \u003crepo name\u003e 完成後，開啟 GCP 檢查一下是否有建立成功～點擊左側 menu \u003e Source Repositories， 開啟 Source Repositories\" 開啟 Source Repositories 成功建立 Source Repositories\" 成功建立 Source Repositories ","date":"2022-07-01","objectID":"/gcp-gcsr/:1:2","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"將程式碼新增至存放區中 我們要在這一步來設定鏡像 (mirror)，首先我們看剛剛上面建立好的 Source Repositories，其中有一個手動產生的憑證，點選 產生及儲存 Git 憑證 產生及儲存 Git 憑證\" 產生及儲存 Git 憑證 點完後會需要先登入你的 GCP 帳號，登入完後會出現以下內容： Configure Git\" Configure Git 接著把藍色框框內的輸入到終端機內 Configure Git\" Configure Git 接著請複製以下指令貼到終端機內，會生成憑證密碼： grep 'source.developers.google.com' ~/.gitcookies | tail -1 | cut -d= -f2 生成憑證密碼\" 生成憑證密碼 接著請複製以下指令貼到終端機內，將用戶名存儲在 CSR_USER 環境變量中： CSR_USER=$(grep 'source.developers.google.com' ~/.gitcookies | \\ tail -1 | cut -d$'\\t' -f7 | cut -d= -f1) 用戶名存儲在 CSR_USER 環境變量中\" 用戶名存儲在 CSR_USER 環境變量中 接著請複製以下指令貼到終端機內，將 GCP 存儲庫的 URL 存儲在 CSR_REPO 環境變量中 (repo name 要改成你在 gcp 上面的 repo)： CSR_REPO=$(gcloud source repos describe \u003crepo name\u003e --format=\"value(url)\") 將 GCP 存儲庫的 URL 存儲在 CSR_REPO 環境變量中\" 將 GCP 存儲庫的 URL 存儲在 CSR_REPO 環境變量中 接著請複製以下指令貼到終端機內，將存儲庫的 URL（包括用戶名）印到終端機上： echo $CSR_REPO | sed \"s/:\\/\\//:\\/\\/${CSR_USER}@/\" 存儲庫的 URL（包括用戶名）印到終端機上\" 存儲庫的 URL（包括用戶名）印到終端機上 經過上面操作，我們可以在第 4 步驟拿到密碼，以及在第 7 步驟拿到完整的 GCP URL，接著我們要到 GItLab Mirror 來設定鏡像。 ","date":"2022-07-01","objectID":"/gcp-gcsr/:1:3","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"到 GitLab Mirror 設定鏡像 先從右側 muen \u003e 選擇 Settings \u003e 點選 Repository，找到 Mirroring repositories GitLab Mirror 設定鏡像\" GitLab Mirror 設定鏡像 將剛剛拿到的 URL 以及密碼各別輸入 Git repository URL 以及 Password，記得要選擇 Mirror direction，因為我們是要將 gitlab 的鏡像到 GCP 的 Cloud Source Repositories，所以我們要選擇 PUSH，最後按下 Mirror repository： GitLab Mirror 設定鏡像\" GitLab Mirror 設定鏡像 如果沒有跳出錯誤，基本上是沒有問題了！ GitLab Mirror 檢查\" GitLab Mirror 檢查 就可以試著在 gitlab 上面推程式，看看有沒有跑到 Cloud Source Repositories 上面囉！ GitLab 推程式測試\" GitLab 推程式測試 ","date":"2022-07-01","objectID":"/gcp-gcsr/:1:4","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"參考資料 Cloud Source Repositories documentation Mirroring GitLab repositories to Cloud Source Repositories ","date":"2022-07-01","objectID":"/gcp-gcsr/:2:0","tags":["GCP","Source Repositories","git"],"title":"Google Cloud Platform (GCP) 百科全書  - Cloud Source Repositories [ EP.3 ]","uri":"/gcp-gcsr/"},{"categories":["codenotes"],"content":"本篇是我們進入 GCP 的第二篇文章，詳細的文章列表大家可以到這一篇查看 ～ 跟大家介紹一下今天的主題 Google Compute Engine(GCE)，GCE 是 Google Cloud 上的基礎架構服務 (IaaS)，該平台可以提供大規模的虛擬機器以及相關的基礎建設 (包含硬碟、網路、附載平衡器… 等等)來建置及運作您的服務，那我們可以將 GCE 服務的主要功能劃分成以下幾點： ","date":"2022-06-29","objectID":"/gcp-gce/:0:0","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"Google Compute Engine 特色 ","date":"2022-06-29","objectID":"/gcp-gce/:1:0","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"穩健的網路功能 提供使用者擁有穩健的網路功能，以運行各項應用程式及服務。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:1","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"自訂網路與預設網路 GCE 包含內部與外部的網路連線能力，讓使用者可以透過自訂規劃來建置屬於自己服務適用的網路，而在 GCE 服務開通當下，也提供預設的 default network，內建常用的路由與防火牆設定 (例如：SSH、RDP、ICMP… 等)，供入門使用者直接使用。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:2","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"防火牆規則 除了預設防火牆規則外，使用者也可以透過自建防火牆來開放可以連入的 IP。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:3","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"各區域的 HTTP(S) 的負載平衡 為 Layer 7 的負載平衡設備，透過設定可以串連多台主機或是主機群組，讓服務不再只是依賴於單點存在的伺服器。Layer 7 的負載平衡更可以識別路由規劃，進一步可以提供不同路由的重導規則設定，也可以提供 CDN 的 Cache 功能。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:4","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"網路的負載平衡 為 Layer4 的負載平衡設備，可以透過 Protocol 與 Port 的方式來重導外部流量到 GCE 主機或主機群，並可以透過 Health Check 的方式，讓流量僅通過健康的主機，避免服務中斷。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:5","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"子網路 透過 CIDR 的方式設定 GCE Network 中的各子網路範圍，並可以透過路由的方式串接各子網路中間的通訊，讓 GCE 網路的設計規劃可以更有彈性，也可以讓子網路的規劃來實作更安全的雲端網路架構。 ","date":"2022-06-29","objectID":"/gcp-gce/:1:6","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"Google Compute Engine 測試 首先我們使用 cloudskillsboost 提供的 Creating a Virtual Machine 來做練習，打開後，請先登入自己的 Google 帳號，接著點選左上角的 Start Lab，會跳出與下面圖片類似的內容： 測試用的帳號密碼\" 測試用的帳號密碼 ","date":"2022-06-29","objectID":"/gcp-gce/:2:0","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"新增新的 VM 實例 點選 Open Google Console 按鈕來開啟 GCP 主控台 登入帳號就使用上面圖片所提供的帳號密碼來進行登入 登入成功會進入 GCP 主控台，點選左側的 menu \u003e Compute Engine \u003e VM Instances，可以參考下方圖片 新增 VM 實例\" 新增 VM 實例 點選 CREATE INSTANCE，請依照下方表格來進行設定： 標題 設定值 說明 Name gcelab 虛擬機實例的名稱 Region us-central1（愛荷華州） 有關區域的更多信息，請參閱 Compute Engine 指南 Regions and zones Zone us-central1-f Series N1 Machine type n1-standard-2 這是一個 2 vCPU、7.5 GB RAM 實例 Boot disk New balanced persistent disk/10 GB/Debian GNU/Linux 10 Firewall Allow HTTP taffic VM 實例 (Name、Region、Zone、Series)\" VM 實例 (Name、Region、Zone、Series) VM 實例 (Machine type、Boot disk、Firewall)\" VM 實例 (Machine type、Boot disk、Firewall) 新增完後，大約需要等待一分鐘，新的虛擬機就會列在 VM Instances 頁面上。 VM 實例\" VM 實例 ","date":"2022-06-29","objectID":"/gcp-gce/:2:1","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"安裝 NGINX Web 服務器 點擊 VM instances 實例最後的 SSH，會開啟 SSH 用戶端 在 SSH 終端，要先獲得 root 訪問權限，才更方便的進行後續的動作，請先使用一下指令： sudo su - 利用 root 用戶，來更新操作系統： apt-get update 更新操作系統\" 更新操作系統 安裝 NGINX： apt-get nginx -y 安裝 NGINX\" 安裝 NGINX 最後確認 NGINX 是否運行： ps auwx | grep nginx 確認 NGINX 是否運行\" 確認 NGINX 是否運行 可以打開瀏覽器瀏覽 http://外部 IP/ 或是使用 curl 外部IP，外部 IP 會在跟剛剛 VM 實例的 External IP 欄位呦～ curl 外部 IP\" curl 外部 IP 完成後，記得可以點選 Check my progress 來檢查進度吧！ Check my progress\" Check my progress ","date":"2022-06-29","objectID":"/gcp-gce/:2:2","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"使用 gcloud 創建一個新實例 我們剛剛是使用網頁版來新增，當然也可以使用 gcloud 指令來新增，這個工具有預先裝在 Google Cloud Shell 中。Cloud Shell 是一個基於 Debian 的虛擬機，包含了常用的開發工具 (gcloud、git 等工具)，另外你也可以將 gcloud 下載至本機上來做使用，請閱讀gcloud 命令行工具指南 在 Cloud Shell 中，使用 gcloud 來新增新的虛擬機實例： gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone us-central1-f 就會跳出以下圖片的內容，過一陣子去查看 VM Instances 也可以看到我們所新增的虛擬機實例歐～ Check my progress\" Check my progress 到這邊就完成了我們 Google Compute Engine 測試囉～我們知道可以新增 GCE 將實體主機的內容，移植到雲端上囉！希望大家會喜歡今天的文章 🥰 ","date":"2022-06-29","objectID":"/gcp-gce/:2:3","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"參考資料 Compute Engine基本介紹 Creating a Virtual Machine ","date":"2022-06-29","objectID":"/gcp-gce/:3:0","tags":["GCP","GCE"],"title":"Google Cloud Platform (GCP) 百科全書  - Compute Engine [ EP.2 ]","uri":"/gcp-gce/"},{"categories":["codenotes"],"content":"本篇是我們進入 GCP 的第一篇文章，詳細的文章列表大家可以到這一篇查看 ～ IAM 的全名是 Identity and Access Management，當我們藉由 IAM，可以授與特定 Google Cloud 資源的 精細 訪問權限，並防止對其他資源的訪問。疑！？為什麼是精細？我們接著看下去，我們可以採用最小權限安全原則，該原則要求任何人都不應擁有超出實際所需的權限。 ","date":"2022-06-29","objectID":"/gcp-iam/:0:0","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"IAM 的工作原理 首先我們先來了解一下 IAM 的工作原理，藉由 IAM，我們可以定義誰 (哪一個身份) 對哪些資源有哪種的訪問權限 (角色) 來管理訪問權限控制。什麼是資源？例如， Compute Engine 虛擬機 (GCE)、Google Kubernetes Engine (GKE) 集群和 Cloud Storage 存儲分區都是 Google Cloud 資源，我們用於整理資源的組織或資料夾、項目等也都是資源 GCP IAM Logo\" GCP IAM Logo 我們可以把它理解成 引用 什麼 『 人 』，可以對什麼『 資源 』，做什麼『 事情 』 IAM 不會直接向用戶授與資源的訪問權限，而是將權限分成多個角色，然後將這些角色授與經過身份驗證的主帳號。(以前 IAM 會將主帳號稱為成員，目前部分 API 仍然使用此術語。) IAM 中的權限管理\" IAM 中的權限管理 可以看到這張圖片，訪問權限管理主要包含三個部分： 主帳號 (Principal)：主帳號可以是 Google 帳號 (針對用戶)、服務帳號 (針對應用和計算工作負載)、Google 群組或 Workspace 帳號或可以訪問資源的 Cloud Identity 網域等等 角色 (Role)：一個角色對應一組權限，權限決定了可以對資源執行的操作。向主帳號授與某個腳色， 代表授與該角色包含的所有權限給主帳號 政策 (Policy)：允許政策 (Allow Policy) 是將一個或多個主體綁定在各個角色，當想要定義誰 (主體) 對資源擁有何種類型的訪問 (角色) 時，可以創建允許政策並將其附加到資源。 ","date":"2022-06-29","objectID":"/gcp-iam/:1:0","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"IAM 測試 接下來，我們來測試看看 IAM 實際設定以及用途吧！ 我們會使用 GCP 所以提供的 [Qwiklabs] Cloud IAM：Qwik Start 來進行測試，之後的步驟會跟 Cloud IAM：Qwik Start 內容一樣，所以大家可以邊操作邊參考呦！那我們開始囉 🙃 進入網頁後，請先登入自己的 Google 帳號，接著點選左上角的 Start Lab，會跳出與下面圖片類似的內容： 測試用的帳號密碼\" 測試用的帳號密碼 這邊會提供兩組的帳號及密碼，分別是 Username1 以及 Username2 (後面會以 Username 1 跟 2 來說明)，密碼會用共用，且會在同一個專案下。 ","date":"2022-06-29","objectID":"/gcp-iam/:2:0","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"用第一個 Username1 登入 GCP 點選 Open Google Console 按鈕來開啟 GCP 主控台 登入的帳號就輸入第一個 Username1 ，密碼輸入共用密碼 ，最後登入 登入成功會進入 GCP 主控台，會跳出下方圖片內容，國家選擇台灣，點選同意 Terms of Service，最後按 AGREE AND CONTINUE 登入 Username 1 GCP 主控台\" 登入 Username 1 GCP 主控台 ","date":"2022-06-29","objectID":"/gcp-iam/:2:1","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"用第二個 Username2 登入 GCP 步驟與第一個相同，這邊就不在重複，但建議使用無痕，避免 Username1 跟 Username2 搶來搶去，以及登入帳號要選 Username2，應該不會選錯吧 🤣 ","date":"2022-06-29","objectID":"/gcp-iam/:2:2","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"Username1 IAM 主控台 到 Username1 的 GCP 主控台首頁 點選左側的 menu \u003e IAM 與管理 點擊頁面上方的 +ADD 按鈕，可以從下拉選單去查看各式各項的專案相關角色，可以看到超級多的角色設定，所以我們一開始才會說他是可以設定 ** 精細** 的訪問權限 我們選擇 Base，右側有 4 種角色，分別是瀏覽者 (Browser)、編輯者 (Editor)、所有者 (Owner)、檢視者 (Viewer)，詳細區別請看下面 👇👇 ADD IAM\" ADD IAM 此表是取 Google Cloud IAM 文章基本角色中的定義，簡單說明 4 種角色的差別： 角色名稱 權限 role/viewer (檢視者) 不影響狀態的只讀操作權限，例如：查看 (但不修改) 現有資源或是資料 role/editor (編輯者) 所有查看者權限，以及修改狀態的操作權限，例如：更改現有資源 role/owner (擁有者) 以下操作的所有編輯權限： 1. 管理項目和項目內的所有資源角色及權限 2. 為項目設置帳單 role/browser (瀏覽者) 讀取權限以及瀏覽項目的層次結構，包含資料夾、組織和 IAM 政策。但此角色不包含查看項目中資源的權限 我們的 Username1 為 owner，Username2 為 viewer 注意 Google 建議：Base 角色包含所有 Google Cloud 服務的數千個權限。除非別無選擇，否則不要授與用戶 Base 角色，請設定最有限的自訂義角色或是可以滿足該需求的角色即可 ","date":"2022-06-29","objectID":"/gcp-iam/:2:3","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"切換到 Username2 IAM 主控台 我們可以在表格裡面收尋 Username1 跟 Username2 的帳號，可以看一下他們授與的角色是否與上面說的一致，大概可以參考以下圖片： Username1 跟 Username2 權限\" Username1 跟 Username2 權限 在 Username2 因為是 Viewer 權限，所以點擊上面的 + ADD，不會反應，會跳出以下照片內容： Username2 權限不足\" Username2 權限不足 ","date":"2022-06-29","objectID":"/gcp-iam/:2:4","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"再切回 Username1 Cloud Storage 接下來我們要建立一個 GCS 儲存空間，點選 menu \u003e Cloud Storage \u003e Browser 點選 Create a bucket 給予他一個獨特的名稱，以及在 Choose where to store your data 選擇 Multi-Region 最後點選 CREATE Create a bucket\" Create a bucket ","date":"2022-06-29","objectID":"/gcp-iam/:2:5","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"上傳範例檔案 進入新建立的 Cloud Storage，點選 Upload fiiles 按鈕 上傳一個 txt 檔案，可以先取名為 sample.txt，或是上傳後使用最後三個小點圖案內的 Rename 來修改名稱 Upload sample.txt fiiles\" Upload sample.txt fiiles ","date":"2022-06-29","objectID":"/gcp-iam/:2:6","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"驗證專案檢視者存取權限 我們再切換回 Username2 的主控台，選擇 menu \u003e Cloud Storage \u003e Browser 就可以看到跟上面一樣的儲存區 Username2 被授與 “檢視者 Viewer” 角色，這個角色有不影響狀態的只讀權限。這個範例中說明這個功能，他僅能檢視，沒有辦法上傳 ","date":"2022-06-29","objectID":"/gcp-iam/:2:7","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"移除專案存取權限 我們再次切回 Username 主控台，選擇 menu \u003e IAM 與管理 ，找到 Username2 旁邊的鉛筆圖案 修改 Username2 權限\" 修改 Username2 權限 點擊角色名稱的垃圾桶來移除 Username2 的檢視者權限，點擊 Save 移除 Username2 權限\" 移除 Username2 權限 提醒 這個動作要完成生效到所有服務上，所以會需要一點時間，詳細可以參考點我 ","date":"2022-06-29","objectID":"/gcp-iam/:2:8","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"檢查 Username2 是否有存取權限 切換到 Username2 主控台，選擇 menu \u003e Cloud Storage \u003e Browser 會發現出現以下的錯誤訊息，代表我們移除權限成功 Username2 沒有權限\" Username2 沒有權限 ","date":"2022-06-29","objectID":"/gcp-iam/:2:9","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"新增儲存角色 我們再次切換到 Username1 主控版，選擇 menu \u003e \u003e IAM 與管理，點選上方 + ADD，在 New principals 上貼上 Username2 的帳號，Role 選擇 Storage Object Viewer 新增 Username2 角色\" 新增 Username2 角色 查看 Username2 權限\" 查看 Username2 權限 ","date":"2022-06-29","objectID":"/gcp-iam/:2:10","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"檢查 Username2 是否有存取權限 切換到 Username2 主控台，因為 Username2 沒有專案檢視者的角色，所以看不到專案以及任何的資源，但這個使用者對我們剛剛設定的 Cloud Storage 有特別的存取權 打開右上角的 Activate Cloud Shell 命令列工具 ，如下圖： 開啟 Activate Cloud Shell 命令列工具\" 開啟 Activate Cloud Shell 命令列工具 輸入以下指令 gsutil ls gs://\u003c剛剛建的 Cloud Storage 名稱\u003e 如果出現跟下方圖片一樣，就代表我們設定成功囉！ Username2 Storage Object Viewer 權限\" Username2 Storage Object Viewer 權限 最後的最後，如果有跟我們一步一步來的朋友，在 [Qwiklabs] Cloud IAM：Qwik Start 頁面中，應該會看到一個叫 Check my progress 的按鈕，做完每一步驟，都可以點一下，他會自動去判斷你是否有完成這項動作歐！ Check my progress\" Check my progress 到這邊就完成了我們在 IAM 的測試囉～我們知道 IAM 可以設定很多的角色，以及測試了查看、新增、修改、刪除角色的功能，希望大家會喜歡今天的文章 🥰 ","date":"2022-06-29","objectID":"/gcp-iam/:2:11","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"參考資料 IAM 概覽 什麼是 Cloud IAM？GCP 權限管理服務介紹 ","date":"2022-06-29","objectID":"/gcp-iam/:3:0","tags":["GCP","IAM"],"title":"Google Cloud Platform (GCP) 百科全書  - IAM 與管理 [ EP.1 ]","uri":"/gcp-iam/"},{"categories":["codenotes"],"content":"哈囉大家好，我們在之前的文章有講到 Docker、K8s 等等，我們都是在本機來測試，但實際上，現在很多公司或服務都遷移到雲端上，那我們這次要帶領大家到雲端的世界，本次要介紹的就是 Google Cloud Platform (GCP) ，是 Google 在雲端上提供的一組產品與服務，讓您能夠在雲端上使用與 Google 相同的技術和基礎架構，預先準備好各式服務的基本元件，讓您能夠快速上手開發及使用。 Google Cloud Platform (GCP) Logo\" Google Cloud Platform (GCP) Logo 提一個他最大的優點就是彈性，你隨時隨地想要幾台機器，GCP 都可以立即開給你。 可以試想一下，假設明天遊戲公司要推出新遊戲，預估有200萬人要上線，那我們要預先準備幾台機器呢？ 再來，如果準備好支援200萬人的機器，結果來了500萬人，要怎麼辦呢？或是只有20萬人上線，其他多餘的機器要怎麼辦？ 等等的問題，GCP 都可以透過他的自動擴充來依照目前使用量自動調整機器的數量，流量大時自動加開，流量小自動縮減機器。很酷吧 😁 接下來的文章，會介紹常見在 GCP 中的工具以及實作內容，該文章下方會不定期更新所有文章連結，歡迎大家可以關注此篇文章呦！😍 ","date":"2022-06-28","objectID":"/gcp-introduce/:0:0","tags":["GCP","GKE","K8s"],"title":"Google Cloud Platform (GCP) 百科全書  - 介紹與開頭 [ EP.0 ]","uri":"/gcp-introduce/"},{"categories":["codenotes"],"content":"文章連結 Google Cloud Platform (GCP) 百科全書 - IAM 與管理 [ EP.1 ] Google Cloud Platform (GCP) 百科全書 - Compute Engine [ EP.2 ] Google Cloud Platform (GCP) 百科全書 - Cloud Source Repositories [ EP.3 ] ","date":"2022-06-28","objectID":"/gcp-introduce/:1:0","tags":["GCP","GKE","K8s"],"title":"Google Cloud Platform (GCP) 百科全書  - 介紹與開頭 [ EP.0 ]","uri":"/gcp-introduce/"},{"categories":["codenotes"],"content":"參考資料 一堂課了解 Google 雲端全貌 - GCP 是什麼 ","date":"2022-06-28","objectID":"/gcp-introduce/:2:0","tags":["GCP","GKE","K8s"],"title":"Google Cloud Platform (GCP) 百科全書  - 介紹與開頭 [ EP.0 ]","uri":"/gcp-introduce/"},{"categories":["codenotes"],"content":"當我們在使用 Git 時，常常修改完內容後，會推 commit 到 github or gitlab，在一個分支上開發久了， commit 會累積很多，很雜且很亂，所以我們可以試著將 commit 給合併。 大家可以使用這個檔案來做練習：點我 GoGo 😉 git commit\" git commit 可以看到上面這張圖，這個與範例檔案的 commit 相似(不同專案，所以 SHA-1 也會不同，為了模擬所以 commit 相同而已)，我們模擬在同一個分支底下，有很多的 commit，那我們試著把他給合併起來。先說明一下目前的 commit 狀況，我們在 master 分支上有 3 個 commit，且已經推到遠端上。所以我們本地修改後，還要讓遠端的也合併，這個步驟要怎麼做呢？大家可以先想想看，後面會告訴大家答案 🥰 ","date":"2022-06-21","objectID":"/git-merge-multiple-commit/:0:0","tags":["Git","指令","介紹"],"title":"如何合併多個 commit，且推到遠端呢？","uri":"/git-merge-multiple-commit/"},{"categories":["codenotes"],"content":"合併本地端 commit 首先我們目的是想要讓 add 2.txt 與 add 3.txt 的 commit 合併成 add txt，可以先使用以下指令來找到他的 commit 的 SHA-1： git log git log 查看 commit 的 SHA-1\" git log 查看 commit 的 SHA-1 要怎麼合併呢？我們先使用 rebase 到不會變動的 commit，也就是 add 1.txt 這個 commit： git rebase -i 3b5bab9d5fb65b965ae55236734103b178f9daf2 git rebase\" git rebase 下完後，會跳出上面圖片內容，可以看到上面是 rebase interactive (-i) 要執行的指令，下面是每個指令的簡單說明，我們本次會使用的只有 pick 以及 squash，分別的意思是： pick：會執行該 commit。 squash：會把這個版本的 commit 合併到前一個 commit。 所以我們要將它改成以下： pick f8e5882 add 2.txt squash 3eb0ef4 add 3.txt 也就是將 3eb0ef4 這個版本的 commit 合併到 f8e5882 的 commit，對應我們的例子，將 add 3.txt 合併到 add 2.txt 這個 commit。 儲存離開後，會跳出以下的畫面，他會告訴你原本兩個的 commit message 分別是 add 2.txt 以及 add 3.txt，這時候我們要輸入新的 commit message，也就是 add txt，建議可以把原本的訊息註解掉。 輸入新的 commit\" 輸入新的 commit 儲存後，我們查看 git log，就可以看到我們將 add 2.txt 跟 add 3.txt 合併成 add txt 😝 查看目前合併狀態的 git log\" 查看目前合併狀態的 git log ","date":"2022-06-21","objectID":"/git-merge-multiple-commit/:1:0","tags":["Git","指令","介紹"],"title":"如何合併多個 commit，且推到遠端呢？","uri":"/git-merge-multiple-commit/"},{"categories":["codenotes"],"content":"合併遠端 commit 可以看到下方是我們已經將本機端的 commit 給合併，但遠端還是一樣有 3 個 commit，如果我們就這樣直接推上去，只會多一次的 commit，所以我們該怎辦呢 ? 遠端與本地端的 commit 不同\" 遠端與本地端的 commit 不同 我們就是要使用大家都害怕的： git push -f 強制覆蓋掉分支上的內容，但切記切記，這個只適用於自己的分支上歐～不然會直接大爆炸 💣 使用 git push -f 後的 commit\" 使用 git push -f 後的 commit ","date":"2022-06-21","objectID":"/git-merge-multiple-commit/:2:0","tags":["Git","指令","介紹"],"title":"如何合併多個 commit，且推到遠端呢？","uri":"/git-merge-multiple-commit/"},{"categories":["codenotes"],"content":"參考資料 如何合併多個commits 【狀況題】聽說 git push -f 這個指令很可怕，什麼情況可以使用它呢？ ","date":"2022-06-21","objectID":"/git-merge-multiple-commit/:3:0","tags":["Git","指令","介紹"],"title":"如何合併多個 commit，且推到遠端呢？","uri":"/git-merge-multiple-commit/"},{"categories":["codenotes"],"content":"因為最近在管理機器時，常常會使用各式各樣的指令來協助管理，所以把常用的指令依照不同類別整理在底下呦 😘 會定期更新該文章呦 ~ ","date":"2022-06-17","objectID":"/linux/:0:0","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"網路類 ","date":"2022-06-17","objectID":"/linux/:1:0","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"查詢遠端 Port 是否開放 nc (netcat) nc (netcat)，可以讀取經過 TCP 及 UDP 的網路連線資料，是一套很實用的網路除錯工具。 安裝指令： yum install nc 檢查 Port 是否有開放，可以用以下指令來查詢： nc -zvw3 \u003cIP:Port\u003e -z 只進行掃描，不進行任何的資料傳輸 -v 顯示掃描訊息 -w3 等待 3 秒 如果 Port 有開放，會回傳以下內容： Ncat: Version 7.50 ( https://nmap.org/ncat ) Ncat: Connected to \u003cIP:Port\u003e. Ncat: 0 bytes sent, 0 bytes received in 0.01 seconds. 如果沒有開放，會回傳以下內容： Ncat: No route to host. nmap nmap (Network Mapper) 是另一個可以檢查 Port 的工具，安裝語法是這樣： yum install nmap 檢查 Port 是否有開放，可以用以下指令來查詢： nmap \u003cIP\u003e -p \u003cPort\u003e 如果 Port 有開放，會回傳以下內容： Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-17 16:06 CST Nmap scan report for\u003cDomain\u003e (\u003cIP\u003e) Host is up (0.0039s latency). PORT STATE SERVICE 80/tcp open http Nmap done: 1 IP address (1 host up) scanned in 1.09 seconds 如果沒有開放，會回傳以下內容： Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-17 16:06 CST Nmap scan report for\u003cDomain\u003e (\u003cIP\u003e) Host is up (0.0039s latency). PORT STATE SERVICE 80/tcp filtered http Nmap done: 1 IP address (1 host up) scanned in 1.09 seconds Telnet Telnet 也是一個可以檢查 Port 的工具，安裝語法是這樣： yum install telnet 檢查 Port 是否有開放，可以用以下指令來查詢： telnet \u003cIP\u003e \u003cPort\u003e 如果 Port 有開放，會回傳以下內容： Trying \u003cIP\u003e… Connected to \u003cIP\u003e. Escape character is ‘^]’. ^CConnection closed by foreign host. 如果沒有開放，會回傳以下內容： Trying \u003cIP\u003e… telnet: Unable to connect to remote host: Connection refused ","date":"2022-06-17","objectID":"/linux/:1:1","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"系統類 ","date":"2022-06-17","objectID":"/linux/:2:0","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"顯示當前進程狀態 ps ps [參數] -A 列出所有的進程 -w 可以加寬顯示較多的訊息 -au 顯示更詳細的訊息 -aux 顯示所有包含其他用戶的進程 au(x) 輸出的格式： USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER：行程的擁有者 PID：pid %CPU：佔用的 CPU 使用率 %MEM：佔用的記憶體使用率 VSZ：佔用的虛擬記憶體大小 RSS：佔用的記憶體大小 TTY：終端的次要裝置號碼 STAT：該行程的狀態： D：無法中斷的休眠狀態 (通常都是 IO 進程) R：正在執行中 S：靜止狀態 T：暫停執行 Z：不存在但暫時無法消除 W：沒有足夠的記憶體可以分配 \u003c：高優先序的進程 N：低優先序的進程 START：進程開始時間 TIME：執行的時間 COMMAND：所執行的指令 ","date":"2022-06-17","objectID":"/linux/:2:1","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"刪除執行中的進程 kill kill [-s \u003c訊息名稱或編號\u003e] [程序] or [-l \u003c訊息編號\u003e] -l \u003c訊息編號\u003e：若不加 \u003c訊息編號\u003e選項，-l 會列出全部的訊息名稱 -s \u003c訊息名稱或編號\u003e：指定要送出的訊息 最常用的訊息是 1 (HUP)：重新加載進程 9 (KILL)：刪除一個進程 15 (TERM)：正常停止一個進程 ","date":"2022-06-17","objectID":"/linux/:2:2","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"參考資料 3 種檢查遠端埠號是否開啟的方法 ","date":"2022-06-17","objectID":"/linux/:3:0","tags":["Linux","指令","介紹"],"title":"Linux 常用指令","uri":"/linux/"},{"categories":["codenotes"],"content":"今天在工作時，遇到機器的 Swap 超過預警值，需要手動去清除 Swap，那剛好就由這次機會來介紹要如何清除 Linux 機器上的 Swap，以及查詢 Linux 記憶體的使用狀況！ ","date":"2022-06-06","objectID":"/linux-clear-swap/:0:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"如何查詢 Linux 記憶體 在講 Swap 之前，我們先來說一下怎麼查詢 Linux 記憶體，可以使用以下指令來顯示： free 下完後，格式會長這樣： total used free shared buff/cache available Mem: 32765564 8499252 1825132 1857720 22441180 19693100 Swap: 16776188 0 16776188 但這樣子不是很好觀察，所以我們可以加上 -h 來顯示大小的單位，讓我更清楚的知道每一個的大小： total used free shared buff/cache available Mem: 31G 8.1G 1.6G 1.8G 21G 18G Swap: 15G 0B 15G 那我們接著先來說說使用 free 查詢後，所有欄位的意思吧！ ","date":"2022-06-06","objectID":"/linux-clear-swap/:1:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"free 第一列 Mem：記憶體的使用資訊 Swap：交換空間的使用資訊 ","date":"2022-06-06","objectID":"/linux-clear-swap/:1:1","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"free 第一行 total：系統總共的可用實體記憶體大小 used：已被使用的實體記憶體大小 free：還剩下多少可用的實體記憶體 shared：被共享使用的實體記憶體大小 buff/cache：被 buffer 和 cache 使用的實體記憶體大小 available：可被 應用程式 使用的實體記憶體大小 ","date":"2022-06-06","objectID":"/linux-clear-swap/:1:2","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"buff 跟 cache 以及 Swap 的比較 比較 buff cache Swap 功用 記憶體寫完資料會先暫存起來，等之後再定期將資料存到硬碟上 記憶體讀完資料後暫存起來，可以在下此查詢時快速的顯示 硬碟的交換分區，當 buff/cache 記憶體已經用完後，又有新的讀寫請求時，就會將部份內存的資料存入硬碟，也就是把內存的部分空間當成虛擬的記憶體來做使用 ","date":"2022-06-06","objectID":"/linux-clear-swap/:2:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"free 與 available 的比較 free：是真正尚未被使用的實體記憶體數量 available：是應用程式認為可用的記憶體數量，可以理解成 available = free + buff/cache 接下來我們就要進入主題，如何清除 Swap ： ","date":"2022-06-06","objectID":"/linux-clear-swap/:3:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"清除 Swap 首先第一步我們先使用 free 來查看目前的 Swap 使用狀態： Swap 使用 (尚未清除)\" Swap 使用 (尚未清除) 可以看到我們的 Swap used 是 797M，我們設定它不能超過 5%，超過就會通知，所以我們要把它手動清除。 ","date":"2022-06-06","objectID":"/linux-clear-swap/:4:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"先檢查記憶體 available 為什麼要先檢查 available，是因為一開始會使用到 Swap 的原因就是因為應用程式的可用記憶體空間不足，所以現在要清除 Swap 條件就是：Mem 的 available 必須要大於 Swap 的 used 才可以，否則會導致記憶體爆炸 💥 ","date":"2022-06-06","objectID":"/linux-clear-swap/:4:1","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"將記憶體資料暫存到硬碟 接下來因為我們要清除 Swap ，所以不能讓資料在寫入記憶體中，所以我們先使用下方指令，讓記憶體的資料暫存到硬碟。 sync 這個指令就是將存於暫存的資料強制寫入到硬碟中，來確保清除時導致資料遺失。 ","date":"2022-06-06","objectID":"/linux-clear-swap/:4:2","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"關閉 Swap，再打開 Swap 沒錯，Swap 的清除就是把他先關掉，再重新打開，他就會自己清除 Swap 的資料了！使用的指令如下：(清除過程需要稍等，讓他進行刪除動作) swapoff -a \u0026\u0026 swapon -a 確認都沒問題後，我們就使用 free 來重新查看記憶體狀態： Swap 使用 (已清除)\" Swap 使用 (已清除) 可以看到我們清除完 Swap 後，Swap 的 used 已經從 797M 變成 0B。 小提醒 如果碰到執行 swapoff -a \u0026\u0026 swapon -a 出現 swapoff: Not superuser.，只需要在指令前面加上 sudo 就可以了！ ","date":"2022-06-06","objectID":"/linux-clear-swap/:4:3","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"參考資料 Linux內存、Swap、Cache、Buffer詳細解析 linux free 命令下free/available區別 釋放linux的swap記憶體 ","date":"2022-06-06","objectID":"/linux-clear-swap/:5:0","tags":["Linux","Swap","Cache","Buff","實作","介紹"],"title":"清除 Linux 機器上的 Swap  (Buff、Cache、Swap 比較)","uri":"/linux-clear-swap/"},{"categories":["codenotes"],"content":"前陣子對於 Kubernetes 部分內容還不是很清楚，在網路上閒逛的時候發現一篇很有趣的文章，標題是 『 給行銷跟業務的 Kubernetes 101 中翻中介紹 』，點進去後才發現，作者 Phil Huang 將 Kubernetes 元件的內容用大型住戶社區來介紹，讓我更清楚每一個元件的意思，以下我會用我理解的以及作者的思考邏輯來去寫這篇筆記，再次感謝作者文章 😍 ","date":"2022-06-02","objectID":"/k8s-plain/:0:0","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Kubernetes 元件白話文 大型社區示意圖 (圖片來源：蘋果地產)\" 大型社區示意圖 (圖片來源：蘋果地產) 可以看到上面這張圖片，他是一個很典型的大型社區，我們這次的 Kubernetes 元件白話文，會以大型社區來當作現實中的元件，以社區的例子來說明 Kubernetes 。 當然，我們之前的文章也有介紹過 Kubernetes，有興趣可以先飛回去看看！ Kubernetes (K8s) 介紹 - 基本 Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap) Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet) 我們先想像一下我們建立 Kubernetes 完整的叢集服務，就好比是建立一個大型的社區，所以以下會將名詞與社區來做連結，那．．．開始囉！ ","date":"2022-06-02","objectID":"/k8s-plain/:1:0","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Kubernetes 元件 Kubernetes：建立這個大型社區的藍圖，規劃的社區內的大大小小的設計。 虛擬化平台、公有雲平台、實體機器：就是我們要蓋社區的地皮。(虛擬化平台：vSphere/Proxmox/VMware、公有雲平台：AWS/GCP/Azuer、實體機器：就是實體機器 😂) OS 作業系統：每棟大樓的骨架和地基。 Master Node：住戶管委會所居住大樓 (真好自己有所屬的大樓ＸＤ)，為了保證他們不會吵架，所以建議最少需要三棟。 Etcd Cluster：管委會的人，一樣為了怕一黨獨大(?，所以建議最少需要有三位管委，且互相投票選出一個頭頭。 Worker Node：就是偶們住戶所居住的大樓。 Pod：住戶，所以我們一棟 Worker Node 大樓，可以有很多 Pod 住戶。 Pod IP：每個住戶的門牌，既然是門牌，代表他也不會重複。 Container Registry：包裹集中的存放中心。 Container Images：還沒有被打開的包裹。 Containers：已經被打開且正在使用的包裹，那每個 Pod 住戶裡面，可以有一個或很多個以上的 Containers 包裹。 Service：社區裡面的社團，例如：羽球社、麻將社等等，可以集合大家的地方。 Service Mesh：社團的聯絡名冊，會記住誰是哪一個社團的成員。 Ingress Controller：社區的大門，可以指定讓社區成員都固定走同一個或是多個門的入口管控。 Egress Controller：社區的後門，可以指定讓社區成員都固定走同一個或是多個門的出口管控。 Internal DNS / Service Discovery：大樓住戶的電話簿。 External DNS：指向各大樓的路標。 OCI (Open Container Initiative)：制定大樓鋼筋水泥或是行李箱標準的組織。 CRI (Container Runtime Interface)：大樓鋼筋水泥的廠商。 CNI (Container Network Interface)：大樓水電系統的廠商。 CSI (Container Storage Interface)：大樓空間規劃的廠商。 Bastion：專門維護社區的工程車。 ","date":"2022-06-02","objectID":"/k8s-plain/:1:1","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"常用套件 Promethus：社區整體的監控中心 (Meterics)，一堆攝影機的管理室XD Grafana：監控中心裡面大型的 LED 儀表板。 Elaticsearch：社區整體的情資中心 (Logging)，這應該是一群愛八卦的大媽吧 😏 Kibana：情資中心裡面大型的 LED 訊息版。 ","date":"2022-06-02","objectID":"/k8s-plain/:1:2","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"常見問題 作者也有整理了一些常見的問題，我把它整理一下挑選出幾個我自己一開始也會有疑問的問題，我們一起來看看吧！一樣我會用我所理解的意思來介紹 ~ ","date":"2022-06-02","objectID":"/k8s-plain/:2:0","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q1：為什麼 Kubernetes 的最小單位是 Pod 這個要怎麼理解？ Ans ： 試想一下，難道管委會會管你的包裹裡面內容物放什麼嗎XD ","date":"2022-06-02","objectID":"/k8s-plain/:2:1","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q2：Docker 在 Kubernetes 的角色是什麼？ Ans ： 是眾多的 CRI (Container Runtime Interface) 選擇之一，也就是大樓的鋼筋水泥廠商有很多間，有一間叫做 Docker 的廠商特別有名。 ","date":"2022-06-02","objectID":"/k8s-plain/:2:2","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q3：呈上，那 CRI/CNI/CSI 是不是也可以替換成他的廠商？ Ans ： 當然可以，現在可以看到越來越多廠商都開始支援 Kubernetes 就是因為這個原因，因為一般情況下，Kubernetes 並不會特別限定 大樓鋼筋水泥廠商、大樓水電系統廠商、大樓空間規劃廠商，只要有符合特定的標準即可，但要留意 Kubernetes 的版號也會受到這三個介面支援發行的版號所影響，要留意相容性的問題！ ","date":"2022-06-02","objectID":"/k8s-plain/:2:3","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q4：整個住戶社區最重要的角色是什麼？ Ans ： 那三棟管委會大樓，和裡面的的三位委員，三位掛掉一位還可以維持正常運作，掛掉兩位會維持唯獨運作。 ","date":"2022-06-02","objectID":"/k8s-plain/:2:4","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q5：Kubernetes、VM、Container 的差異性 Ans ： 我們可以建立好一個大樓(VM)，隨意放置一個或是多個包裹(Containers)，必須手動管理這些包裹，如果資源不足或是這棟大樓倒了，就沒有辦法自動轉移這些包裹的內容了。 但如果是 Kubernetes，我們就可以建立多個大樓(VM)，透過 Kubernetes 所規定的放置計畫 (例如：Deployment、DaemonSet)，我們將可以統一調度這些 Pod，當某棟大樓資源不夠或是這棟大樓倒時，可以根據 Kubernetes 規則來進行搬遷或是擴充大樓。 ","date":"2022-06-02","objectID":"/k8s-plain/:2:5","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q6：為什麼有人會把 Container 跟 Pod 混在一起講 Ans ： 因為大部分的情況下，都是一個住戶(Pod)放一個包裹(Container)，，才會導致這樣的誤會。但實際上，一個住戶(Pod)是可以放一個或多個包裹在裡面的！ ","date":"2022-06-02","objectID":"/k8s-plain/:2:6","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q7：什麼是 Node Scaling ? Ans ： 可以把它理解成，當住戶太多時，Kubernetes 會自動或手動興建大樓，來把多出來的用戶給塞進去。 ","date":"2022-06-02","objectID":"/k8s-plain/:2:7","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"Q8：在 Q5 有提到放置計畫是什麼意思？ Ans ： 只要你有需要將包裹放在社區內，都必須提出部署計畫(Deployment) 給管委會審核，只要通過審核，他們依照你事先聲明的計畫，盡最大可能性來放置包裹。 所以當我們有任何變更計畫時，都需要重新提交一份新的部署計畫給管委會重新審核和接受。 ","date":"2022-06-02","objectID":"/k8s-plain/:2:8","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"參考資料 給行銷跟業務的 Kubernetes 101 中翻中介紹 ","date":"2022-06-02","objectID":"/k8s-plain/:3:0","tags":["Kubernetes","K8s","介紹"],"title":"用大型社區來介紹 Kubernetes 元件","uri":"/k8s-plain/"},{"categories":["codenotes"],"content":"此文章會實作如何部署 Laravel 於 Heroku 搭配 GitLab CI/CD","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"經過上一篇文章 如何從頭打造專屬的 GitLab CI/CD 的學習，讓我們了解到 GitLab CI/CD 的整個流程，接著我們本次要把 Laravel 給部署到 Heroku 透過 GitLab 的 CI/CD 去達成，不需要透過任何人工去測試，並上架程式到 HeroKu 上，全部都依賴 GitLab CI/CD，讓我們接著看下去吧！ 當然，此文章程式碼也會同步到 Github ，需要的也可以去查看歐！要記得先確定一下自己的版本 Github 程式碼連結 😏 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:0:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"版本資訊 macOS：11.6 Docker：Docker version 20.10.14, build a224086 Laravel Installer：2.3.0 Laravel Framework：9.14.1 gitlab.com：GitLab Enterprise Edition 15.1.0-pre 首先，我們第一步驟就是先建立一個 Laravel 專案，至於為什麼要選擇用 Laravel 來當作 GitLab CI/CD 的範例呢？因為 Laravel 內建有 PHPUnit 的測試腳本，可以讓我們在 CI 測試時，更好的展現 CI 的功能！，有關於 Laravel 相關內容，這邊一樣推薦兩篇文章給大家閱讀：🤣 Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式) 又工商了一波 XD ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:1:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"建立 Laravel 專案 請大家依照 Laravel 官方文件來建立 Laravel 環境，也可以看小弟我的文章拉 👆👆👆，請記得要先安裝好 php 以及 composer，接著按照以下步驟來建立。 新建一個 Laravel 新專案\" 新建一個 Laravel 新專案 這時候瀏覽 http://127.0.0.1:8000，如果都正確，應該會看到 Laravel 的首頁 Laravel 首頁\" Laravel 首頁 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:2:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"測試本地 Unit Test 接著我們剛剛有提到選用 Laravel 的原因是 Laravel 有 PHPUnit 單元測試可以使用，所以我們現在先在本地端來測試 Unit Test，專案預設有放一個單元測試在 tests/Unit/ExampleTest.php。我們先再次確認環境是否有安裝好，再來執行單元測試。 在本地端執行單元測試\" 在本地端執行單元測試 執行後，應該都會是通過的畫面，如下圖： 執行單元測試結果\" 執行單元測試結果 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:3:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"GitLab CI 建置 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"上傳 Laravel 專案 接下來我們要上傳含有 Unit Test 專案到 GitLab 上，步驟如下，如果已經熟悉如何將專案推到 GitLab，可以直接跳到 在 GitLab 上執行單元測試 在 gitlab.com 上點選建立專案，選擇 Create blank project，也可以直接瀏覽該網址 https://gitlab.com/projects/new#blank_project。 輸入專案名稱可以選擇 Project deployment target 為 Heroko，選擇 Public，最後按下 Create project 在 GitLab 上建立新專案\" 在 GitLab 上建立新專案 於專案資料夾下加入 remote 遠端 GitLab，並 Push 將專案推上去。 將 Laravel 專案推到 GitLab 上\" 將 Laravel 專案推到 GitLab 上 成功推上去，可以到 GitLab 上，看到我們剛剛的專案！ 成功推到 GitLab 上\" 成功推到 GitLab 上 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:1","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"在 GitLab 上執行單元測試 要在 GitLab 上執行 CI/CD 就需要有 Runner，這次我們選擇使用 gitlab.com 的 Shared runners，想要使用 Specific runners，可以查看上一篇 如何從頭打造專屬的 GitLab CI/CD 文章 本次使用 Share runners\" 本次使用 Share runners 接下來在專案的根目錄撰寫我們的 .gitlab-ci.yml 檔案，之後再次上傳 GitLab，當我們根目錄有此檔案，GitLab-CI 就會讀取並依照內容啟動 Runner 來執行工作： .gitlab-ci.yml image:lorisleiva/laravel-docker:latestUnit_test:before_script:- composer install --prefer-dist --no-ansi --no-interaction --no-progress --no-scriptsscript:- ./vendor/bin/phpunit --testsuit Unit --coverage-text --colors=never 說明一下這個 yml 檔內的設定是在做什麼： image：因為我們執行 CI/CD 過程中，需要有 PHP、Compose、NPM 等工具，有這些套件管理工具就可以延伸去安裝更多套件，如果一開始沒有安裝，就會很麻煩，其中一個辦法就是去 Runner 環境修改並安裝，但因為方便以及我們這次使用 Share runners，所以不能修改別人的 Runner，另一個辦法是可以使用 image 關鍵字，可以讓 Runner 切換到另一個環境去執行工作 (Job)，我們這邊使用 lorisleiva/laravel-docker:latest ，他裡面已經幫我們安裝好上述的工具了！ Unit_test：這邊也是我們的 Job，那裡面主要是先用 composer install 去安裝我們需要的套件，最後在執行 phpunit 來做單元測試。 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:2","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"上傳 .gitlab-ci.yml 接著我們使用以下指令將含有 .gitlab-ci.yml 的專案上傳到 GitLab，並回到 GitLab 選擇 CI/CD，可以查看目前的 Pipelines，會有我們剛剛所新增的 Runner。 將 .gitlab-ci.yml 推到 GitLab\" 將 .gitlab-ci.yml 推到 GitLab 查看 Runner 已經進行執行單元測試檢測\" 查看 Runner 已經進行執行單元測試檢測 可以看到 Runner 先安裝我們的環境，再執行單元測試的腳本\" 可以看到 Runner 先安裝我們的環境，再執行單元測試的腳本 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:3","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"設置須通過測試才可以合併 當我們有了測試還不夠，要怎麼確保每隻要上線 (合併到主分支) 的程式都有經過測試才上線呢？ 接下來我們可以在 GitLab 裡面做這些設定，先到專案的 Setting → General → Merge requests → Merge checks 點選 Pipelines must succeed： 點選 Pipelines must succeed 來確保程式合併前都必須經過測試\" 點選 Pipelines must succeed 來確保程式合併前都必須經過測試 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:4","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"測試是否可以阻擋未成功情況 我們先模擬要開發新功能，所以在 master 最新 commit 下，建立一個新分支 new git checkout -b \"new\" 接著修改單元測試，故意新增錯誤的測試，開啟專案的 tests/Unit/ExampleTest.php，最下面加上紅色框框程式碼： 新增錯誤測試，還模擬看看是否能成功擋住\" 新增錯誤測試，還模擬看看是否能成功擋住 assertEquals 會檢查這兩個值是否相同，不同的話，就會跳出錯誤，所以我們故意輸入 1 和 2。 並將它上傳到 GitLab，並發出 Merge Request 看看會有什麼結果！ 將新增錯誤的 ExampleTest 加入暫存，推到 GitLab\" 將新增錯誤的 ExampleTest 加入暫存，推到 GitLab 並將 new 分支透過 Merge Request 來合併到 master\" 並將 new 分支透過 Merge Request 來合併到 master 可以看到我們合併在 Pipeline 測試時，因為 new 沒有通過測試，所以也沒有辦法進行合併！ 分支 new 沒有通過測試，所以沒有進行 Merge\" 分支 new 沒有通過測試，所以沒有進行 Merge ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:4:5","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"GitLab CD 建置 我們玩完 CI 後，接著要把程式部署到伺服器或是雲端上，這時候我們不需要透過人工手動的方式，只需要有 CD 來幫我們自動化部署就可以拉！如果不太清楚，可以參考這張圖片： GitLab CI/CD workflow (圖片來源：GitLab)\" GitLab CI/CD workflow (圖片來源：GitLab) 當我們剛剛進行 CI 的整合測試，最後經過 Review and approve 合併到主分支，這時候如果我們有設定 CD，CD 就會幫我們部署到服務上，我把 CD 流程轉成文字步驟說明： 把新功能分支合併到 master 分支，代表功能已經可以上線 GitLab 觸發 Gitlab-CI 執行 pipeline Gitlab-CI 執行自動化測試 Gitlab-CI 測試成功後，執行部署到正式伺服器 回傳執行結果至 GitLab 那想要達成自動化部署之前，必須能在遠端用指令下達部署更新！簡單來說有兩件事情： 要先整理再更新專案時需要哪些指令，並將其寫成腳本 需要獲得伺服器的授權，可以對伺服器下達更新專案的腳本 我們以現在 Laravel 專案來說，套用上面講的兩件事情： 腳本製作：上線新版本大概要執行以下圖片的內容 Laravel 專案上線前會下達的指令\" Laravel 專案上線前會下達的指令 對遠端伺服器下指令：通常使用 ssh 與 伺服器做溝通，所以先在伺服器產生授權金鑰給要遠端控制的電腦，如果要給 Gitlab-CI 控制的話，也需要把金鑰存在 GitLab 上，通常使用 ssh user@remote.server 'git pull' 來下達更新專案的指令 本篇我們要部署的是 PaaS 的 HeroKu，可以減少時間去架設環境，就可以達到我們想要的效果，那接著會帶大家從 Heroku 設定開始歐！先簡單介紹一下 Heroku： Heroku 是一個支援多種程式語言的雲平台即時服務(PaaS)， 是一種雲端運算服務，提供運算平台與解決方案服務，PaaS提供使用者將雲端基礎設施部署與建立至使用者端，或者藉此獲得使用程式語言、程式庫與服務。使用者不需要管理與控制雲端基礎設施（包含網路、伺服器、作業系統或儲存），但需要控制上層的應用程式部署與應用代管的環境。 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:5:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"創建 Heroku 專案 那要使用 Heroku 當然需要一組帳號拉，建立帳號我應該不用再多介紹了吧 🤡 我們直接到 Heroku 頁面，右上角 New，點選 Create new app，輸入本次專案名稱，我就取叫 laravel-gitlab-cicd-heroku (這個不能與別人重複，因為他會生成專屬網頁)， 進去後，點選右上角有一個 Open app，就會跳出這個專案專屬的網頁： Heroku 專屬網頁\" Heroku 專屬網頁 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:5:1","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"設定 HeroKu 與 GitLab 連線 先點選右上角個人頭像 → Account setrtings → 在 Account 往下滑 → API Key，點選 Reveal 並將該 API 記住，這是等等透過 GitLab 部署時會用到的 API Token： 取得部署的 API Token\" 取得部署的 API Token 回到 GitLab 專案底下，Settings → CI/CD → Variables，他可以將變數設定在這邊，再讓 .gitlab-ci.yml 來抓取變數，設定以下兩個變數：(詳細可以參考官網) Key 名稱(HEROKU_PRODUCTION_PROJECT_NAME)，Value 值(設定我們剛剛在 Heroku 部署的專案名稱，我的是 laravel-gitlab-cicd-heroku) Key 名稱(HEROKU_PRODUCTION_API_KEY)，Value 值(這個就是我們上面的 API Key，每個人都要用自己的歐！上面的我已經重設了 😎 ) GitLab 設定 Variables\" GitLab 設定 Variables 這邊要注意先把預設的 Protect variable 給關閉，他預設會只能在受保護的分支或標籤運行，但我們這此以簡單為主，所以這些設定都先關掉。 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:5:2","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"新增 Heroku 識別檔案 接下來我們要新增一個檔案名為 Procfile，它是 Heroku 部署更新時會啟動的對象，注意他沒有副檔名，我們在裡面輸入以下：(我們使用合併後的 master) 新增 HeroKu 識別檔案\" 新增 HeroKu 識別檔案 它代表我們網頁服務使用 apache2 指令運行並把入口指向專案資料夾中的 laravel 專案的入口資料夾。 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:5:3","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"修改 .gitlab-ci.yml 我們修改原本用來 CI 的腳本，來設定自動化部署的任務 Job 及腳本 .gitlab-ci.yml image: lorisleiva/laravel-docker:latest Production_Deploy: stage: Production_Deploy before_script: - apk add ruby ruby-dev ruby-irb ruby-rake ruby-io-console ruby-bigdecimal ruby-json ruby-bundler yarn ruby-rdoc \u003e\u003e /dev/null - apk update - gem install dpl \u003e\u003e /dev/null script: - dpl --provider=heroku --app=$HEROKU_PRODUCTION_PROJECT_NAME --api-key=$HEROKU_PRODUCTION_API_KEY 最後上傳 GitLab 來觸發 Gitlab-CI 執行自動化部署 (上傳指令就不多說囉，想必大家都會了吧！，不會的話可以去看 Git 介紹，裡面有詳細的介紹 😍 ) 觸發 Gitlab-CI 執行自動化部署\" 觸發 Gitlab-CI 執行自動化部署 可以看到部署成功，我們也來看看 Runner 運作狀況： Runner 運作狀況\" Runner 運作狀況 看到他成功將服務給部署到 https://laravel-gitlab-cicd-heroku.herokuapp.com/。 既然已經部署好了，當然要去看一下我們的網頁啊，但當我們打開部署好的網頁，會發現跳出 500 Error，雖然他與我們 CI/CD 沒有關係，但我們還是試著解決，那這個問題會發生是因為我們沒有給環境變數的 APP_KEY，這個 Key 可以在專案的 .env 取得，拿到後開啟 Heroku → Setting → Config vars 將 APP_KEY 設定上去。 Runner 運作狀況\" Runner 運作狀況 最後重新整理 https://laravel-gitlab-cicd-heroku.herokuapp.com/，就可以看到我們部署上去的網站囉！ 透過 CD 部署到 Heroku 的 Laravel 首頁\" 透過 CD 部署到 Heroku 的 Laravel 首頁 ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:5:4","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"參考資料 Gitlab-CI 入門實作教學 - 單元測試篇 Gitlab-CI 自動化部屬部署 部署 Laravel 於 Heroku 搭配 Gitlab CI/CD ","date":"2022-05-26","objectID":"/laravel-gitlab-cicd-heroku/:6:0","tags":["GitLab","CI/CD","Laravel","Heroku","介紹","實作"],"title":"部署 Laravel 於 Heroku 搭配 GitLab CI/CD","uri":"/laravel-gitlab-cicd-heroku/"},{"categories":["codenotes"],"content":"此文章是介紹 GitLab CI/CD 的一些概念，並解搭配圖片來做説明💪","date":"2022-05-26","objectID":"/gitlab-cicd/","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"自從上次學完 Jenkins 及 Ansible CI/CD，就覺得 CI/CD 實在太酷了！能夠自動化的去持續整合 (Continuous Integration, CI) 以及持續佈署 (Continuous Deployment,CD) 專案，再加上這幾天複習了 Git 的使用方法，突然想到，要怎麼設定我們將程式推到遠端的 Git Repo，能夠再搭配 CI/CD 去做測試，並且把程式碼自動部署到正式的服務機器設備上呢？ 那我們就開始囉！此篇會複習一下 CI/CD 並且說明 GitLab CI/CD 運作的原理，關於實作部分會放到下一篇文章 部署 Laravel 於 Heroku 搭配 GitLab CI/CD 對了工商一下，剛剛有提到的 Jenkins 及 Ansible CI/CD 總共有 3 篇文章，還沒看過的可以先飛過去看一下歐 👇👇👇 Jenkins 及 Ansible IT 自動化 CI/CD 介紹 使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers) 老樣子文章也會同步到 Github，會附上範例中的程式碼，有需要的也可以去查看歐！ Github 程式碼連結 💓 ","date":"2022-05-26","objectID":"/gitlab-cicd/:0:0","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"GitLab CI/CD GitLab CI/CD 是 GitLab 內建強大的工具，在 GitHub 被稱為 Github Actions，這個之後有空再來介紹XD，回歸正題，GitLab CI/CD 可以讓我們持續整合和部署，且不需要使用第三方的應用程式來整合。我們來複習一下 持續整合 CI、持續部署 CD 他們是什麼吧： ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:0","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"持續整合 CI 一個處於開發階段的專案或是軟體，它被我們放在 GitLab 的 Repository 裡，開發人員每天會推送不同的程式碼到 GitLab 上，GitLab 持續整合 CI 會在開發人員每次推送後，自動化的依照我們設定好的腳本進行建構與測試，從而減少開發中的專案發生錯誤的可能性。 這種做法就被稱作持續整合，對於我們提交給專案的每一個更改、甚至是開發分支，它都是自動且持續地建構和測試，確保新加入的變動，符合我們在專案中所設計的所有測試。 ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:1","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"持續部署 CD 持續部署，讓我們不太需要手動的去部署專案服務，而是將其設置為自動化部署，完全不需要有人工去干涉，減少了人為的部署錯誤。 GitLab CI/CD (圖片來源：GitLab Agile Planning)\" GitLab CI/CD (圖片來源：GitLab Agile Planning) 大致了解是如何運作之後，我們接著聊聊上面有提到的 設定好的腳本： ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:2","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":".gitlab-ci.yml GitLab CI/CD 的工作原理是，要在專案根目錄新增一個名為 .gitlab-ci.yml 的文件 (記得文件名稱開頭有 . ，我一開始忘記要加，想說怎麼都沒有反應 😅 )，也就是我們上面說的 設定好的腳本，可以先將所需建構、測試和部署的腳本編寫完成，以及定義很多規則，例如執行命令的先後順序、部署應用程式的位置以及指定是否自動運行或是手動觸發腳本等。 將 .gitlab-ci.yml 文件放入 Repository 裡，就會觸發 CI，負責管理的 GitLab-CI 就會依照 .gitlab-ci.yml 設定檔來啟動名為 GitLab Runner 的工具來運行腳本，這個 GitLab Runner 我們放到後面來說，我們先來說說 .gitlab-ci.yml 這個設定檔要怎麼編寫，以及編寫後的流程。 這是一個示範的 .gitlab-ci.yml，選自優良的 GitLab XD，為了說明有小修改程式碼，程式碼也會放在 GitHub 上歐： .gitlab-ci.yml stages:- build- test- deploycache:paths:- config/build-job:stage:buildscript:- echo \"Hello, $GITLAB_USER_LOGIN!\"test-job1:stage:testscript:- echo \"This job tests something\"test-job2:stage:testbefore_script:- echo \"This job tests something, but takes more time than test-job1.\"script:- echo \"After the echo commands complete, it runs the sleep command for 20 seconds\"- echo \"which simulates a test that runs 20 seconds longer than test-job1\"- sleep 20deploy-prod:stage:deployscript:- echo \"This job deploys something from the $CI_COMMIT_BRANCH branch.\" 那我來簡單說明一下上面這些設定檔案的功能： stages：代表這個 CI 設定檔有三個 stage 要跑，一個是 build、一個 test、一個 deploy，他們的順序也決定 CI 運作的順序，由 build → test → deploy，假如 test 沒有通過，就不會執行 deploy。 cache：我們在寫 CI 時，常常需要裝 package，但我不想每次都重新跑一次，所以可以寫一個 cache，不要讓 GitLab 每次都重新拉新的 package。 build-job、test-job1、test-job2、deploy-prod：代表我有 4 個 job 要執行，每個 job 裡面有不同的任務，也是顯示在 Pipeline 的名稱。 stage：他現在要執行的階段，對應到 stages。 before_script：可以把它當先需要先執行的指令，後面才會執行主要的 script 指令。所以需要安裝的可以先寫在這裡面。 script：主指令，在實際運行的腳本中，通常會見到多行的指令被依序執行。 $CI_COMMIT_BRANC：當然 .gitlab-ci.yml 檔案也可以帶入參數，這個部分我們留到 部署 Laravel 於 Heroku 搭配 GitLab CI/CD 搭配實際操作來說明。 當然 .gitlab-ci.yml 有很多功能，上面只是簡單說明比較常用的，當你不確定自己寫的 CI 設定檔有沒有問題，沒關係就直接推上去，GitLab 還會先檢查一下設定檔是不是正確： GitLab CI/CD 檢查格式有錯\" GitLab CI/CD 檢查格式有錯 當我們將 .gitlab-ci.yml 連同專案一起推到 GitLab 上後，我們可以看到它會開始執行我們所寫的腳本，會顯示整個執行過程： GitLab CI/CD 執行過程\" GitLab CI/CD 執行過程 查看執行的狀態： GitLab CI/CD 狀態\" GitLab CI/CD 狀態 也可以在 GitLab Pipeline 看到執行的流程： GitLab CI/CD Pipeline\" GitLab CI/CD Pipeline ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:3","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"GitLab CI Runner 我們上面有提到，我們在 CI 跑腳本，需要一個 Server 來代替 GitLab 來讓我們執行，這個 Server 我們稱為 Runner。我們來看一下整個執行的圖片： Gitlab CI/CD 實際執行流程 (圖片來源：Gitlab-CI 入門實作教學 - 單元測試篇)\" Gitlab CI/CD 實際執行流程 (圖片來源：Gitlab-CI 入門實作教學 - 單元測試篇) 那這個 Runner 有分成兩種： 共享 Runner (Shared Runners) 自架 Runner (Specific Runners) 共享 Runner (Shared Runners) 因為本文章以及後續 部署 Laravel 於 Heroku 搭配 GitLab CI/CD 文章所使用的平台是 gitlab.com，由官方所提供，所以我們直接使用共享 Runner，可以在 repository Settings → CI / CD → Runners 中找到，有不少官方提供的共享 Runner 可以使用，也不需要做任何設定。 GitLab CI/CD 共享 Runner\" GitLab CI/CD 共享 Runner 但也有幾個缺點： 因為是共享，所以 Server 資源也會共享，理論上多人使用的速度還是會比較慢。 以及如果是開源專案，是完全免費。但如果是私人專案，一個月有 400 分鐘的 CI 執行時間限制。 自架 Runner (Specific Runners) GitLab CI/CD 自架 Runner (圖片來源：Best Practice for DevOps on GitLab and GCP : GitLab Runner 簡介與安裝 - Day 7 )\" GitLab CI/CD 自架 Runner (圖片來源：Best Practice for DevOps on GitLab and GCP : GitLab Runner 簡介與安裝 - Day 7 ) GitLab Server 和 GitLab Runner 是 GitLab CI/CD 中不可或缺的兩者，但如果像公司是自架 GitLab，首先要先找一台電腦或是 Server 做為 Runner，那我們這邊以 Docker 作示範。 GitLab Runner 的建議建置步驟如下： 準備/安裝一個 GitLab Server (這邊我們直接使用 gitlab.com) 安裝一個與 GitLab Server 對應版本的 GitLab Runner 在安裝 GitLab Runner 的設備上設定 Executor 什麼是 Executor ? 如果把 GitLab Runner 當成一個工廠來看，那 Executor 就是工廠內一個又一個的產線，同一個工廠內可以擁有不同種類的產線，Runner 與 Executor 之間的關係就是如此，這些產線會根據專案中 .gitlab-ci.yml 的內容，決定產線以及如何產出開發者期望的產品。 另外 Executor 的種類非常多，可以看下方這些圖片，因為我們最常使用的就是 Docker，所以我們等等的範例，也是建置在 Docker 之上！ GitLab Runner Executors\" GitLab Runner Executors 那我們就開始來實作我們的 GitLab Runner吧： 首先，我們回去剛剛在 repository Settings → CI / CD → Runners 左側的 Specific runners GitLab Runner Executors\" GitLab Runner Executors 可以看到一個註冊的 URL 以及 Token，這個我們在設定 Executor 會使用到！ 接下來開始安裝 GitLab Runner，我們使用 Docker，以下是 Docker 執行的指令：本此使用 gitlab-runner 版本是 alpine-v15.0.0 docker run -d --name gitlab-runner --restart always \\ -v ~/Shared/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:alpine-v15.0.0 接著進入容器裡面，使用 docker exec -it gitlab-runner gitlab-runner register 來註冊，可以參考下方圖片，輸入 URL 以及 自己的 Token： GitLab Runner 註冊 Executors\" GitLab Runner 註冊 Executors 可以回到 gitlab.com 查看 Specific runners 下方是否多了我們剛剛所註冊的 GitLab-Runner GitLab Available specific runners\" GitLab Available specific runners ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:4","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"GitLab CD GitLab CD 其實就是在 .gitlab-ci.yml 後面加上我們要部署的設定，透過 CI 整合完，我們可以設定他要部署到哪一台機器或是設備上這部分就放到下一篇文章直接用實作來告訴大家要怎麼使用吧！，請大家接續看下一篇 部署 Laravel 於 Heroku 搭配 GitLab CI/CD ，一起學習吧 GoGo ! ","date":"2022-05-26","objectID":"/gitlab-cicd/:1:5","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"參考資料 Get started with GitLab CI/CD Best Practice for DevOps on GitLab and GCP : GitLab CI/CD - Day 6 Gitlab-CI 入門實作教學 - 單元測試篇 如何使用 GitLab CI ","date":"2022-05-26","objectID":"/gitlab-cicd/:2:0","tags":["GitLab","CI/CD","介紹","實作"],"title":"如何從頭打造專屬的 GitLab CI/CD ","uri":"/gitlab-cicd/"},{"categories":["codenotes"],"content":"此文章是透過 Docker-compose 搭配 Nginx 實作一個簡單的 web service 範例，並整合 Prometheus 和 Grafana","date":"2022-05-18","objectID":"/prometheus-grafana-docker/","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"還記得我們上次架設 EFK 來獲得容器的日誌嗎！？身為一個 SRE 除了收集日誌外，還需要監控每個系統或是服務的運行狀況，並在警急情況即時通知相關人員作為應對處理。所以透過好的 Monitoring/Alert System 了解目前 Server 硬體系統狀況和整個 Service 的網路狀況是一件非常重要的一件事情。 在眾多的 Monitor 工具中，Prometheus 是一個很方便且完善的監控預警框架 TSDB (Time Series Database) 時間序列資料庫，可以快速且容易的建立不同維度的指標 (Metrics) 和整合不同的 Alert Tool 以及資訊視覺化圖表的監控工具並提供自帶的 PromQL 進行 query 查詢。 Prometheus Logo\" Prometheus Logo 我們先來看看 Prometheus 的架構圖，可以更了解 Prometheus 整體的定位： Prometheus 架構圖 (圖片來源：使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統)\" Prometheus 架構圖 (圖片來源：使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統) 有一個 Prometheus server 主體，會去 Prometheus Client Pull 相關的指標 (Metrics)，若是短期的 Job 例如 CronJob 在還來不及 Pull 資料回來可能就已經完成任務了、清洗掉資料。所以會有一個 pushgateway 接收 Job Push 過來的相關資訊，Prometheus Server 再從其中拉取資料。 (圖片左半部) Service Discovery 可以更好的蒐集 Kubernetes 相關的資訊。 (圖片上半部) Prometheus Server 主體會將資料儲存在 Local On-Disk Time Series Database 或是可以串接 Remote Storage Systems。(圖片下半部) Prometheus Server 資料拉回來後可以使用本身自帶的 Web UI 或是 Grafana 等其他的 Client 來呈現。(圖片右下半部) 當抓取資料的值超過 Alert Rule 所設定的閥值 (threshold) 時，Alertmanager 就會將訊息送出，可以透過 Email、Slack 等訊息通知，提醒相關人員進行處理。(圖片右上半部) Prometheus 可能在儲存擴展上比不上其他 Time Series Database，但在整合各種第三方的 Data Source 上十分方便，且在支援雲端服務和 Container 容器相關工具也十分友好。但在圖片的表現上就相較於單薄，所以會搭配我們接下來要介紹的 Grafanac 精美儀表板工具來進行資訊視覺化和圖表的呈現。 Grafana Logo\" Grafana Logo Grafana 是由 Grafana Lab 經營的一個非常精美的儀表板系統，可以整合各種不同的 Data Source，例如：Prometheus、Elasticsearch、MySQL、PostgreSQL等。透過不同種指標 (Metrics) 呈現在 Dashboard 上。如果還是不太清楚，可以把 Prometheus Grafana 分別想成 Prometheus 是 EFK 的 Elasticsearch，Grafana 想成是 EFK 的 Kibana。 今天我們要透過 Docker-Compose 搭配 Nginx 實作一個簡單的 Web Service 範例，並整合 Prometheus 和 Grafana 來建立一個 Web Service 監控預警系統。 此文章程式碼也會同步到 Github ，需要的也可以去查看歐！要記得先確定一下自己的版本 Github 程式碼連結 😆 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:0:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"版本資訊 macOS：11.6 Docker：Docker version 20.10.14, build a224086 Nginx：1.21.6 Prometheus：v.2.35.0 nginx-prometheus-exporter：0.10 Grafana：8.2.5 (最新版本是 8.5.2，但選擇 8.2.5，是因為 8.3.0 後 Alerting 沒有辦法附上圖片，詳細原因可以參考 Add “include image” option into Grafana Alerting ) grafana/grafana-image-renderer：3.4.2 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:1:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"檔案結構 . ├── docker-compose.yaml ├── nginx │ ├── Dockerfile │ └── status.conf ├── prometheus.yaml └── test.sh 這是主要的結構，簡單說明一下： docker-compose.yaml：會放置要產生的 nginx、nginx-prometheus-exporter、prometheus、grafana、grafana-image-renderer 容器設定檔。 nginx/Dockerfile：因為在 nginx 要使用 stub_status 需要多安裝一些設定，所以用 Dockerfile 另外寫 nginx 的映像檔。 nginx/status.conf：nginx 的設定檔。 prometheus.yaml：prometheus 的設定檔。 test.sh：測試用檔案(後續會教大家如何使用)。 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:2:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"實作 接下來會依照執行的流程來跟大家說明歐！那要開始囉 😁 我們要建立一個 Nginx 來模擬受監控的服務，我們要透過 nginx-prometheus-exporter 來讓 Prometheus 抓到資料最後傳給 Grafana，所以我們在 Docker-compose 裡面會有 nginx、nginx-prometheus-exporter、prometheus、grafana、grafana-image-renderer 幾個容器，我們先看一下程式碼，再來說明程式碼設定了哪些東西吧！ ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"Docker-compose.yaml version:'3.8'services:nginx:build:./nginx/container_name:nginxports:- 8080:8080nginx-prometheus-exporter:image:nginx/nginx-prometheus-exporter:0.10container_name:nginx-prometheus-exportercommand:-nginx.scrape-uri http://nginx:8080/stub_statusports:- 9113:9113depends_on:- nginxprometheus:image:prom/prometheus:v2.35.0container_name:prometheusvolumes:- ./prometheus.yaml:/etc/prometheus/prometheus.yaml- ./prometheus_data:/prometheuscommand:- '--config.file=/etc/prometheus/prometheus.yaml'ports:- '9090:9090'renderer:image:grafana/grafana-image-renderer:3.4.2environment:BROWSER_TZ:Asia/Taipeiports:- '8081:8081'grafana:image:grafana/grafana:8.2.5container_name:grafanavolumes:- ./grafana_data:/var/lib/grafanaenvironment:GF_SECURITY_ADMIN_PASSWORD:passGF_RENDERING_SERVER_URL:http://renderer:8081/renderGF_RENDERING_CALLBACK_URL:http://grafana:3000/GF_LOG_FILTERS:rendering:debugdepends_on:- prometheus- rendererports:- '3000:3000' nginx：因為 Nginx 會通過 stub_status 頁面來開放對外的監控指標。所以我們要另外寫一個 Dockerfile 設定檔，先將 conf 放入 Nginx 中。 nginx-prometheus-exporter：這裡要注意的是需要使用 command 來設定 nginx.scrapt-url，我們設定 http://nginx:8080/stub_status，他的預設 Port 是 9113，並設定依賴 depends_no，要 nginx 先啟動後才會執行 nginx-prometheus-exporter。 prometheus：將 prometheus.yaml 設定檔放入 /etc/prometheus/prometheus.yaml，以及掛載一個 /prometheus_data 來永久保存 prometheus 的資料，最後 command 加入 --config.file 設定。 renderer：這是 grafana 顯示圖片的套件，我們使用 3.4.2 版本，記得要設定環境變數，照片顯示的時間才會正確，並開啟 8081 Port 讓 grafana 訪問。 grafana：一樣我們先掛載一個 /grafana_data 來永久保存 grafana 的設定，在環境變數中設定預設帳號 admin 的密碼是 pass，設定 renderer 套件的服務位置是 http://renderer:8081/render 以及回傳到 http://grafana:3000/，並設定依賴 depends_on prometheus 跟 renderer，最後設定 grafana 要呈現的畫面 3000 Port。 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:1","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"nginx/Dockerfile FROMnginx:1.21.6 COPY ./status.conf /etc/nginx/conf.d/status.conf 選擇我們要使用的 nginx image 版本，並將我們的設定檔，複製到容器內。 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:2","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"nginx/status.conf server { listen 8080; server_name localhost; location /stub_status { stub_status on; access_log off; } } 這邊最重要的就是要設定 /stub_status 路徑，並開啟 stub_status ，這樣才可以讓 nginx-prometheus-exporter 抓到資料！(要怎麼知道 Nginx 是否開啟 stub_status，可以使用 nginx -V 2\u003e\u00261 | grep -o with-http_stub_status_module 指令檢查，我們這次裝的 Image 已經有幫我們啟動) ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:3","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"prometheus.yaml global:scrape_interval:5s# Server 抓取頻率external_labels:monitor:\"my-monitor\"scrape_configs:- job_name:\"prometheus\"static_configs:- targets:[\"localhost:9090\"]- job_name:\"nginx_exporter\"static_configs:- targets:[\"nginx-prometheus-exporter:9113\"] 這邊是 prometheus 的設定檔，例如有 scrape_interval 代表 Server 每次抓取資料的頻率，或是設定 monitor 的 labels，下面的 configs，分別設定了 prometheus 它的 targets 是 [\"localhost:9090\"] 以及 nginx_exporter 它的 targets 是 [\"nginx-prometheus-exporter:9113\"]。 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:4","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"test.sh #!/bin/bash docker=\"docker exec nginx\" for i in {1..10} do $docker curl http://nginx:8080/stub_status -s done 這個是我自己另外寫的測試程式，在本機執行後他會訪問 nginx 容器內部，並模擬 nginx 流量，讓我們在 Grafana 可以清楚看到資料。 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:5","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"執行/測試 當我們都寫好設定檔後，在專案目錄下，也就是有 Docker-compose 路徑下，使用 docker-compose up -d 來啟動容器： 啟動容器\" 啟動容器 接下來我們依序檢查容器是否都有正常運作，開啟瀏覽器瀏覽 http://localhost:9113/metrics 查看是否有出現跟下面圖片差不多的內容： 檢查 Nginx 以及 nginx-prometheus-exporter 的設定\" 檢查 Nginx 以及 nginx-prometheus-exporter 的設定 如果有出現，恭喜你完成了 Nginx 以及 nginx-prometheus-exporter 的設定，我們將 Nginx 的 stub_status 服務，透過 http://nginx:8080/stub_status 讓 nginx-prometheus-exporter 可以抓到圖片中的這些指標 (Metrics)。 Prometheus 接著我們瀏覽 http://localhost:9090/targets，看看我們的 Prometheus 有沒有設定正確，抓到我們設定好的 targets： 檢查 Prometheus targets\" 檢查 Prometheus targets 如果兩個出現的都是 綠色的 UP 就代表正常有抓到資料囉！ 那要怎麼測試才知道有抓到資料呢？我們可以先用 Prometheus 內建的圖形化介面來檢查，在瀏覽器瀏覽 http://localhost:9090/graph 就可以看到下面的畫面： Prometheus 內建的圖形化介面\" Prometheus 內建的圖形化介面 我們選擇 Graph，並在上面的搜尋欄，打上 nginx_connections_accepted 按下右邊的 Execute 就會產生一張圖表，圖表裡面只有一條綠色的線，那這個線是什麼呢？它就是我們剛剛在 http://localhost:9113/metrics 其中一個指標 (Metrics)，它代表 Nginx 接受用戶端連接總數量： Prometheus 內建的圖形化介面\" Prometheus 內建的圖形化介面 這個功能就是把我們所收到的 Nginx 指標 (Metrics)，轉換成圖表讓我們可以知道他的變化。 為了更明顯的看出變化，這時候就要使用我所寫好的 test.sh 腳本，使用 sh test.sh 來執行，再回來觀察圖型是否變化： 經過測試顯示的 nginx_connections_accepted 圖形\" 經過測試顯示的 nginx_connections_accepted 圖形 可以發現剛剛原本只有 1 個的連接數因為我們模擬總共跑了 10 次，所以連接數變成 11 了！ Grafana Prometheus 的圖形化比較單調，所以我們使用 Grafana 來美化我們的儀表板，瀏覽器瀏覽 http://localhost:3000/ ，可以看到一個登入頁面：帳號是 admin，密碼是我們在環境變數中所設定的 pass： Grafana 登入頁面\" Grafana 登入頁面 登入後我們看到首頁，選擇 Add your first data source 來新增資料來源： Grafana 新增資料來源\" Grafana 新增資料來源 選擇第一個 Prometheus，我們到 HTTP 的 URL 設定 http://prometheus:9090 其他設定在我們測試環境中，不需要去調整，滑到最下面按下 Save \u0026 test： Grafana 新增資料來源\" Grafana 新增資料來源 接著我們要來設計我們的儀表板，在 Grafana 除了自己設計以外，還可以 Import 別人做好的儀表板。 我們點選左側欄位的 ＋ 符號 \u003e 裡面的 Import，可以在這邊 Import 別人做好的儀表板，使用方式也很簡單，只需要先去 Grafana Labs dashboard 裡面找到自己要使用的儀表板，右側會有一個 ID，把 ID 貼上我們的 Grafana 就 Import 成功囉！很神奇吧XD 我們要使用的儀表板是別人已經做好的 NGINX exporter，它的 ID 是 12708，把 ID 貼入後，按下 Load，就會有 NGINX exporter 的基本資訊，我們在最下面的 Prometheus 選擇我們要使用的 data source，就是我們剛剛先設定好的 Prometheus，最後按下 Import，就完成拉。 Grafana 載入別人做好的儀表板\" Grafana 載入別人做好的儀表板 如果設定都沒有錯誤的話，應該可以看到下面這個畫面，最上面是監測 Nginx 服務的狀態，以及下方有不同的指標在顯示： Grafana 儀表板\" Grafana 儀表板 接下來我們一次用 test.sh 來測試一下是否有成功抓到資料： 測試 Grafana 是否成功抓到資料\" 測試 Grafana 是否成功抓到資料 可以看到在我們使用完測試腳本後，在該時段的資料有明顯的不一樣，代表我們有成功抓到資料 😄 此外也可以將 Nginx 服務暫停，看看儀表板上方的 NGINX Status 狀態是否改變： 測試暫停 Nginx 查看 Grafana 儀表板 NGINX Status\" 測試暫停 Nginx 查看 Grafana 儀表板 NGINX Status Alerting 警報 當然除了監控以外，我們還需要有警報系統，因為我們不可能每天都一直盯著儀表板看哪裡有錯誤，所以我們要設定警報的規則，以及警報要發送到哪裡，接著我們一起看下去吧： 我們先點左側的 Alerting 🔔 \u003e 點選 Notification channels 來新增我們要發送到哪裡。這次我們一樣使用 Telegram，我們在 type 下拉式選單選擇 Telegram，輸入我們的 BOT API Token 以及 Chat ID，儲存之前可以點選 test 來測試！ 怎麼使用 Telegram Bot 請參考這一篇 Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers) 來取得 BOT API Token 以及 Chat ID。 Alerting 設定\" Alerting 設定 Alerting 測試結果\" Alerting 測試結果 接著我們來設計一個屬於我們的控制板 (Panel)，順便幫他加上 Alerting，稍後也用 test.sh，看看他會不會自動發出提醒到 Telegram Bot 😬 首先點選左側欄位的 ＋ 符號 \u003e 裡面的 Create，在選擇 Add an empty panel： Create Panel\" Create Panel 再 Query 的 A Metrics browser 輸入 nginx_connections_accepted 一樣來取得 Nginx 接受用戶端連接總數量的圖表，到右上角選擇 Last 5 minutes，旁邊的圖型我們選擇 Graph (old)，下面的 Title 可以修改一下這個圖表的名稱，最後按下 Save，就可以看到我們建好一個控制板囉 🥳 設定 Panel\" 設定 Panel 接著我們來設定 Alert，可以看到剛剛在 Query 旁邊有一個 Alert，點進去後按 Create Alert，我們先修改 Evaluate every 後面的 For 改為 1m (代表當數值超過我們所設定的閥值後，狀態會從 OK 變成 Pending，這時候還不會發送警報，會等待我們現在設定的 1m 分鐘後，情況還是沒有好轉，才會發送通知)，再 Conditions 後面欄位加入 10 (我們所設定的閥值，代表 nginx_connections_accepted 超過 10 就會進入 Pending 狀態)，往下滑 Notifications 的 Send to 選擇我們上面所建立的 channels 名稱，按下 Save。 設定好 Alert 的控制板\" 設定好 Alert 的控制板 接著執行 test.sh 兩次，讓 nginx_connections_accepted 超過我們所設定的閥值，可以看到控制板超過 10 以上變成紅色： 超過閥值，控制板變成紅色\" 超過閥值，控制板變成紅色 接著等待幾分鐘後，狀態會從 OK 綠色變成黃色的 Pending，最後轉成紅色的 Alert，這時候 Telegram 就會收到通知囉 ❌ 自動發送通知到 Telegram Bot，並附上控制板圖片\" 自動發送通知到 Telegram Bot，並附上控制板圖片 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:3:6","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"Nginx 指標 (Metrics) 描述 我們在 http://localhost:9113/metrics 中可以看到許多指標 (Metrics) 那他們各代表什麼意思呢？我把它整理成表格讓大家可以選擇要使用的指標 (Metrics)： 指標 描述 nginx_connections_accepted 接受用戶端的連接總數量 nginx_connections_active 當前用戶端連接數量 nginx_connections_handled Handled 狀態的連接數量 nginx_connections_reading 正在讀取的用戶端連接數量 nginx_connections_waiting 正在等待中的用戶端連接數量 nginx_connections_writing 正在寫入的用戶端連接數量 nginx_http_requests_total 客戶端總請求數量 nginx_up Nginx Exporter 是否正常運行 nginxexporter_build_info Nginx Exporter 的構建資訊 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:4:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"參考資料 使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統 Nginx Exporter 接入 通過nginx-prometheus-exporter監控nginx指標 使用nginx-prometheus-exporter 監控nginx 使用阿里雲Prometheus監控Nginx（新版） Grafana Image Renderer grafana的image render设置 ","date":"2022-05-18","objectID":"/prometheus-grafana-docker/:5:0","tags":["Prometheus","Grafana","Docker","介紹","實作"],"title":"使用 Prometheus 和 Grafana 打造監控預警系統 (Docker 篇)","uri":"/prometheus-grafana-docker/"},{"categories":["codenotes"],"content":"此文章是接續前面 Jenkins 及 Ansible IT 自動化 CI/CD 介紹、使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot，歡迎大家先去觀看前面兩篇文章 😋","date":"2022-05-16","objectID":"/ansible/","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"本篇文章是接續前面兩篇 Jenkins 及 Ansible IT 自動化 CI/CD 介紹 跟 使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot 文章，歡迎大家先去觀看前面兩篇文章 🤪 本篇所使用到的程式碼都會整理於 GitHub 連結，大家有興趣可以去瀏覽看看歐！ ","date":"2022-05-16","objectID":"/ansible/:0:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Ansible 是如何運作的？ 在 Ansible 世界裡，我們會透過 Inventory 檔案 來定義有哪些的 Managed Node，並藉由 SSH 與 Python 來進行溝通。那我們先來看一張圖： Ansible 運作原理 (圖片來源：七分鐘掌握 Ansible 核心觀念)\" Ansible 運作原理 (圖片來源：七分鐘掌握 Ansible 核心觀念) 誒 😱 突然多了很多新名詞，沒關係我來一一解釋，首先我們先從 Managed Node 是什麼，以及圖片中的 Control machine 開始說起吧！ ","date":"2022-05-16","objectID":"/ansible/:1:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"什麼是控制主機及被控節點？ 在 Ansible 裡，我們會把所有機器的角色做以下的區分： 控制主機 (Control Machine)：顧名思義，這類主機可以透過運行 Ansible 的劇本 (Playbooks) 對被控節點進行部署。 被控節點 (Managed Node)：也稱為遙控節點 (Remote Node)。相對於控制主機，這類節點就是我們透過 Ansible 進行部署的對象。 所以代表我們在操作這邊就是 Control Machine，要部署的機器就是 Managed Node，透過 SSH 來做連線。但什麽是 Inventory 跟 Playbooks 呢？ ","date":"2022-05-16","objectID":"/ansible/:1:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"什麼是 Ansible Inventory Inventory 這個單字本身有詳細目錄、清單和列表的意思。在這裡我們可以把它理解成一份主機列表，可以透過它來定義每個 Managed Node 的代號、IP 位址、連線設定和群組。 $ vim hosts # ansible_ssh_host：遠端 SSH 主機位址 # ansible_ssh_port：遠端 SSH Port # ansible_ssh_user：遠端 SSH 使用者名稱 # ansible_ssh_private_key_file：本機 SSH 私鑰檔案路徑 # ansible_ssh_pass：遠端 SSH 密碼 (建議使用私鑰) [local] server1 ansible_ssh_host=127.0.0.1 ansible_ssh_port=55000 ansible_ssh_pass=docker 所以我們可以在這邊輸入很多個主機來做管理，可以把它想成一個設定檔。 ","date":"2022-05-16","objectID":"/ansible/:1:2","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"什麼是 Ansible Playbooks 再談 Ansible Playbooks 之前，先說明我們要怎麼去操作 Ansible？一般來說，我們可以使用 Ad-Hoc Commands 和 Playbooks 兩種方式來操作 Ansible。 Ad-Hoc Commands 是什麼？ Ad hoc 可以翻譯成簡短地指令，也就是我們常用的指令模式，最常見的 ping和echo 為例。 ping $ ansible all -m ping server1 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } echo $ ansible all -m command -a \"echo Hello World\" server1 | CHANGED | rc=0 \u003e\u003e Hello World 從上面的例子中可以看到 Ad-Hoc Commands 一次只能處理一件事情，這是它與 Playbooks 最大的差異。 ","date":"2022-05-16","objectID":"/ansible/:1:3","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Playbooks 是什麼？ Playbooks 就是字面上的意思為劇本，我們可以先透過寫好的劇本 (Playbooks) 來讓各個 Managed Node 進行指定的動作 (Plays) 和任務 (Tasks)。 簡而言之，Playbooks 就是 Ansible 的腳本 (Script)，而且比傳統 Shell Script 還要強大好幾百倍的腳本！此外它是使用 YAML 格式，寫 Code 就如同寫文件一樣，簡單易讀。 有關詳細的動作 (Plays) 和任務 (Tasks)，等我們實際安裝好再來說明 😆 ","date":"2022-05-16","objectID":"/ansible/:1:4","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Ansible 安裝與實作 安裝之前先讓大家看一下版本吧！大家要記得檢查自己的版本與教學是否相同，如果不同，記得要先查看官網是否有修改內容。 ","date":"2022-05-16","objectID":"/ansible/:2:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"版本 macOS：11.6 Docker：Docker version 20.10.14, build a224086 Aansible：ansible [core 2.12.5] ","date":"2022-05-16","objectID":"/ansible/:2:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"如何安裝 Ansible 在控制主機 由於 Ansible 是一套開源的軟體，所以在目前大部分主流作業系統上都可以透過對應的套件管理 (package manager) 進行安裝。 本人使用 macOS ，所以這邊僅列出 masOS 安裝方式，其他的可以參考官方的安裝指南。 macOS 安裝可以使用兩種方式，官方較推薦使用 pip 來做安裝： Pip Install Packages (pip 官方較推薦) $ sudo pip install ansible Homebrew (brew) $ sudo brew install ansible 安裝完後，可以使用 --version 指令來檢查是否安裝完成： $ ansible --version ansible [core 2.12.5] config file = None configured module search path = ['/Users/ian_zhuang/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/local/Cellar/ansible/5.7.1/libexec/lib/python3.10/site-packages/ansible ansible collection location = /Users/ian_zhuang/.ansible/collections:/usr/share/ansible/collections executable location = /usr/local/bin/ansible python version = 3.10.4 (main, Apr 26 2022, 19:43:24) [Clang 13.0.0 (clang-1300.0.29.30)] jinja version = 3.1.2 libyaml = True ","date":"2022-05-16","objectID":"/ansible/:2:2","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"如何安裝 Ansible 在被控節點 不需要！！！ 透過 Ansible 進行管理的被控節點完全不需要安裝 Ansible。我們只需要確保這個節點可以透過 SSH 與控制主機做溝通，並安裝 Python 2.6 以上版本就可以透過控制主機來進行部署及管理了。 那我們為了要模擬，所以我們使用 Docker 來模擬 Managed Node，首先老樣子，一樣先寫一個 Dockerfile 來建立我們的映像檔，此映像檔是微調 chusiang/ansible-managed-node.dockerfile 的內容，修改 ubuntu 版本以及內容作調整，我會把程式碼放在 GitHub 連結 ，以及 DockerHub 連結，歡迎大家前去下載使用。 FROMubuntu:22.10LABEL maintainer=\"880831ian@gmail.com\"# Update the index of available packages.RUN apt-get update# Install the requires package.RUN apt-get install -y openssh-server sudo curl wget bash-completion openssl \u0026\u0026 apt-get clean# Setting the sshd.RUN mkdir /var/run/sshdRUN echo 'root:root' | chpasswdRUN sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/' /etc/ssh/sshd_config# SSH login fix. Otherwise user is kicked off after loginRUN sed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshdENV NOTVISIBLE \"in users profile\"RUN echo \"export VISIBLE=now\" \u003e\u003e /etc/profile# Create a new user.## - username: docker# - password: dockerRUN useradd --create-home --shell /bin/bash \\ --password $(openssl passwd -1 docker) docker# Add sudo permission.RUN echo 'docker ALL=(ALL) NOPASSWD: ALL' \u003e\u003e /etc/sudoers# Setting ssh public key.RUN wget https://raw.githubusercontent.com/chusiang/ansible-jupyter.dockerfile/master/files/ssh/id_rsa.pub \\ -O /tmp/authorized_keys \u0026\u0026 \\ mkdir /home/docker/.ssh \u0026\u0026 \\ mv /tmp/authorized_keys /home/docker/.ssh/ \u0026\u0026 \\ chown -R docker:docker /home/docker/.ssh/ \u0026\u0026 \\ chmod 644 /home/docker/.ssh/authorized_keys \u0026\u0026 \\ chmod 700 /home/docker/.sshEXPOSE22# Run ssh server daemon.CMD [\"/usr/sbin/sshd\", \"-D\"] 接下來將它包成 Image 並啟動他： $ docker build -t ansible-ubuntu-server . \u0026\u0026 docker run --name server1 -d -p 8888:22 ansible-ubuntu-server 64c51235e34a7ba42c0c45e690201dd80248c9aac76c3b855c99cf63f7f0af7c 可以用 exec 進入容器： docker exec -it server1 /bin/bash ","date":"2022-05-16","objectID":"/ansible/:2:3","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"如何讓 Ansible 操控 Docker 容器？ 我們在工作目錄下，新增一個 ansible.cfg： [defaults] inventory = hosts remote_user = docker host_key_checking = False 設定 inventory hosts： [local] server1 ansible_ssh_host=127.0.0.1 ansible_ssh_port=8888 ansible_ssh_pass=docker 其中 8888 是我們在啟動時所開放的 Port，也可以自行更改。 ansible_ssh_host：設為本機的 IP。 ansible_ssh_port：設為 docker ps 取得的 SSH Port 也就是我們的 8888。 ansible_ssh_pass：因為我們沒有連線用的金鑰，所以直接使用密碼方式做連結。(建議只用於練習環境使用) ","date":"2022-05-16","objectID":"/ansible/:2:4","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Hello World On Managed Node 當我們都設置完成後，就可以使用 Terminal 用 Docker 建立好的 Ansible 來練習了！ $ ansible all -m command -a 'echo Hello World on Docker.' server1 | CHANGED | rc=0 \u003e\u003e Hello World on Docker. ansible 安裝時常見問題 Q1. server1 | FAILED | rc=-1 » to use the ‘ssh’ connection type with passwords or pkcs11_provider, you must install the sshpass program Q2. ~paramiko/transport.py:236: CryptographyDeprecationWarning: Blowfish has been deprecated ansible 安裝時常見問題 Ans1. 會遇到這個問題是因為需要多安裝 sshpass，一般系統安裝 sshpass 很簡單，但在 macOS 上稍微麻煩，詳細可以參考這篇文章。 Ans2. 在我安裝過程中，發現上前幾天才出現這個 Bug 詳細情形可以參考 GitHub issues，目前解決辦法有降板或是先將錯誤訊息給註解掉，之後再等新的版本出來再更新，大家可以自行選擇，我這邊是直接把出現問題的 transport.py 內容註解掉，大概位於236行，可以看下方圖片。 CryptographyDeprecationWarning 錯誤訊息修正\" CryptographyDeprecationWarning 錯誤訊息修正 ","date":"2022-05-16","objectID":"/ansible/:2:5","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"第一個 Playbook 在我們都安裝好後，要來說說我們剛剛有偷偷提到的 Playbooks 的動作 (Plays) 和任務 (Tasks)。在一份 Playbooks 裡面，可以有多個 Play、多個 Task 和多個 Module： Play：通常為某個特定的目的，例如： Setup a official website with Drupal 藉由 Drupal 建置官網 Restart the API Service 重開 API 服務 Task：要實行 Play 這個目的所需做的每個步驟，例如： Install the Nginx 安裝 Nginx Kill the djnago process 強制停止 django 的行程 Module：Ansible 所提供的各種操作方式，例如： apt: name=vim state=present 使用 apt 套件安裝 vim command: /sbin/shutdown -r now 使用 shutdown 的指令關機 有點聽不懂吧！我來舉個例子，我們最熟悉的 Hello World，先建立一個 helloworld.yaml 的檔案： ---- name:say 'hello world'hosts:alltasks:- name:echo 'hello world'command:echo 'hello world'register:result- name:print stdoutdebug:msg:\"{{ result.stdout }}\" 可以看到這整個就是 Play，我們想要達到 say ‘hello world’ 的目的，其中有兩個 name 分別代表兩個 Task，也就是達成 Play 目的所需得步驟。最後 command 與 debug 就是我們的 Module 要怎麼達成這兩個步驟的操作方式。 Playbooks 組成結構\" Playbooks 組成結構 我們使用 ansible-playbook 執行 Playbook，在這個範例中，我們執行了１個 Play、3 個 Tasks 和 2 個 Modules： $ ansible-playbook helloworld.yaml 執行 Playbooks\" 執行 Playbooks 我們剛剛明明只寫兩個 tasks，為什麼執行就變成三個 tasks？ 這是因為 Ansible 預設會使用 Setup task 來取得 Managed node 的 facts。關於 facts 的詳細說明，請滑到後面 取得-managed-node-的-facts 觀看😬 那如果沒有 Ansible 時，我們是怎麼操作的？我會附上 Shell Script 的做法，我們來比較看看吧！ Shell Script 建立 helloworld.sh 檔案 #! /bin/bash echo \"Hello World\" 執行 helloworld.sh ./ helloworld.sh Hello World 看起來 Shell Script 已經夠用了，為什麼還要寫 Playbook 呢？這邊整理幾個理由給大家參考： 用 Ansible 的 Module 可以把很多複雜的指令給標準化，例如不同的 Linux 發行版本在安裝套件時需代各種不同的參數。 在現有的雲原生 (cloud native) 的架構下，傳統的 Shell Script 已經不敷使用，一般而言 Shell Script 只能對一台機器 (instance) 進行操作。 ","date":"2022-05-16","objectID":"/ansible/:3:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"常用的 Ansible Module 有哪些？ 接下來簡單介紹一下比較常用到的 8 個 Module： ","date":"2022-05-16","objectID":"/ansible/:4:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.apt apt module 是給 Debian, Ubuntu 等作業系統使用的套件模組 (Packing Modules)，我們可以透過它管理 apt 套件。類似的有 apt-get、dpkg等。 更新套件索引(快取)，等同於 apt-get update 指令 - name:Update repositories cacheansible.builtin.apt:update_cache:yes 安裝 vim 套件 - name:Install the package \"vim\"ansible.builtin.apt:name:vimstate:present 移除 nano 套件 - name:Remove \"nano\" packageansible.builtin.apt:name:nanostate:absent ","date":"2022-05-16","objectID":"/ansible/:4:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.command command module 是可以在遠端上執行指令的指令模組，但它不支援變數 (variables) 和 \u003c、\u003e、|、;、\u0026，若有這類需求要改用 shell module。 重新開機 - name:Reboot at nowansible.builtin.command:/sbin/shutdown -r now 當某個檔案不存在時才執行指令 - name:create .ssh directoryansible.builtin.command:mkdir .ssh creates=.ssh/ 先切換目錄再執行指令 - name:cat /etc/passwdansible.builtin.command:cat passwdargs:chdir:/etc ","date":"2022-05-16","objectID":"/ansible/:4:2","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.copy copy moudule 是從本地複製檔案到遠端的檔案模組，若有使用變數需求，可以改用 template。它類似 Linux 指令的 scp。 複製 ssh public key 到遠端 (chmod 644 /target/file) - name:copy ssh public key to remote nodeansible.builtin.copy:src:files/id_rsa.pubdest:/home/docker/.ssh/authorized_keysowner:dockergroup:dockermode:0644 複製 ssh public key 到遠端 (chmod u=rw,g=r,o=r /target/file) - name:copy ssh public key to remote nodeansible.builtin.copy:src:files/id_rsa.pubdest:/home/docker/.ssh/authorized_keysowner:dockergroup:dockermode:\"u=rw,g=r,o=r\" 複製 nginx vhost 設定檔到遠端，並備份原有的檔案 - name:copy nginx vhost and backup the originalansible.builtin.copy:src:files/ironman.confdest:/etc/nginx/sites-available/defaultowner:rootgroup:rootmode:0644backup:yes ","date":"2022-05-16","objectID":"/ansible/:4:3","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.file file module 是在遠端建立和刪除檔案 (file)、目錄 (directory) 和軟連結 (symlinks) 的檔案模組。它類似的 Linux 指令為 chown、mkdir 和 touch。 建立檔案 (touch)，並設定權限為 644 - name:touch a file, and set the permissionsansible.builtin.file:path:/etc/motdstate:touchmode:\"u=rw,g=r,o=r\" 建立目錄 (mkdir)，並設定檔案擁有者為 docker - name:create a directory, and set the permissionsansible.builtin.file:path:/home/docker/.ssh/state:directoryowner:dockermode:\"700\" 建立軟連結 (ln) - name:create a symlink fileansible.builtin.file:src:/tmpdest:/home/docker/tmpstate:link ","date":"2022-05-16","objectID":"/ansible/:4:4","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.lineinfile lineinfile module 是個可用正規表示法對檔案進行插入或取代文字的檔案模組。它類似的 Linux 指令是 sed。 移除 docker 使用者的 sudo 權限 - name:remove sudo permission of dockeransible.builtin.lineinfile:dest:/etc/sudoersstate:absentregexp:'^docker' 在 /etc/hosts 檔案裡用 127.0.0.1 localhost 取代開頭為 127.0.0.1 的一行 - name:set localhost as 127.0.0.1ansible.builtin.lineinfile:dest:/etc/hostsregexp:'^127\\.0\\.0\\.1'line:'127.0.0.1 localhost'owner:rootgroup:rootmode:0644 ","date":"2022-05-16","objectID":"/ansible/:4:5","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.service service module 是用來管理遠端系統服務的系統模組。它類似的 Linux 指令為 service。 啟動 Nginx - name:start nginx serviceansible.builtin.service:name:nginxstate:started 停止 Nginx - name:stop nginx serviceansible.builtin.service:name:nginxstate:stopped 重開網路服務 - name:restart network serviceansible.builtin.service:name:networkstate:restartedargs:eth0 ","date":"2022-05-16","objectID":"/ansible/:4:6","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.shell shell module 是可以在遠端用 /bin/sh 執行指令的指令模組，支援變數 (variables) 和 \u003c、\u003e、|、; 和 \u0026 等運算。 藉由 ls 和 wc 檢查檔案數量 - name:check files numberansible.builtin.shell:ls /home/docker/ | wc -l 把所有的 Python 行程給砍掉 - name:kill all python processansible.builtin.shell:kill -9 $(ps aux | grep python | awk '{ print $2 }') ","date":"2022-05-16","objectID":"/ansible/:4:7","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"ansible.builtin.stat stat module 是用來檢查檔案狀態的檔案模組。其類似的 Linux 指令為 stat。 檢查檔案是否存在，若不存在則建立他。 - name:check the 'vimrc' target existsansible.builtin.stat:path:/home/docker/.vimrcregister:stat_vimrc- name:touch vimrcfile:path:/home/docker/.vimrcansible.builtin.state:touchmode:\"u=rw,g=r,o=r\"when:stat_vimrc.stat.exists == false 取的某檔案的 md5sum - name:Use md5sum to calculate checksumansible.builtin.stat:path:/path/to/somethingchecksum_algorithm:md5sum ","date":"2022-05-16","objectID":"/ansible/:4:8","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"其他 其他還有很多可以使用的 Module ，詳情可以查看 Ansible.Builtin。 ","date":"2022-05-16","objectID":"/ansible/:4:9","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Ansible 發送通知到 Telegram Bot 剛剛看了很多內建的模組，當然 Ansible 還有很多好玩的模組可以使用，我們就跟 使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot 文章 一樣，將我們取得的內容傳送到 Telegram Bot 吧！那首先我們要先創造一個 Telegram Bot，在 Telegram 找到一個機器人叫 BotFather 的官方機器人帳號。並使用指令 /newbot，會看到一下畫面： Telegram 創建機器人\" Telegram 創建機器人 他詢問你要幫機器人取叫什麼名稱，可以直接在輸入欄位輸入想要取的名稱，當然不能是別人已經取過的： Telegram 創建機器人\" Telegram 創建機器人 看到它回覆你 Done! 代表成功了，接下來你會拿到一組 API Token，像我的是 5335968936:AAEDO_Tudhy0t577jtbF9TpgrzqOsL99h9c (已更換，大家放心 😂 )，接下來開啟瀏覽器輸入以下網址 https://api.telegram.org/bot{API Token}/getupdates，其中的 {API Token} 請帶入自己的 Token，直到出現 {\"ok\":true,\"result\":[]} 代表完成。 接下來開啟你自己的 Bot ，打上 /start 指令，重新整理剛剛的網頁就可以看到以下這樣的文字： {\"ok\":true,\"result\":[{\"update_id\":606594112,\"message\":{\"message_id\":1,\"from\":{\"id\":493995679,\"is_bot\":false,\"first_name\":\"\\u54c1\\u6bc5\",\"last_name\":\"Ian\",\"username\":\"pinyichuchu\",\"language_code\":\"zh-hans\"},\"chat\":{\"id\":493995679,\"first_name\":\"\\u54c1\\u6bc5\",\"last_name\":\"Ian\",\"username\":\"pinyichuchu\",\"type\":\"private\"},\"date\":1652695148,\"text\":\"/start\",\"entities\":[{\"offset\":0,\"length\":6,\"type\":\"bot_command\"}]}} 這是你傳訊息給 Bot 它所收到的 API，資料很多沒關係，我們找到 id，像我的是 493995679，這個就是我跟機器人的聊天室，我們就先回到 Ansible 這邊吧！ 開啟一個新的檔案叫 send_notify_tg.yaml，打以下內容： ---- name:Send notifyhosts:alltasks:- name:Send notify to Telegramcommunity.general.telegram:token:\"9999999:XXXXXXXXXXXXXXXXXXXXXXX\"api_args:chat_id:000000parse_mode:\"markdown\"text:\"Your precious application has been deployed: https://example.com\"disable_web_page_preview:Truedisable_notification:True 可以看到我們使用的模組不是 Ansible 內建的，而是社群別人寫的，詳細可以參考 community.general.telegram module – module for sending notifications via telegram： 其中 token 就是我們剛剛在 BotFather 那邊所拿到的 Token，chat_id 就是我們剛剛在網頁上看到的 id，把資料都輸入進去後，我們可以修改 text 內容，改成 “Send notify to Telegram 測試傳送通知”，接著執行 ansible-ploybook send_notify_tg.yaml ，看看能不能正常收到通知！ 發送通知至 Telegram Bot\" 發送通知至 Telegram Bot 這樣子就成功透過 Ansible Module 傳送通知給 Telegram 囉！ 我們可能需要將機器人加入群組內，這時候需要更換一下 chat_id，先將機器人加入群組，再次到剛剛瀏覽器的網頁刷新，查看 chat 後面的 id 帶有 -，像是 -540226836 這樣，這個就是該群組的 ID，將 send_notify_tg.yaml 的 chat_id 修改成 -540226836 在測試看看，他就會在群組中發送通知囉！ {\"update_id\":606594124,\"message\":{\"message_id\":14,\"from\":{\"id\":493995679,\"is_bot\":false,\"first_name\":\"\\u54c1\\u6bc5\",\"last_name\":\"Ian\",\"username\":\"pinyichuchu\",\"language_code\":\"zh-hans\"},\"chat\":{\"id\":-540226836,\"title\":\"\\u54c1\\u6bc5 \u0026 AnsibleSendMessageBot\",\"type\":\"group\",\"all_members_are_administrators\":true},\"date\":1652696181,\"group_chat_created\":true}} 發送通知至 Telegram 群組 Bot\" 發送通知至 Telegram 群組 Bot ","date":"2022-05-16","objectID":"/ansible/:5:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"取得 Managed node 的 facts 還記得我們在執行任務 (Tasks) 時，明明只有兩個，但最後結果顯示三個嗎？是因為在使用 Playbooks 時，Ansible 會自動執行 Setup module 以蒐集各個 Managed node 的 facts。 這個 facts 就好比是系統變數一樣，從 IP 位址、作業系統、CPU 等資訊應有盡有。 ","date":"2022-05-16","objectID":"/ansible/:6:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"Ad-Hoc Commands 通常我們都會先使用 Ad-Hoc Commands 來呼叫 setup 看看有哪些可用的資訊，這對於我們稍後撰寫較為複雜的 Playbooks 會很有幫助。 可以藉由 less 快速搜尋所有的變數 $ ansible all -m setup | less server1 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_apparmor\": { \"status\": \"disabled\" }, \"ansible_architecture\": \"x86_64\", \"ansible_bios_date\": \"03/14/2014\", \"ansible_bios_vendor\": \"BHYVE\", \"ansible_bios_version\": \"1.00\", \"ansible_board_asset_tag\": \"NA\", \"ansible_board_name\": \"NA\", \"ansible_board_serial\": \"NA\", \"ansible_board_vendor\": \"NA\", \"ansible_board_version\": \"NA\", 搭配 filter 將發行版本 (distribution) 資訊給過濾出來 $ ansible all -m setup -a \"filter=ansible_distribution*\" server1 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_distribution\": \"Ubuntu\", \"ansible_distribution_file_parsed\": true, \"ansible_distribution_file_path\": \"/etc/os-release\", \"ansible_distribution_file_variety\": \"Debian\", \"ansible_distribution_major_version\": \"22\", \"ansible_distribution_release\": \"kinetic\", \"ansible_distribution_version\": \"22.10\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } 取得套件管理員的種類資訊，例子中取得的值是 apt $ ansible all -m setup -a \"filter=ansible_pkg_mgr\" server1 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_pkg_mgr\": \"apt\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } ","date":"2022-05-16","objectID":"/ansible/:6:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"轉寫 Playbooks 我來出個題目，我想要知道 Ansible 所使用的公鑰，並透過 Telegram Bot 發送到群組，要怎麼做呢！？ 首先要利用剛剛的 Ad-Hoc Commands filter，找到公鑰，再將公鑰透過 Telegram Bot 傳送，所以我們會有兩個 Tasks，那我們開始實作囉 🤓 1.找到公鑰 ---- name:Filter rsa_public \u0026 Send notifyhosts:alltasks:- name:Filter setup rsa_public keyansible.builtin.setup:filter:- \"ansible_ssh_host_key_rsa_public\"register:result 可以看到我們將 filter setup 從 Ad-Hoc 轉成 Playbooks，並使用 result 來存在找到的公鑰。 發送通知至 Telegram Bot - name:Send notify to Telegramcommunity.general.telegram:token:\"5335968936:AAFhxxMRJy-rucGKgSE80Xss7qPq2iOHWlc\"api_args:chat_id:-540226836parse_mode:\"markdown\"text:\"{{ result }}\"disable_web_page_preview:Truedisable_notification:True 老樣子，我們就使用上次 send_notify_tg.yaml 內的 Send notify to Telegram 任務來傳送通知。 執行後，看看群組是否有收到我們找到的 ansible_ssh_host_key_rsa_public 通知。 發送通知至 Telegram 群組 Bot\" 發送通知至 Telegram 群組 Bot ","date":"2022-05-16","objectID":"/ansible/:6:2","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"使用 Ansible 的 Template 系統 Template module 是常使用的檔案模組之一，我們在 常用的 Ansible Module 有哪些？ 文章中有提到，可以用它和變數 (Variables) 來操作檔案。 我們只需要事先定義變數和模板 (Templates)，即可用它動態產生遠端的 Shell Script、設定檔 (Configure)等。換句話說，我們可以用一份 template 來開發 (Development)、測試 (Test)、正式環境 (Production) 等不同環境設定。 舉例說明： 建立 template 檔案 $ vim hello_world.txt.j2 Hello \"{{ dynamic_word }}\" 由於 Ansible 是就由 Jinja2 來實作 template 系統，所以需要使用 *.j2 的副檔名。 上面的 \"{{ dynamic_word }}\"\" 代表我們在 template 裡使用了名為 dynameic_word 的變數。 建立 playbook，並加入變數 vim template_demo.yaml ---- name:Play the template modulehosts:localhostvars:dynamic_word:\"World\"tasks:- name:generation the hello_world.txt fileansible.builtin.template:src:hello_world.txt.j2dest:/tmp/hello_world.txt- name:show file contextcommand:cat /tmp/hello_world.txtregister:result- name:print stdoutdebug:msg:\"{{ result.stdout_lines }}\" 在第 5 行，我們幫 dynamic_word 變數設了一個預設值 World。 在 8 行的第 1 個 task 裡，我們使用 template module，並指定了檔案的來源 (src) 和目的地 (dest)。 之後的 2 個 task 則是把 template module 產生的檔案給印出來。 直接使用 ansible-playbook template_demo.yaml 執行 Playbook。 Template Module 範例\" Template Module 範例 也可以透過 -e 參數將 dynamic_word 覆寫成 “ansible” $ ansible-playbook template_demo.yaml -e \"dynamic_word=ansible\" Template Module 使用 -e 覆寫參數\" Template Module 使用 -e 覆寫參數 ","date":"2022-05-16","objectID":"/ansible/:7:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"如何切換不同環境 除了我們剛剛用 vars 來宣告變以外，還可以使用 vars_files 來 include 其他的變數檔：$ vim template_demo2.yaml ---- name:Play the template modulehosts:localhostvars:env:\"development\"vars_files:- vars/{{ env }}.ymltasks:- name:generation the hello_world.txt fileansible.builtin.template:src:hello_world.txt.j2dest:/tmp/hello_world.txt- name:show file contextcommand:cat /tmp/hello_world.txtregister:result- name:print stdoutdebug:msg:\"{{ result.stdout_lines }}\" 可以看到上面例子中第 7 行，就是我們使用 vars_files 來 include 其他的變數檔。 建立 vars/development.yaml、vars/test.yaml、vars/production.yaml 檔案，接下來將依不同得環境 include 不同的檔案變數檔案 (vars files)，這樣就可以用一份 Playbook 切換環境了！ Development $ vim vars/development.yaml dynamic_word: \"development\" Test $ vim vars/test.yaml dynamic_word: \"test\" Production $ vim vars/production.yaml dynamic_word: \"production\" 執行 ansible-playbook template_demo2.yaml -e \"dynamic_word=Test\"，並有 -e 去修改各個環境。 Template Module 範例\" Template Module 範例 Template 系統是實務上很常見的手法之一，藉由它我們可以很輕鬆地讓開發、測試、正式環境無縫接軌。但若是在大型的 Playbook 裡切換環境，建議使用較為進階的 group_vars 跟 host_vars。 ","date":"2022-05-16","objectID":"/ansible/:7:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"在 Playbooks 使用 Handlers Handlers 是我們在 Ansible Playbooks 裡很常用來重開系統服務 (Service) 的手法，我們這邊透過安裝 Nginx 來介紹它。 那什麼是 Handlers 呢？Handler 本身是一種非同步的 callback function ; 在這裡則是指關聯於特定 tasks 的事件 (event) 觸發機制。當這些特定的 tasks 狀態為 被改變 (changed) 且都已被執行，才會觸發一次的 event。 我們建立 setup_nginx.yaml ---- name:setup the nginxhosts:allbecome:truevars:username:\"PinYi\"mail:\"880831ian@gmail.com\"blog:\"https://pin-yi.me\"tasks:# 執行 'apt-get update' 指令。- name:update apt repo cacheapt:name=nginx update_cache=yes# 執行 'apt-get install nginx' 指令。- name:install nginx with aptapt:name=nginx state=present# 於網頁根目錄 (DocumentRoot) 編輯 index.html。- name:modify index.htmlansible.builtin.template:src=templates/index.html.j2dest=/var/www/html/index.htmlowner=www-datagroup=www-datamode=\"644\"backup=yesnotify:restart nginx# handlers## * 當確認事件有被觸發才會動作。# * 一個 handler 可被多個 task 通知 (notify)，並於 tasks 跑完才會執行。handlers:# 執行 'sudo service nginx restart' 指令。- name:restart nginxservice:name=nginx enabled=yes state=restarted# post_tasks:## 在 tasks 之後執行的 tasks。post_tasks:# 檢查網頁內容。- name:review http statecommand:\"curl -s http://localhost\"register:web_context# 印出檢查結果。- name:print http statedebug:msg={{ web_context.stdout_lines }} 來說明一下上面這個 yaml 檔案： 首先我們想要安裝 Nginx，我們給了三個參數，分別是 username、mail、blog，等等會帶入我們的 template。 我們一開始有 3 個 task，分別代表執行更新、安裝、編輯 index.html 檔案。 以及 1 個 handlers 他會等 modify index.html 有改變且執行後才會動作。 最後是 post_tasks 他是等 tasks 之後執行的 tasks。 接下建立 Nginx html 的 template：vim templates/index.html.j2 _____________________________________/ This is a ansible-playbook demo for \\\\ automate-with-ansible at 2022/05/17./-------------------------------------\\ ^__^\\ (oo)\\_______(__)\\ )\\/\\||----w ||| ||[{{username }}@automate-with-ansible ~ ]$[{{username }}@automate-with-ansible ~ ]$[{{username }}@automate-with-ansible ~ ]$ cat .profile- {{mail }}- {{blog }} 執行 Playbook 可以看到因為我們 modify index.html 沒有被改變，notify 沒有通知 handlers，所以他不會執行 handlers 該段程式。(正常來說，修改 html 不需要重啟，此為範例🤣 ) Handlers 範例\" Handlers 範例 那我們修改一下 index.html 來測試一下會不會把 index.html 的狀態被改變，而讓 handlers 執行呢！我們隨意修改 index.html 內容，修改日期改成 05/17： Handlers 範例\" Handlers 範例 可以看到我們的 modify index.html 被改變了，所以 notify 通知 handlers 執行重新啟動。 ","date":"2022-05-16","objectID":"/ansible/:8:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"在 Playbooks 使用 loops 在 Shell Script 中，我們會使用 for 和 while 等迴圈 (loop) 來簡化重複的程式碼，而在 Ansible 我們也可以使用 loop 來簡化重複的任務 (Tasks)。 ","date":"2022-05-16","objectID":"/ansible/:9:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"標準迴圈 首先我們先以簡單的方式重複印出三筆資料。 Shell Script 建立 for loop 的 Script $ vim bash_loop.sh #!/bin/bash for x in 0 1 2; do echo Loop $x done 在第 4 行，我們用 for，並\u0008代入 0,1,2 三個值到 $x 變數 在第 5 行，則用了 echo，印出訊息和 $x 變數 執行 Script：可以看到底下跑了 3 次的 loop $ chmod a+x bash_loop.sh $ ./bash_loop.sh Loop 0 Loop 1 Loop 2 Ansible Playbooks 我們需要透過 item 和 with_items 來使用 Ansible 的 loop，其 item 為預設名。在 Ansible 2.5 中添加了 loop，所以我們後續兩者都會提到 (目前兩者都可以使用！) 建立 loop 的 playbook vim playbook_with_items.yaml ---- name:a basic loop with playbookhosts:localhosttasks:- name:print loop messageansible.builtin.debug:msg:\"Loop {{ item }}\"with_items:- 0- 1- 2 在第 6、7 行裡，我們用 debug module 來印出訊息，並定義 item 在第 8 ~ 11 行，則用了 with_item 將 0,1,2 的值傳入 item 執行 ansible-playbook playbook_with_items.yaml 後會得到： TASK [print loop message] *************************************************************************************************************ok:[server1] =\u003e (item=0) =\u003e {\"msg\": \"Loop 0\"}ok:[server1] =\u003e (item=1) =\u003e {\"msg\": \"Loop 1\"}ok:[server1] =\u003e (item=2) =\u003e {\"msg\": \"Loop 2\"} 另一種 在 Ansible 新增的 loop 建立 loop 的 playbook vim playbook_loop.yaml ---- name:a basic loop with playbookhosts:alltasks:- name:print loop messageansible.builtin.debug:msg:\"{{ item }} {{ my_idx }}\"loop:- Loop- Loop- Looploop_control:index_var:my_idx 執行 ansible-playbook playbook_loop.yaml 後會得到： TASK [print loop message] *************************************************************************************************************ok:[server1] =\u003e (item=0) =\u003e {\"msg\": \"Loop 0\"}ok:[server1] =\u003e (item=1) =\u003e {\"msg\": \"Loop 1\"}ok:[server1] =\u003e (item=2) =\u003e {\"msg\": \"Loop 2\"} 會使用 Loop 就可以減少我們在寫重複的程式碼，當然上面的只是簡單的範例，詳細請參考 Loops - Ansible Documentation。 ","date":"2022-05-16","objectID":"/ansible/:9:1","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"參考資料 現代 IT 人一定要知道的 Ansible 自動化組態技巧 Ansible 安裝 怎麼用 Docker 練習 Ansible？ community.general.telegram module – module for sending notifications via telegram ","date":"2022-05-16","objectID":"/ansible/:10:0","tags":["Ansible","CI/CD","介紹","實作"],"title":"Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers)","uri":"/ansible/"},{"categories":["codenotes"],"content":"此文章是接續前面 Jenkins 及 Ansible IT 自動化 CI/CD 介紹，歡迎大家先去觀看前面的文章 😋","date":"2022-05-16","objectID":"/jenkins/","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"此文章是接續前面 Jenkins 及 Ansible IT 自動化 CI/CD 介紹 文章，此篇會實際安裝及實作 Jenkins，大家記得在學習前要先檢查自己的版本是否有新的更新！那我們開始囉 😘 ","date":"2022-05-16","objectID":"/jenkins/:0:0","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"Jenkins 安裝與實作 我這次會使用 Docker-compose 來進行安裝，除了 Docker 以外也有不同的安裝方式，可以參考 Jenkins download and deployment，本次使用的環境版本如下： ","date":"2022-05-16","objectID":"/jenkins/:1:0","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"版本 macOS：11.6 Docker：Docker version 20.10.14, build a224086 Jenkins：jenkins/jenkins:lts-jdk11 yamllint：1.26.0 ","date":"2022-05-16","objectID":"/jenkins/:1:1","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"安裝 這邊會使用 Jenkins 提供的 官方 LTS 映像檔 來作為基底，因為我們要多安裝測試程式 yamllint，所以就自己寫一個 Docker-compose：(同樣的程式碼會放在 GitHub，也直接包成映像檔放在 DockerHub，歡迎大家自行取用) yamlint yamlint，它是語法檢查工具，可以用來檢查 yaml 檔案的語法是否正確以及符合規範，我們看一下實際操作的畫面： yamllint 測試\" yamllint 測試 可以看到如果不符合 yaml 規範就會跳出錯誤訊息。 接下來先看一下整個 Docker-compose 結構以及各參數： . ├── Docker-compose.yaml ├── jenkins │ └── Dockerfile Docker-compose.yaml version:\"3.8\"services:jenkins:build:./jenkins/container_name:jenkinsports:- 8080:8080- 50000:50000restart:alwaysvolumes:- ./jenkins_home:/var/jenkins_home 參數說明： build: ./jenkins/：因為要先安裝 yamllint，所以使用 Dockerfile 另外寫。 container_name:jenkins：容器的名稱。 ports: -8080:8080 - 50000:50000：8080 是待會我們瀏覽儀表板會使用到的 Port，如果本機上 8080 已經被佔用，可以自行更換，50000 是 Jenkins 所使用的 Port。 restart: always：當容器停止時，會自動重新啟動容器。 volumes: - ./jenkins_home:/var/jenkins_home：掛載目錄，就算刪除容器一樣可以保留其他設定。我將啟動 Docker-compose.yaml 的資料夾下多一個 jenkins_home 與容器內 /var/jenkins_home 做映射，大家可以自己去調整。 jenkins/Dockerfile FROMjenkins/jenkins:lts-jdk11LABEL maintainer=\"880831ian@gmail.com\"USERrootRUN apt-get upgrade -y\\ \u0026\u0026 apt-get update -y\\ \u0026\u0026 apt-get install yamllint -y 參數說明： FROM：我們使用 Jenkins 官方提供的 LTS 維護版本。 USER：因為要先安裝東西，所以直接給 root 權限。 RUN：先升級完後，再更新，最後再裝 yamllint。(-y 是同意所以詢問) 最後使用 docker-compose 來執行： $ docker-compose up -d 要在 Docker-compose.yaml 資料夾下指令才有用。 下完指令後，他就會在背景開始安裝，可以試著用瀏覽器瀏覽 http://localhost:8080，查看有沒有跳出下面這個畫面： 瀏覽器訪問 http://localhost:8080\" 瀏覽器訪問 http://localhost:8080 我們看到它需要輸入一組 Administrator password，我們要使用 docker logs 來查看，會發現最後會有寫 Please use the following password to proceed to installation 的地方： $ docker logs jenkins ************************************************************* ************************************************************* ************************************************************* Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: 70c0780f62a7441f90286be106908378 This may also be found at: /var/jenkins_home/secrets/initialAdminPassword ************************************************************* ************************************************************* ************************************************************* 其中的 70c0780f62a7441f90286be106908378 ，就是我們的 Administrator password，直接複製並貼到欄位後按 Continue。 我們可以看到它詢問是否要安裝套件，我們選擇左邊 Install suggested plugins 安裝推薦的套件即可： 安裝推薦的套件\" 安裝推薦的套件 等待它安裝套件，安裝完後會自動跳到註冊畫面： 等待安裝…\" 等待安裝… 輸入完基本的資料後，按 Save and Continue： 創建 Admin 使用者\" 創建 Admin 使用者 最後看到下面這個畫面就代表我們安裝好囉！ Jenkins 儀表板\" Jenkins 儀表板 ","date":"2022-05-16","objectID":"/jenkins/:1:2","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"建立第一個 Jenkins Job 我們已經成功安裝好並進入到 Jenkins 儀表板，我們先來建立第一個 Job，它的功用是告訴我們系統檔案的即時使用狀況，讓我們對 Jenkins 有初步的了解： 點選儀表板的新增作業或是 Create a Job： 新增作業\" 新增作業 輸入 Job 專案名稱並選擇建立 Free-Style 軟體專案： 設定 Job 專案\" 設定 Job 專案 可以看到這邊有不同的專案類型可以選擇，Free-Style 以及 Pipeline 這兩種類型的專案基本上就涵蓋大部分的需求。Free-Style 類型的專案提供了非常大的彈性讓使用者來做原始碼管理以及建置。如果建置流程涉及多個專案，則可以使用 Pipeline 類型的專案來組合及定義建置邏輯。 接下來設定專案組態： 設定專案組態\" 設定專案組態 要記得幫每一個專案都加上描述，讓其他人知道該專案的用途或是使用時機等。 接著，在建置的下拉式欄位選擇 選擇建置步驟 \u003e 執行 Shell 設定專案組態\" 設定專案組態 輸入 df -h 指令： 設定專案組態\" 設定專案組態 我們這邊透過建置 執行 Shell 這個建置步驟來告訴 Jenkins，未來這個專案被建置，就會執行 df -h 這個指令。 專案組態設置完後，我們點選左邊的馬上建置來建置剛剛建好的專案，如果我們設定上沒有問題，應該會在左下角的建置歷程這邊看到我們的第一個建置紀錄： 建置專案\" 建置專案 點進去後，再點 Console Output，可以看到這次建置的結果： 建置專案\" 建置專案 這樣我們的第一個 Jenkins Job 就設定完成囉！Jenkins 也確實的執行我們所設定的指令，並將系統的使用狀況呈現在終端機的輸出上。 以上就是我們第一個簡單的專案建置流程，當然，Jenkins 可以做到的事情不僅如此，在後面我們會透過安裝不同的套件來強化 Jenkins，來達到完整的持續整合 😁 ","date":"2022-05-16","objectID":"/jenkins/:1:3","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"原始碼管理與建置觸發程序 上面有提到 Jenkins 作為一個持續整合的工具，與原始碼管理系統的整合尤其重要。我們這一章節，會介紹如何在 Jenkins 上透過原始碼管理 (source code management,SCM) 系統，例如從 GitHub 獲得專案的原始碼，並設置建置觸發程序 (build triggers) 來實踐持續整合。 ","date":"2022-05-16","objectID":"/jenkins/:2:0","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"建置專案 HTTPS 接下來我們先建立一個新的 Job，選擇 Free-style 模式，這次要在原始碼管理裡面選擇 Git，在 Repositories \u003e Repository URL 裡面輸入我們這次要測試的 repository URL： 設定 Repository URL\" 設定 Repository URL SSH 如果我們想要透過 SSH 來存取專案，我們會遇到以下狀況： SSH 尚未設定錯誤訊息\" SSH 尚未設定錯誤訊息 會有錯誤訊息是因為我們還沒有把 Jenkins 與 GitHub 做 SSH 金鑰配對，所以 GitHub 拒絕 Jenkins 透過 SSH 存取。那要怎麼解決呢？ 最簡單的方法就是在 Jenkins 主機下建立 SSH 金鑰，並將公開金鑰 Key 加入到 GitHub 帳號中，有需要的朋友可以再自行使用，該範例使用 HTTPS 來做設定。 ","date":"2022-05-16","objectID":"/jenkins/:2:1","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"建置觸發程序 由於我們還沒有定義任何建置的觸發程序，所以除非我們手動去操作 Jenkins，不然 Jenkins 並不會主動幫我們進行建置。因此，在建置觸發程序這個欄位內，我們可以自由設定我們希望 Jenkins 何時自動幫我們進行建置專案。那依照專案的屬性不同，我們也可以採用不同的建置時機。那最常見的有以下兩種： 定期建置 在 Jenkins 中，我們是採用 Cron Format 的方式來定義建置行程。Cron Format 總共五個欄位，欄位與欄位之間可用空白或 Tab 鍵做區隔： 分 (minute)：0 - 59 分 時 (hour)：0 - 23 時 日 (day of month)：1 - 31 日 月 (month)：1 - 12 月 星期 (day of week)：星期 0 - 7 (其中 0 與 7 都代表星期天) 假設我們希望每個 30 分鐘就建置一次當前專案，我們可以在定義規則裡面填入 H/15 * * * *： 定期建置\" 定期建置 GitHub hook trigger for GITScm polling 這種觸發方式在持續整合時非常實用。我們可以讓 Jenkins 自動監測當在原始碼專案有任何的 push event 發生時就進行建置。為了要使用這種方式建置，需要以下幾個步驟來設定： 新增 GitHub personal access token 進入 GitHub 首頁，點選右上角下拉選單，點選 Settings： GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 先點選左邊的 Developer settings \u003e 點選左邊的 Personal access tokens \u003e 點選右上角的 Generate new token，輸入 token 的描述並勾選 repo scope 以及 admin:repo_hook scope 跟 admin:org_hook scope，點選 Generate token： GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 會產生一個 token，請先把 token 複製下來，離開這個畫面後，token 就會看不到了！(此 token 已刪除 ✌️) GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 設定 Jenkins GitHub 進入 Jenkins 儀表板頁面，點選左邊管理 Jenkins \u003e System Configuration 的設定系統，往下滑找到 GitHub： GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 找到後，再 GitHub Servers 下拉欄位選擇 Add GitHub Server，會看到下面畫面，API URL 輸入 https://api.github.com，Credentials 點 Add： GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 Kind 選擇 Secret Text，Secret 輸入剛剛存的 Personal Access Token，Description 簡單描述一下： GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 設定完後，點選一下右邊的 Test connection，如果我顯示 Credentials verified for user UserName, rate limit: xxx 就代表成功囉！ GitHub hook trigger for GITScm polling 設定\" GitHub hook trigger for GITScm polling 設定 設定專案組態 接著我們跳回來剛剛的專案組態，並勾選 GitHub hook trigger for GITScm polling： 設定專案組態\" 設定專案組態 寫一個 Shell Script 來建置專案： for file in $(find . -type f -name \"*yaml\") do yamllint $file done 設定專案組態\" 設定專案組態 這邊利用一個簡單的 Shell Script 迴圈來對所有 YAML file 進行 yamllint 的檢查，最後點選儲存離開。 GitHub 上整合 Jenkins 先到 GitHub 被建置專案的頁面下點 Setting 標籤 \u003e 點選左邊的 Webhook \u003e 點選右上角的 Add webhook \u003e 輸入 Jenkins Hook URL 到 Payload URL： 記得 Jenkins Hook URL 後面要加 /github-webhook/，小弟我卡在這裡很久😢 😢 Webhooks 設定\" Webhooks 設定 Jenkins Hook URL 設定 由於我們是將 Jenkins 運行在本機端，所以 Jenkins Hook URL http://localhost:8080 是 Private IP。GitHub 沒有辦法抓 Private IP，為了練習，我們可以透過 ngrok 這套簡單小工具來暫時將 http://localhost:8080 變成 Public IP。 ngrok 的使用方式很簡單，只要先下載 brew install ngrok/ngrok/ngrok ，並使用 ngrok http 8080 指令，將 Private IP 變成 Public IP： ngrok 將 Private IP 變成 Public IP\" ngrok 將 Private IP 變成 Public IP 圖片中 https://2063-111-235-135-57.jp.ngrok.io 就是 Public 的 Jenkins Hook URL 完成後，先點選 Recent Deliveries 檢查是否成功，底下的 Response 需要是 200，才是對的歐！(這裡一定要先檢查，不然後面會找問題到死 XD) Webhooks 設定\" Webhooks 設定 ","date":"2022-05-16","objectID":"/jenkins/:2:2","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"測試 我們都設定好後，要開始來測試，我們可以直接先點選 馬上建置，來測試是否可以透過 GitHub personal access token，抓取 GitHub 的檔案。 馬上建置\" 馬上建置 可以看到在建置流程那邊發現建置失敗，點進去可以看詳細內容， 建置失敗\" 建置失敗 點選左側的 Console Output，可以看到我們有成功獲取 GitHub 上得專案，並且執行我們的 Shell 來檢查 yaml 的檔案格式，發現是因為格式有錯誤，所以建置才會失敗 ❌ Console Output\" Console Output 接下來我們先修改一下 yaml 的檔案，後重新 push 到 Github 上，並觀察 Jenkins 會不會自動建置 ！(修改位置大家可以直接看 Commit 結果) Console Output\" Console Output 當你 push 完後，發現它會自動建置，請因為我們修改成正確格式，所以他也建置成功囉！ 也可以點選左側有一個新的 GitHub Hook Log ，可以看到我們成功透過 GitHub hook trigger for GITScm polling 偵測到有新的 event，透過 WebHook 讓 Jenkins 知道。 GitHub Hook Log\" GitHub Hook Log ","date":"2022-05-16","objectID":"/jenkins/:2:3","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"建置後觸發通知 當我們自動建置成功當然沒什麼問題，但如果失敗有可能就會影響後續程式的上線時間，所以我們希望建置完成後，可以收到通知，通知除了可以用 email 以外，也可以使用套件去串接我們常用的平台，例如 Telegram、Slack、Line 等等，接下來我會教大家要怎麼去串接這些服務，在開始之前要請大家先安裝兩個套件： 安裝/設定 Build Timestamp Build Timestamp 這個套件可以幫我們在稍後傳送通知時加上當下的時間戳，那要怎麼安裝套件呢？先到儀表板首頁，點選左側的 管理 Jenkins \u003e 點選 管理外掛程式： 管理 Jenkins \u003e 管理外掛程式\" 管理 Jenkins \u003e 管理外掛程式 再 Plugin Manager 的 可用的裡面搜尋 Build Timestamp，選擇後點下方的 Download now and install after restart，等待他安裝後會自動重啟。 安裝 Build Timestamp\" 安裝 Build Timestamp 重啟後從儀表板點選左側 管理 Jenkins \u003e 點選 設定系統，找到 Build Timestamp，開啟設定，並設定 Timezone 為 Asia/Taipei 以及 pattern yyyy-MM-dd HH:mm:ss z，這樣我們待會就可以使用 BUILD_TIMESTAMP 參數來獲取當下時間，記得要按下儲存歐！ 設定 Build Timestamp\" 設定 Build Timestamp 安裝/設定 Notify.Events Notify.Events 這個套件可以串接很多的平台，例如 Telegram、Slack、Line 等，也可以透過它寄發郵件，是一個十分方便的套件，但缺點是他需要註冊，免費版只有每個月 300 次的訊息傳輸量，但在我們測試階段已經十分夠用。一樣我們用剛剛的方法安裝 Notify.Events。 安裝 Notify.Events\" 安裝 Notify.Events 安裝好後，Notify.Events 他不需要先設定，它可以依據不同的 Job 有不同的設定，所以我們開啟剛剛的 Job 組態，拉到最下面找到 建置後動作 ，選擇 Notify.Events： 安裝 Notify.Events\" 安裝 Notify.Events 可以看到這邊要先輸入 Token，那 Token 就必須去官網註冊後設定。 我們先開啟瀏覽器，搜尋 Notify.Events，註冊帳號後，在 Channels 點選 Create，輸入一下 Title 按下 Save。 Notify.Events 官網設定\" Notify.Events 官網設定 完成後，應該可以看到以下畫面，這邊就可以讓我們選擇來源，以及要發送到哪裡： Notify.Events 官網設定\" Notify.Events 官網設定 我們先選擇 Sources，點選 Add source，可以看到很多來源，選擇 CI/CD and Version control ，再選擇 Jenkins： Notify.Events 官網設定\" Notify.Events 官網設定 點選 Next，就可以看到以下畫面，它告訴我們要將它提供的 Token 貼入設定檔，也就是我們剛剛在 Job 組態裡面的那個 Token： Notify.Events 官網設定\" Notify.Events 官網設定 設定好 Sources，接下來要設定接收方，回到剛剛 Notify.Events 的儀表板，點選 Subscribe，我們測試使用 Telegram 來當接收方，它會跳出一個視窗，告訴你要怎麼把他的機器人加成好友或是加入群組，這邊就依大家需要自行選擇，那我就將它加入群組，使用 /subscribe DRr0bIZ0 @NotifyEventsBot 指令來綁定 Notify.Events 官網設定\" Notify.Events 官網設定 這時候我們都設定好了，我們回到 Job 組態的 Notify.Events 設定位置，將 Token 貼上去，它可以自訂訊息的模板，可以全部都一樣，也可以針對建置後的狀態，產生不同的訊息模板，我們來自定義設計一下： Success 📢 Jenkins 建置通知 📣 時間：$BUILD_TIMESTAMP 🕐 名稱： \u003ca href=\"$PROJECT_URL\"\u003e$PROJECT_NAME\u003c/a\u003e 次數： \u003ca href=\"$BUILD_URL\"\u003e#$BUILD_NUMBER\u003c/a\u003e 建置狀態： 🟢 \u003cb\u003e$BUILD_STATUS\u003c/b\u003e 🟢 \u003ca href=\"$BUILD_URL/console\"\u003e建置日誌連結\u003c/a\u003e --------- 😍😍😍 --------- Notify.Events Success\" Notify.Events Success Failure 📢 Jenkins 建置通知 📣 時間：$BUILD_TIMESTAMP 🕐 名稱： \u003ca href=\"$PROJECT_URL\"\u003e$PROJECT_NAME\u003c/a\u003e 次數： \u003ca href=\"$BUILD_URL\"\u003e#$BUILD_NUMBER\u003c/a\u003e 建置狀態： 🔴 \u003cb\u003e$BUILD_STATUS\u003c/b\u003e 🔴 \u003ca href=\"$BUILD_URL/console\"\u003e建置日誌連結\u003c/a\u003e --------- 😭😭😭 --------- Notify.Events Failure\" Notify.Events Failure Telegram 通知測試 最後我們都設定好了，就來測試一下吧！我們先故意將程式碼格式用錯，讓他先跳出錯誤，再修改，來看看結果如何吧！(文字連結是對應的 Commit ) Telegram 通知\" Telegram 通知 可以看到，我們分別兩次的測試，會依據我們建置後的結果，觸發不同的通知模板。 ","date":"2022-05-16","objectID":"/jenkins/:2:4","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"參考資料 30 天入門 Ansible 及 Jenkins [CI]設定jenkins連結GitHub Private Repo by Webhook ","date":"2022-05-16","objectID":"/jenkins/:3:0","tags":["Jenkins","CI/CD","介紹","實作"],"title":"使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot","uri":"/jenkins/"},{"categories":["codenotes"],"content":"此文章是介紹參考網路上 30 天入門 Ansible 及 Jenkins，自己實際測試後的筆記紀錄，歡迎大家可以先閱讀原文，原文會放在文章最後，歡迎大家指教 😁","date":"2022-05-11","objectID":"/jenkins-ansible/","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"在軟體開發領域中，IT 自動化 (automation) 及 持續整合 (Continuous Integration, CI) 、持續佈署 (Continuous Deployment,CD) 是 DevOps 精神中很重要的兩個部分，此文章是參考 30 天入門 Ansible 及 Jenkins ，再加上自己測試後的筆記紀錄，歡迎大家可先閱讀作者原文，那我們就開始一起學習吧 👊 我會分別介紹 Ansible 與 Jenkins 這兩個非常熱門的開源軟體再搭配實作來讓大家更了解他們，那在之前我們先來聊聊為什麼需要 IT 自動化以及什麼是持續整合/持續部署吧 🤠 ","date":"2022-05-11","objectID":"/jenkins-ansible/:0:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"為什麼需要 IT 自動化 ? 當我們在開發任何軟體產品時，除了開發本身的過程需要花相當多的心力外，在產品部署的環節也是讓大家頭痛的一個部分。其環境的搭建或是參數的設定常常會因為一些小原因導致產品無法像在開發時一樣正常運作。尤其當需要部署的主機不只一台時，重複性的工作會花費我們大量的時間。再加上還會因為伺服器提供的作業環境不同、或是其他種種限制而必須做參數上的調整等等。 這時候 IT 自動化 就顯得十分重要，透過自動化，不但可以幫助開發人員有效減少部署產品所需時間外，還可以在有限度的修改下分別針對不同環境去做調整。 Best Automation Tools for DevOps\" Best Automation Tools for DevOps ","date":"2022-05-11","objectID":"/jenkins-ansible/:1:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"什麼是持續整合/持續部署 當環境搭建成功後，對於服務本身的維護以及監控也是開發流程中相當重要的一環。當我們從原始碼代管服務 (GitHub、GitLab)上取得原始碼後，要如何確保產品在發布前品質沒有問題，一直以來都是開發人員需要思考的一個課題。 由於現在多數開發團隊都會透過版本控制來提交並整合開發人員各自修改的程式碼，若在合併分支時沒有把合併衝突 (conflict) 處理恰當，或是合併程式碼後產生某些邏輯錯誤，往往會到產品發佈後才發現不可預期的錯誤。 所以有了持續整合/持續部署的機制下，我們可以透過高頻率的整合、測試並分析程式碼品質，在最短時間發現問題以及發生點，進而確保產品每一次的發布都是穩定且高品質的。 CI/CD 流程圖 (作者打錯是 rsync 不是 rsyne) Day12 什麼是 CICD\" CI/CD 流程圖 (作者打錯是 rsync 不是 rsyne) Day12 什麼是 CICD 上面這張圖是簡化版的 CI/CD 流程圖，當我們 Developer 將程式 Push 到原始碼代管服務 (GitHub、GitLab)上，會經過 Webhook 給 Jenkins 這種自動化可以持續整合部署到各自的伺服器上。 那 CI \u0026 CD 分別負責哪些工作呢？ ","date":"2022-05-11","objectID":"/jenkins-ansible/:2:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"持續整合 Continuous Integration 持續整合的英文是 Continuous Integration 我們縮寫成 CI ，後續也會使用 CI 來做說明： 流程： 程式建置 開發人員在每一次的 Commit \u0026 Push 後，都能夠於統一的環境自動 Build 程式，透過此步驟可以避免每個開發人員因本機的環境或是套件版本不同導致出現異常。 程式測試 當程式編譯完後，透過單元測試測試新寫的功能是否正確，或者確定是否會影響現有功能，透過該步驟進行測試，可以避免開發人員遺忘先在本機檢查，作為雙重驗證之功用。 目的： 降低人為疏失風險 減少人工手動的反覆動作 進行版本控制 增加系統一制性與透明化 ","date":"2022-05-11","objectID":"/jenkins-ansible/:2:1","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"持續佈署 Continuous Deployment 持續佈署的英文是 Continuous Deployment 我們縮寫成 CD ，後續也會使用 CD 來做說明： 流程： 部署服務 透過自動化方式，將寫好的程式碼更新到機器上並公開對外服務，另外需要確保套件版本＆資料庫資料的完整性，也會透過監控系統進行服務存活檢查，若服務異常會即時發送通知告知開發人員。 目的： 保持每次更新程式都可以順暢完成 確保服務存活 我們了解了自動化與 CI/CD 的重要性與功用，那我們要怎麼去實現這些呢！我們先看下面這張圖： Top 5 DevOps Automation Tools in 2020\" Top 5 DevOps Automation Tools in 2020 這邊整理 2020 年適合用於 DevOps Automation 的工具，那我們本次教學會介紹最多人使用的 Jenkins 以及 Ansible 兩種： ","date":"2022-05-11","objectID":"/jenkins-ansible/:2:2","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"Jenkins Jenkins 是使用 Java 編成語言編寫最受歡迎的開源自動化服務器。它促進了軟體開發過程中的持續整合、持續部署的自動化過程。 Jenkins 支持 1800 多個其他軟體套件，Jenkins 易於安裝和使用，它還提供方便瀏覽的項目管理儀表板，它的優點還有： 免費開源 充滿活力的用戶社群 多種工具和技術集成 插件支持 易於安裝、配置和升級 監控外部工作 支持各種身份驗證方法、通知、版本控制等等 ","date":"2022-05-11","objectID":"/jenkins-ansible/:3:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"Ansible Ansible 是一種 IT 自動化工具。它可以部署軟體、配置系統，並編排更高級的自動化任務，例如 CD (持續部署) 或 RollingUpdate 零停機的滾動更新。 自動化簡化了複雜的任務，不僅使開發人員的工作更容易管理，也讓他們的注意力可以放在對團體更有價值的其他任務上。換句話說，它可以節省時間並提高效率。Ansible 使用簡單的 YAML 語法，且 Ansible 是一種輕量級且安全的解決方案，它的優點還有： 使用 Ansible 不需要任何特殊的編程技能，因為使用的是 YAML 語法 Ansible 允許建立高複雜性的 IT 自動化。 因為不需要安裝其他套件，所以伺服器上有更多空間來容納應用服務的支援 Ansible 在設計上非常簡單且可靠一制性。 ","date":"2022-05-11","objectID":"/jenkins-ansible/:4:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"Jenkins 跟 Ansible 比較 名稱 Jenkins Ansible 套件 Jenkins 支持 1800 多種套件 支持較少套件 語言 支持 C、C++、Java、Perl、Python、Ruby 等 支持 C、Python、JavaScript、Ruby 等 費用 Jenkins 是免費的 Ansible 不是免費的，但有試用版(Red hat) 大小 重量級 輕量級 服務 基於伺服器的工具 基於雲上的工具 ","date":"2022-05-11","objectID":"/jenkins-ansible/:5:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"Jenkins 與 Ansible 介紹實作連結 由於 Jenkins 與 Ansible 介紹與實作教學文章較長，故個別分開一篇文章來做說明，大家可以去看自己有興趣的文章歐 😎 Jenkins：使用 Jenkins 設定 GitHub 觸發程序並通知 Telegram Bot Ansible：Ansible 介紹與實作 (Inventory、Playbooks、Module、Template、Handlers) ","date":"2022-05-11","objectID":"/jenkins-ansible/:6:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"參考資料 30 天入門 Ansible 及 Jenkins Day12 什麼是 CICD Jenkins和Ansible的對比和區別 ","date":"2022-05-11","objectID":"/jenkins-ansible/:7:0","tags":["Ansible","Jenkins","CI/CD","介紹","實作"],"title":"Jenkins 及 Ansible IT 自動化 CI/CD 介紹","uri":"/jenkins-ansible/"},{"categories":["codenotes"],"content":"此文章是介紹參考網路上 K8s 搭配 EFK 範例，自己實際測試後的紀錄，歡迎大家可以先閱讀原文，原文會放在文章最後，歡迎大家指教 😁","date":"2022-05-10","objectID":"/k8s-efk/","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"這是我們 Kubernetes 文章的第三篇，此文章會紀錄我將 EFK 建在 Kubernetes 上面，最後也會統整實作過程中，可能會遇到的一些問題，讓大家在學習時，可以更有效率，不用 debug 到死 😎😎 那由於本文會直接帶入程式，觀念部分，可以先查看： Kubernetes : Kubernetes (K8s) 介紹 - 基本 kubernetes : Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap) EFK : 用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose) 此文章程式碼也會同步到 Github ，需要的也可以去查看歐！要記得先確定一下自己的版本 Github 程式碼連結 😆 ","date":"2022-05-10","objectID":"/k8s-efk/:0:0","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"版本資訊 macOS：11.6 Minikube：v1.25.2 hyperkit：0.20200908 Kubectl：Client Version：v1.22.5、Server Version：v1.23.3 Elasticsearch：8.1.3 Fluentd：v1.14.6-debian-elasticsearch7-1.0 Kibana：8.1.3 ","date":"2022-05-10","objectID":"/k8s-efk/:1:0","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"實作 ","date":"2022-05-10","objectID":"/k8s-efk/:2:0","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"創建命名空間 在我們開始之前，我們首先建立一個命名空間，我們會將 EFK 所有的工具都安裝在此。那我想創建一個名為 kube-logging 的 namespace，先查詢現有的命名空間是否有重複： $ kubectl get namespaces 我們可以看到這些已經存在的 namespace ： NAME STATUS AGE default Active 92m kube-logging Active 89m kube-node-lease Active 92m kube-public Active 92m kube-system Active 92m kubernetes-dashboard Active 92m 那要怎麼創建一個命名空間呢？先打開編輯器編輯名為 kube-logging.yaml： apiVersion:v1kind:Namespacemetadata:name:kube-logging 完成後，使用 apply 來創建命名空間： $ kubectl apply -f kube-logging.yaml namespace/kube-logging created 再使用 kubectl get namespaces 查看是否多了一個名為 kube-logging 的命名空間： $ kubectl get namespaces NAME STATUS AGE default Active 2m23s kube-logging Active 88s kube-node-lease Active 2m24s kube-public Active 2m24s kube-system Active 2m24s kubernetes-dashboard Active 2m19s ","date":"2022-05-10","objectID":"/k8s-efk/:2:1","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"創建 Elasticsearch StatefulSet 我們已經創建好一個命名空間來放我們的 EFK，首先先部署副本數有 3 個的 Elasticsearch Pod。為什麼要使用 3 個 呢？使用 3 個 Elasticsearch Pod 是為了避免在高可用性、多節點叢集時出現錯誤，當其中一個 Elasticsearch Pod 故障，其他 2 個就會選舉後來接替，保證叢集可以繼續運行。 創建 Headless Service 我們先創建名為 elasticsearch_svc.yaml 的 yaml 檔，用來處理 service 的問題： apiVersion:v1kind:Servicemetadata:name:elasticsearchnamespace:kube-logginglabels:app:elasticsearchspec:selector:app:elasticsearchclusterIP:Noneports:- port:9200name:rest- port:9300name:inter-node 我們有創建一個命名空間，所以要先在 metadata 加入 namespace: kube-logging。記得要設定標籤，當我們將 Elasticsearch StatefulSet 與此 Service 關聯時，Service 會返回指向的帶有標籤的 Elasticsearch Pod。然後我們設置 clusterIP: None 定義該 Service 為 Headless Service。最後定義 Port 9200 為 REST API、Port 9300 為 Node 之間的通信。 一樣使用 apply 來建立 Service： $ kubectl apply -f elasticsearch-svc.yaml service/elasticsearch created 我們這次直接查看 minikube dashboard： elasticsearch service\" elasticsearch service 創建 StatefulSet 創建名為 elasticsearch_statefulset.yaml 的 yaml 檔案 (因為程式長度，所以分開說明，要完整請參考 Github 程式碼連結)： apiVersion:apps/v1kind:StatefulSetmetadata:name:es-clusternamespace:kube-loggingspec:serviceName:elasticsearchreplicas:3selector:matchLabels:app:elasticsearchtemplate:metadata:labels:app:elasticsearch 名稱取名為 es-cluster ，我一樣使用 kube-logging 的 namespace，設定 ServiceName elasticsearch 是確保 StatefulSet 中的每一個 Pod 都可以使用以下 DNS 位址進行訪問：es-cluster-[0,1,2].elasticsearch.kube-logging.svc.cluster.local ，其中 [0,1,2] 對應 Pod 分配的整數序號。 我們指定副本數為 3，並將 matchLabels 選擇器設定 app: elasticseach，我們在將其鏡像到該 .spec.template.metadata，.spec.selector.matchLabels 跟 .spec.template.metadata.labels 必須相同。 接續… spec:containers:- name:elasticsearchimage:elasticsearch:8.1.3resources:limits:cpu:1000mrequests:cpu:100mports:- containerPort:9200name:restprotocol:TCP- containerPort:9300name:inter-nodeprotocol:TCPvolumeMounts:- name:datamountPath:/usr/share/elasticsearch/dataenv:- name:cluster.namevalue:k8s-logs- name:node.namevalueFrom:fieldRef:fieldPath:metadata.name- name:discovery.seed_hostsvalue:\"es-cluster-0.elasticsearch,es-cluster-1.elasticsearch,es-cluster-2.elasticsearch\"- name:cluster.initial_master_nodesvalue:\"es-cluster-0,es-cluster-1,es-cluster-2\"- name:ES_JAVA_OPTSvalue:\"-Xms512m -Xmx512m\"- name:xpack.security.enabled# 記得要加上，因爲 Elasticsearch 8.x版本後會自動開啟SSL，如果沒有設定他就會一直重新啟動value:\"false\" 我們定義容器名稱是 elasticsearch，映像檔是 elasticsearch:8.1.3 ，要記得這個版本要與後面的 kibana 相同，我們在 resources 設置容器至少需要 0.1 CPU，最多可以到 1 個 CPU。一樣設定 Port 9200 為 REST API、Port 9300 為 Node 之間的通信，並將名為 data 的PersistentVolume 的容器掛載到容器的 /usr/share/elasticsearch/data。 最後幫容器設置一些環境變數： cluster.name：Elasticsearch 叢集的名稱，我們設定為 k8s-logs。 node.name：節點名稱，我們設置 valueFrom 使用 .metadata.name，它會解析為 es-cluster-[0,1,2]，取決節點的指定順序。 discovery.seed_hosts：設置叢集中主節點列表，這些節點將會為節點發現過程中提供 Pod，但由於我們配置的 Headless Service，所以我們的 Pod 具有 es-cluster-[0,1,2].elasticsearch.kube-logging.svc.cluster.local Kubernetes DNS 解析。 cluster.initial_master_nodes：這邊指定將參與主節點的選舉過程節點列表，這邊是通過節點 node.name 來辨識，不是透過主機名。 ES_JAVA_OPTS：這邊我們設置 -Xms512m -Xmx512m，告訴 JVM 使用最大跟最小 512 MB，可以依據資源來做調配。 xpack.security.enabled：這是也是我在 elasticsearch 卡很久的一個設定，詳細的會在最後的常見問題中提到，大家只要記得 elasticsearch 8.x 以後都需要多這個。 接續… initContainers:- name:fix-permissionsimage:busyboxcommand:[\"sh\",\"-c\",\"chown -R 1000:1000 /usr/share/elasticsearch/data\"]securityContext:privileged:truevolumeMounts:- name:datamountPath:/usr/share/elasticsearch/data- name:increase-vm-max-mapimage:busyboxcommand:[\"sysctl\",\"-w\",\"vm.max_map_count=262144\"]securityContext:privileged:true- name:increase-fd-ulimitimage:busyboxcommand:[\"sh\",\"-c\",\"ulimit -n 65536\"]securityContext:privileged:true 我們這個區塊定義了主容器運行前的初始化設定： fix-permissions：因為默認情況下，Kubernetes 會將數據目錄掛載為 root，導致 Elasticsearch 無法訪問，所以才會多這個運行 chown 將 Elasticsearch 數據目錄的所有者和組更改為 1000:1000 /usr/share/elasticsearch/data。詳細可以參考 Notes for Production Use and Defaults。 increase-vm-max-map：這邊是因為默認情況下內存會太低，所以多這個用 sysctl -w 來調整內存大小。詳細可以參考 Elasticsearch documentation。 iincrease-fd-ulimit：它運行 ulimit 調整打開文件描述的最大數量。詳細可以參考 Notes for Production Use and Defaults。 接續… volumeClaimTemplates:- metadata:name:datalabels:app:elasticsearchsp","date":"2022-05-10","objectID":"/k8s-efk/:2:2","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"創建 Kibana Deployment Service 要在 Kubernetes 上啟動 Kibana，我們要先創建一個名為 Service kibana，以及包含一個副本的 Deployment。我們先創建名為 kibana.yaml 的 yaml 檔： apiVersion:v1kind:Servicemetadata:name:kibananamespace:kube-logginglabels:app:kibanaspec:ports:- port:5601selector:app:kibana---apiVersion:apps/v1kind:Deploymentmetadata:name:kibananamespace:kube-logginglabels:app:kibanaspec:replicas:1selector:matchLabels:app:kibanatemplate:metadata:labels:app:kibanaspec:containers:- name:kibanaimage:kibana:8.1.3resources:limits:cpu:1000mrequests:cpu:100menv:- name:ELASTICSEARCH_URLvalue:http://elasticsearch:9200ports:- containerPort:5601 一樣我們要把 kibana 加入 kube-logging 的命名空間，讓它以去調用其他服務，並賦予 app: kibana 標籤。並指定本機訪問 Port 為 5601，並使用 app: kibana 標籤來選擇服務的 Pod。我們在 Deployment 定義 1 個 Pod 副本，我們使用 kibana:8.1.3 image，記得要跟 Elasticsearch 使用相同版本，此外我們還有設定 Pod 最少使用 0.1 個 CPU、最多使用 1 個 CPU。最後在環境變數中使用 ELASTICSEARCH_URL 設定 Elasticsearch 的叢集以及 Port。 都完成後，我們來開始部署： $ kubectl apply -f kibana.yaml service/kibana created deployment.apps/kibana created 一樣我們用 minikube dashboard 來查看是否部署成功： kibana Deployments\" kibana Deployments 沒有問題後，我們用 port-forward 將本地 Port 轉發到 Pod 上： $ kubectl port-forward kibana-75cbbfcd9c-nr4r8 5601:5601 --namespace=kube-logging Forwarding from 127.0.0.1:5601 -\u003e 5601 Forwarding from [::1]:5601 -\u003e 5601 Handling connection for 5601 開啟瀏覽器瀏覽 http://localhost:5601，如果可以進入 Kibana，就代表成功將 Kibana 部署到 Kubernetes 叢集中： kibana Deployments\" kibana Deployments ","date":"2022-05-10","objectID":"/k8s-efk/:2:3","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"創建 Fluentd DaemonSet 我們要將 Fluentd 設置成 DaemonSet，讓它在 Kubernetes 叢集中每個節點上運行 Pod 副本。用 DaemonSet 控制器，可以將叢集中每個節點部署 Fluentd Pod，詳細可以參考 Using a node logging agent。在 Kubernetes 中，容器化的應用程式會透過 stdout 將日誌 log 定向到節點上的 JSON 文件。Fluentd Pod 會追蹤這些日誌文件、過濾日誌事件、轉換日誌的數據，並發送到我們部署的 Elasticsearch 後端。 除了容器的日誌，Fluentd 還會追蹤 Kubernetes 系統日誌，例如：kubelet、kube-proxy 和 Docker 日誌。 先創建一個 fluentd.yaml 的 yaml 檔 (因為程式長度，所以分開說明，要完整請參考 Github 程式碼連結)： 創建 ServiceAccount apiVersion:v1kind:ServiceAccountmetadata:name:fluentdnamespace:kube-logginglabels:app:fluentd 我們先創建一個服務帳號 fluentd，Fluentd Pod 將使用它來訪問 Kubernetes API。我們在 kube-logging namespace 中創建它並再次賦予它 label app: fluentd。 創建 ClusterRole 接著… apiVersion:rbac.authorization.k8s.io/v1kind:ClusterRolemetadata:name:fluentdlabels:app:fluentdrules:- apiGroups:- \"\"resources:- pods- namespacesverbs:- get- list- watch 在這邊我們定義一個 ClusterRole fluentd，設定我們對叢集範圍的 Kubernetes 資源（如節點）的訪問權限，我們設定 get、list、watch 等權限。 創建 ClusterRoleBinding 接著… kind:ClusterRoleBindingapiVersion:rbac.authorization.k8s.io/v1metadata:name:fluentdroleRef:kind:ClusterRolename:fluentdapiGroup:rbac.authorization.k8s.iosubjects:- kind:ServiceAccountname:fluentdnamespace:kube-logging 我們定義一個將 ClusterRole 綁定到 ServiceAccount 的 ClusterRoleBinding 調用。 創建 DaemonSet 接著… apiVersion:apps/v1kind:DaemonSetmetadata:name:fluentdnamespace:kube-logginglabels:app:fluentd 定義一個可以在 kube-logging namespace 中調用的 DaemonSet，並給它一個 app: fluentd 標籤。 接著… spec:selector:matchLabels:app:fluentdtemplate:metadata:labels:app:fluentdspec:serviceAccount:fluentdserviceAccountName:fluentdtolerations:- key:node-role.kubernetes.io/mastereffect:NoSchedulecontainers:- name:fluentdimage:fluent/fluentd-kubernetes-daemonset:v1.14.6-debian-elasticsearch7-1.0env:- name:FLUENT_ELASTICSEARCH_HOSTvalue:\"elasticsearch.kube-logging.svc.cluster.local\"- name:FLUENT_ELASTICSEARCH_PORTvalue:\"9200\"- name:FLUENT_ELASTICSEARCH_SCHEMEvalue:\"http\"- name:FLUENTD_SYSTEMD_CONFvalue:disable 我們先匹配 .metadata.labels 定義的標籤 app: fluentd ，然後為 DaemonSet 分配 fluentd Service Account。選擇 app: fluentd 作為這個 DaemonSet 管理的 Pod。 我們定義 NoSchedule 容忍度來匹配 Kubernetes master node 上的等效污點。他可以確保 DaemonSet 也被部署到 Kubernetes 主服務器。 接下來定義 Pod 容器，我們將名稱取為 fluentd，我們使用的映像檔是 fluent/fluentd-kubernetes-daemonset:v1.14.6-debian-elasticsearch7-1.0，最後配置一些環境變數： FLUENT_ELASTICSEARCH_HOST：設置我們之前定義的 Elasticsearch Headless 位址。elasticsearch.kube-logging.svc.cluster.local 會解析 3 個 Elasticsearch Pod 的 IP 地址列表。 FLUENT_ELASTICSEARCH_PORT：設置我們之前定義的 Elasticsearch 9200 Port。 FLUENT_ELASTICSEARCH_SCHEME：我們設置 http。 FLUENTD_SYSTEMD_CONF：我們將 systemd 在容器中設定相關的輸出設置為 disable。 接著… resources:limits:memory:512Mirequests:cpu:100mmemory:200MivolumeMounts:- name:varlogmountPath:/var/log- name:varlibdockercontainersmountPath:/var/lib/docker/containersreadOnly:trueterminationGracePeriodSeconds:30volumes:- name:varloghostPath:path:/var/log- name:varlibdockercontainershostPath:path:/var/lib/docker/containers 我們設置 Fluentd Pod 上使用 512 MiB 的內存限制，並保證 0.1 個 CPU 跟 200 MiB 的內存。我們將 varlog /var/log 以及 varlibdockercontainers var/lib/docker/containers 一併掛載進容器內。最後一個設定是 Fluentd 在收到信號 terminationGracePeriodSeconds 後有 30 秒的時間可以優雅的關閉。 都定義完成後，我們部署 Fluentd DaemonSet： $ kubectl apply -f fluentd.yaml serviceaccount/fluentd created clusterrole.rbac.authorization.k8s.io/fluentd created clusterrolebinding.rbac.authorization.k8s.io/fluentd created daemonset.apps/fluentd created 一樣我們用 minikube dashboard 來查看是否部署成功： fluentd DaemonSet\" fluentd DaemonSet 我們使用剛剛的 kibana port-forward 將本地 Port 轉發到 Pod 上： $ kubectl port-forward kibana-75cbbfcd9c-nr4r8 5601:5601 --namespace=kube-logging Forwarding from 127.0.0.1:5601 -\u003e 5601 Forwarding from [::1]:5601 -\u003e 5601 Handling connection for 5601 開啟瀏覽器瀏覽 http://localhost:5601，點選 Management \u003e Stack Management： fluentd 設定\" fluentd 設定 點選 Kibana \u003e Data Views，會看到跳出一個視窗，有一個按鈕寫 Create data view： fluentd 設定\" fluentd 設定 Name 輸入 logstash* ，並選擇 @timestamp 來用時間過濾日誌，最後按下 Create date view： fluentd 設定\" fluentd 設定 設定好 logstash* 的 Data views，再點選左邊欄位的 Discover： fluentd 設定\" fluentd 設定 就可以看到顯示容器的 log 日誌拉！ 顯示容器 ","date":"2022-05-10","objectID":"/k8s-efk/:2:4","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"部署常見問題及解決辦法 常見問題 Q1 . Elasticsearch 部署成功後會一直重新啟動？ 解決辦法 Ans 1：原因是 Elasticsearch 從 8.x 版本後，會自動開啟 SSL 認證，我們在 env 環境變數設定時，如果沒有多加 SSL Key 等設定值，Elasticsearch 這個 Pod 會啟動後，一直重新啟動，導致服務無法正常使用，只需要在環境變數中加入 xpack.security.enabled ，設定為 false 就可以解決。 ","date":"2022-05-10","objectID":"/k8s-efk/:3:0","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"參考資料 How To Set Up an Elasticsearch, Fluentd and Kibana (EFK) Logging Stack on Kubernetes ","date":"2022-05-10","objectID":"/k8s-efk/:4:0","tags":["Kubernetes","K8s","EFK","實作"],"title":"Kubernetes (K8s) 搭配 EFK 實作 (Deployment、StatefulSet、DaemonSet)","uri":"/k8s-efk/"},{"categories":["codenotes"],"content":"此文章是介紹 Kubernetes 進階，會介紹 Service、Ingress、Deployment、ReplicaSet、ConfigMap 等等，多數是參考網路大神分享，加上自己整理自己能理解的加以介紹，歡迎大家指教 😁","date":"2022-05-03","objectID":"/k8s-advanced/","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"前面我們在基本篇中，為了使 Pod 能夠與本機連線，使用了 port-forward，還有另一種方法就是今天要介紹的第一個主題：Service 那我們會先複習一下 port-forward，再來介紹 Service，當然後面也會有實際操作，請大家跟我繼續一起學下去吧 ！ ","date":"2022-05-03","objectID":"/k8s-advanced/:0:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"port-forward port-forward 簡單來說就是把本機的某一個 Port 與 Pod 所開放對外的 Port 做映射，就像是我們在 Docker 跑 container 時會使用 -p 來連結機器與 container 的 port 一樣～ 使用的方法也很簡單且方便，使用 kubectl port-forward \u003cpod\u003e \u003cexternal-port\u003e:\u003cpod-port\u003e，我們拿 Kubernetes 基本篇最後的範例，來做說明： $ kubectl port-forward kubernetes-demo-pod 3000:3000 Forwarding from 127.0.0.1:3000 -\u003e 3000 Forwarding from [::1]:3000 -\u003e 3000 Handling connection for 3000 我們把 kubernetes-demo-pod 這個 pod，用 port-forward 設定本機 3000 port 與 pod 3000 port 做映射，當我們瀏覽 http://localhost:3000 就可以看到 pod 裡面的內容了！ 雖然很方便，可以馬上就開好要映射的 port，但缺點就是每次建立 pod 時都需要手動去打指令來設定 port，且時間久了，也會忘記本機上哪些 port 有被使用到，因此這邊推薦使用 Service 來取代 port-forward，那我們來看看 Service 是什麼吧。 ","date":"2022-05-03","objectID":"/k8s-advanced/:1:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Service ? service 他其實就是建立的一個網路連線通道，可以讓應用程式正確的連結到正在運行的 pods，而 service 又有4種的表現形式，我們接下來會一個一個簡單介紹： ","date":"2022-05-03","objectID":"/k8s-advanced/:2:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"ClusterIP 它是 service 的預設值，所以沒有設定時，預設就是使用該方式做連線，它代表這個 service 只能在相同的 cluster 內使用，無法讓外部做使用。 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"NodePort 簡單來說它可以從外部連線到內部使用。假設本機有其他服務，例如：nginx 之類的服務，還有架一個 K8s 的 cluster ，這時候只要設定好 NodePort，就可以讓本機使用 K8s cluster 來使用內部的服務。 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"ExternalName 主要是為了讓不同 namespace ，以 ClusterIP 所生成的 service 可以利用 ExternalName 設定外部名稱，藉以連到指定的 namespace Service。 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"LoadBalancer 這個屬性是強化版的 NodePort，除了 NodePort 可以讓外部連線的優點以外，同時也建立負載平衡的機制來分散流量，很可惜 LoadBalaner 只提供雲端服務，例如：GCP、AWS 等等都有支援，目前 minikube 要使用 LoadBalancer 需要先啟動 tunnel 才能做使用。tunnel 是什麼呢？我們後面會說明！ k8s service 流程圖 Kubernetes 那些事 — Service 篇\" k8s service 流程圖 Kubernetes 那些事 — Service 篇 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:4","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"NodePort 實作 那我們來用 Service (NodePort) 改寫基本篇的連線問題 ：(Github 程式碼連結) service.yaml apiVersion:v1kind:Servicemetadata:name:kubernetes-demo-servicelabels:app:demospec:type:NodePortports:- protocol:TCPport:3000targetPort:3000nodePort:30001selector:app:demo 結構與 kubernetes-demo.yaml 相同，以下簡單說明不同之處： kind 該元件的屬性，此設定檔的類型是：Service spec type：指定此 Service 要使用的方法，這邊我們使用 NodePort。 ports.protocol：此為連線的網路協議，預設值為 TCP，當然也可以使用 UDP。 ports.port：此為建立好的 Service 要以哪個 Port 連接到 Pod 上。 ports.targetPort：此為目標 Pod 的 Port ，通常 port 跟 targetPort 一樣。 ports.nodePort：此為機器上的 Port 要對應到該 Service 上，這個設定要 nodePort 形式的 Service 才會有效果，假設今天沒有設定 nodePort ，Kubernetes 會自動開一個機器上的 Port 來對應該 Service ，範圍是在 30000 - 37267之間。 selector.app：如果要使 Service 連接到正確的 Pod 就必須利用 selector，只要原封不動的把 Pod 的 Labels 複製上去即可。 接下來使用 kubectl apply 建立 service： $ kubectl apply -f service.yaml k8s 建立 service (NodePort)\" k8s 建立 service (NodePort) 接下來取得 minikube Node IP，可以使用： $ minikube ip 192.168.64.11 打開瀏覽器搜尋 192.168.64.11:30001 就可以看到我們可愛的柴犬囉 \u003e\u003c 成功顯示柴犬\" 成功顯示柴犬 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:5","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"LoadBalancer 實作 那我們來用 Service (LoadBalancer) 改寫基本篇的連線問題 ：(Github 程式碼連結) service.yaml apiVersion:v1kind:Servicemetadata:name:kubernetes-demo-servicelabels:app:demospec:type:LoadBalancerports:- protocol:TCPport:3000targetPort:3000selector:app:demo 結構與 kubernetes-demo.yaml 相同，以下簡單說明不同之處： kind 該元件的屬性，此設定檔的類型是：Service spec type：指定此 Service 要使用的方法，這邊我們使用 LoadBalancer。 ports.protocol：此為連線的網路協議，預設值為 TCP，當然也可以使用 UDP。 ports.port：此為建立好的 Service 要以哪個 Port 連接到 Pod 上。 ports.targetPort：此為目標 Pod 的 Port ，通常 port 跟 targetPort 一樣。 selector.app：如果要使 Service 連接到正確的 Pod 就必須利用 selector，只要原封不動的把 Pod 的 Labels 複製上去即可。 接下來使用 kubectl apply 建立 service： $ kubectl apply -f service.yaml k8s 建立 service (LoadBalancer)\" k8s 建立 service (LoadBalancer) 可以看到 dashboard 有我們剛剛啟動的 Service，但是啟動後前面的燈是黃色的，是因為 minikube LoadBalancer 需要透過 tunnel 才可以使用，可以參考 minikube 官網說明： minikube 官網 說明 LoadBalancer minikube tunnel\" minikube 官網 說明 LoadBalancer minikube tunnel 所以我們需要使用 minikube tunnel 來啟動 tunnel $ minikube tunnel ✅ Tunnel successfully started 📌 NOTE: Please do not close this terminal as this process must stay alive for the tunnel to be accessible ... 🏃 Starting tunnel for service kubernetes-demo-service. 就可以看到燈號已經變成綠燈，在外部 Endpoints 多一個連結，可以直接點開 k8s service\" k8s service 就可以看到我們可愛的柴犬囉 \u003e\u003c 成功顯示柴犬\" 成功顯示柴犬 ","date":"2022-05-03","objectID":"/k8s-advanced/:2:6","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Ingress ? 還記得我們在 Service - NodePort 時，需要打 \u003cip\u003e:\u003cport\u003e ，但現在網站除了網域以外，基本上不會需要自己去打 IP 以及 Port 了吧！那為了解決這個問題，有了 Ingreess。 Ingress 可以幫助我們統一對外的 port number，並根據 hostname 或是 pathname 來決定請求要轉發到哪一個 Service 上，之後就可以利用該 Service 連接到 Pod 來處理服務。 我們先來看一下一般的 Service ： Service 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller\" Service 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller 可以看到當多個 Service 同時運行時，Node 都需要有對應的 port number 去對應每個 Server 的 port number。像是 GCP 這種雲端服務，每台機器都會配置屬於自己的防火牆。這也代表，不論新增、刪除 Service 物件，都必須要額外多調整防火牆的設定，Port 的管理也想對複雜。 若是使用 Ingress，我們只需要開放一個對外的 port numer，Ingree 可以在設定檔中設定不同的路徑，決定要將使用者的請求傳送到哪一個 Service 物件上： Ingress 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller\" Ingress 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller 這樣的設計，除了讓維運人員不需要維護多個 port 或是頻繁的更改防火牆外，可以自訂條件的功能，也使得請求的導向可以更加彈性。 ","date":"2022-05-03","objectID":"/k8s-advanced/:3:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Ingress 功能 將不同\"路徑\"的請求對應到不同的 Service 物件 若沒有設定網域，則該機器上的所有網域只要透過此路徑都可以連接到指定的 Service 物件。 將不同\"網域\"的請求對應到不同的 Service 物件 若沒有設定路徑，則會以 / 路徑連接到指定的 Service 物件。 支援 SSL Termination SSL 全名是傳輸層安全性協定，而網站通常都會利用 https 進行加密以確保資料安全，但 Service 與 Pod 之間的溝通都是以無加密方式傳輸，所以 Ingress 就支援解密，讓 Service 與 Pod 可以正常溝通傳遞資料。 ","date":"2022-05-03","objectID":"/k8s-advanced/:3:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"minikube 啟動 Ingress 由於 minikube 預設沒有啟動 Ingress 功能，因此需要額外使用 minikube addons enable ingress 讓 minikube 啟動 Ingress (Ingress 也需要先安裝 Hyperfix)： Ingress 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller\" Ingress 圖片來源：[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller ","date":"2022-05-03","objectID":"/k8s-advanced/:3:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"設定 /etc/hosts 加入 Ingress 基本上就需要網域才可以使用，但我們在本機上做練習，所以只要修改本機的 host 檔案就可以了(加入 minikube ip 以及想要的網域名稱)。 $ vim /etc/hosts 192.168.64.11 test.tw 192.168.64.11 test-test.tw 因為有兩種方法，第一種 (設定網域以及路徑)跟第二種 (只設定路徑沒有設定網域)，所以底下也會分成兩種來說明！ ","date":"2022-05-03","objectID":"/k8s-advanced/:3:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"設定網域以及路徑 Github 程式碼連結 apiVersion:networking.k8s.io/v1kind:Ingressmetadata:name:kubernetes-demo-ingressspec:rules:- host:\"test.tw\"http:paths:- path:/pathType:Prefixbackend:service:name:kubernetes-demo-serviceport:number:3000 ","date":"2022-05-03","objectID":"/k8s-advanced/:3:4","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"只設定路徑沒有設定網域 Github 程式碼連結 apiVersion:networking.k8s.io/v1kind:Ingressmetadata:name:kubernetes-demo-ingressspec:rules:- http:paths:- path:/pathType:Prefixbackend:service:name:kubernetes-demo-serviceport:number:3000 Ingress 整體寫法與 Service 差不多，只差在 spec 的細部設定，我們就來說一下 spec 設定吧： 對了～ Ingress 的 apiVersion 不像是 Pod 跟 Service 一樣使用 v1 ，因為目前支援 Ingress 的 API 只有 networking.k8s.io/v1，詳細可以參考 kubernetes Ingress 官網 rules 這代表這個 Ingress 的轉發規則，此 Ingress 所有的設定都必須寫載 rules 內。 host 設定可以連接到 Service 物件的網路名稱。 path 設定可以連接到 Service 物件的路徑名稱。 pathType 分為 Prefix 和 Exact 兩種，Prefix：前綴符合就符合規則 ; Exact：需要完全一致才行，包含大小寫。 type path request path macth Prefix / 全部路徑 Yes Exact /aa /aa Yes Exact /bb /cc No Prefix /aa /aa,/aa/ Yes Prefix /aa/cc /aa/ccc No service.name 設定連接到的 Service 名稱，這裡要填寫的就是 Service 中在 metadata 內寫的 name。 service.port.number 設定要經由哪個 port 連接到 Service 物件，就像是 Service 的 Port 要連接到 Pod 的 targetPort。 ","date":"2022-05-03","objectID":"/k8s-advanced/:3:5","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"建立 Ingress 一樣我們分成兩個做說明 設定網域以及路徑 一樣使用 apply 來建立： $ kubectl apply -f ingress.yaml ingress.networking.k8s.io/kubernetes-demo-ingress created 使用 kubectl get ing 來查詢 Ingress 狀況： $ kubectl get ing NAME CLASS HOSTS ADDRESS PORTS AGE kubernetes-demo-ingress nginx test.tw 192.168.64.11 80 10m 接下來我們分別測試寫在 /etc/host 裡面的兩個網域，使用瀏覽器搜尋 test.tw 跟 test-test.tw： test.tw 成功顯示柴犬\" 成功顯示柴犬 test-test.tw 顯示 404\" 顯示 404 從上面結果可以知道，因為我們有設定 domain，所以只有符合的才會連接到 Service 。 只設定路徑沒有設定網域 一樣使用 apply 來建立： $ kubectl apply -f ingress.yaml ingress.networking.k8s.io/kubernetes-demo-ingress created 使用 kubectl get ing 來查詢 Ingress 狀況： $ kubectl get ing NAME CLASS HOSTS ADDRESS PORTS AGE kubernetes-demo-ingress nginx * 192.168.64.11 80 5m56s 接下來我們分別測試寫在 /etc/host 裡面的兩個網域，使用瀏覽器搜尋 test.tw 跟 test-test.tw： test.tw 成功顯示柴犬\" 成功顯示柴犬 test-test.tw 顯示 404\" 顯示 404 從上面結果可以知道，可以發現 hosts 的部分是 * ，這代表所有背後指向 192.168.64.11 這個 IP 的網域都可以直接連接到 Service 物件。 ","date":"2022-05-03","objectID":"/k8s-advanced/:3:6","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Replication Controller ? 大家看到 Controller 就知道 Replication Controller 也是一種 Controller 負責控制 Replication，而 Replication 翻成中文是複製的意思，在 Kubernetes 中 Replication 代表同一種 Pod 的複製品。 這邊要帶給大家認識一個重要的設定：replica，replica 就是複製品的意思，透過這個設定我們就可以快速產生一樣內容的 Pod，舉例來說：今天設定了 replica: 3 就代表會產生兩個內容一樣的 Pod 出來。 Kubernetes StatefulSet 架構\" Kubernetes StatefulSet 架構 ","date":"2022-05-03","objectID":"/k8s-advanced/:4:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Replication Controller 用途 上面有提到 Replication Controller 可以利用設定 replica 的方式快速建立 Pod 數量，除了建立之外 Replication Controller 也確保 Pod 數量與我們設定的 replica 一致，假如今天不小心刪除其中一個 Pod，這時候 Replication Controller 會自動再產生一個新的 Pod 來補齊刪除的 Pod 空缺，所以我們可以善用 Replication Controller 來讓系統更佳穩定。 ","date":"2022-05-03","objectID":"/k8s-advanced/:4:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Replication Controller 寫法 我們來修改一下之前的 kubernetes-demo.yaml Pod 檔案：(Github 程式碼連結) apiVersion:v1kind:ReplicationControllermetadata:name:kubernetes-demospec:replicas:3selector:app:demotemplate:metadata:labels:app:demospec:containers:- name:kubernetes-demo-containerimage:880831ian/kubernetes-demoports:- containerPort:3000 這個設定檔看似複雜但其實很簡單，可以發現 template 區塊內的設定基本上就是 Pod 的設定，再加上一些屬於 Replication Controller 的設定。 由於我們要建立的是 Replication Controller，因此在一開始的 spec 要填的是 Replication Controller 的設定，所以 replica 會擺在第一個 spec 內。 可以再看到 selector，前面提到 Replication Controller 要控制的就是 Pod 的數量，所以這邊的 selector 就是要選取 Pod，就跟我們在 Service 要選取 Pod 的一樣。 最後一個新的設定：template，template 就是用來定義 Pod 的資訊，所以 Pod 的內容像是 metadata、spec 等等都會寫在 template 內，所以可以把 template 想像成不需要寫 apiVersion 跟 kind 的 Pod 壓模檔，有了這個觀念再來看 template 內的描述就很簡單，只是把 Pod 的內容複製過來而已，而 template 內的 spec 就是寫上 Pod 的 container 資訊。 ","date":"2022-05-03","objectID":"/k8s-advanced/:4:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Replication Controller 建立 老樣子，也是使用 apply 來建立壓模檔： $ kubectl apply -f kubernetes-demo.yaml replicationcontroller/kubernetes-demo created 來查看一下 Replication Controller 是否有成功建立起來，可以使用 kubectl get rc 來查詢： $ kubectl get rc NAME DESIRED CURRENT READY AGE kubernetes-demo 3 3 3 28s 接下來可以查看 Pod 是否有出現 3 個，所以使用 kubectl get po 來查詢： $ kubectl get po NAME READY STATUS RESTARTS AGE kubernetes-demo-4zkxm 1/1 Running 0 37s kubernetes-demo-cp8jt 1/1 Running 0 37s kubernetes-demo-pt9px 1/1 Running 0 37s 可以看到為了不要讓名稱重複，所以 Replication Controller 會在每一個 Pod 名稱後面加入亂數。 接下來我們用 minikube dashboard 來測試一下，是否刪除其中一個 Pod 後，Replication Controller 會自動建立新的： 刪除隨機一個 Pod\" 刪除隨機一個 Pod 當我們隨機刪除一個 Pod 時，被刪除的 Pod 會 Terminating 準備刪除，且啟動一個新的 Pod ContainerCreating： Pod 服務\" Pod 服務 當新的 Pod 啟動成功後，舊的 Pod 才會被刪除，所以可以確保我們的服務穩定度。 Pod 服務\" Pod 服務 綜上所述，可以知道 Replication Controller 真的會控制 Pod 數量，那我們刪掉一個 Pod 他就重生一個，這樣不會永遠都刪不完嗎？其實我們可以把 Replication Controller 砍掉就好了，而 Replication Controller 刪除時，也會自動終止底下的 Pod ，最後 Pod 都會自動刪除。 但其實 Kubernetes 官方不建議使用 Replication Controller 的方式來控制 Pod，而是建議使用 Deployment 搭配 ReplicaSet 來控制，我們接下來要介紹的主題就是：Deployment 跟 ReplicaSet 。 ","date":"2022-05-03","objectID":"/k8s-advanced/:4:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 ReplicaSet ? 看到 Replica 大家應該就知道這個跟控制 Pod 的數量有關係了！其實 Replica 跟 Replication Controller 很像，ReplcaSet 提供了更彈性的 selector，在 Replication Controller 中我們必須要把完整的 key/value Label 寫上去，在 ReplicaSet 不用這個麻煩，但 ReplicaSet 一樣也可以寫上完整的 Label ，這個就看開發者要怎麼去設計了！ ","date":"2022-05-03","objectID":"/k8s-advanced/:5:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"ReplcaSet 的特性 上面有提到 ReplcaSet 非常彈性的 selector，這邊要說的是 ReplcaSet 是如何讓 selector 變得更加彈性，這裡一共要介紹兩種 ReplcaSet 的 selector 寫法： matchLabels matchLabels 其實跟一般的 selector 做的事情一模一樣，也要寫出完整的 Label 出來，整體大概會長像這樣： selector:matchLabels:app:demo matchExpressions matchExpressions 則是提供更彈性的選取條件，每一筆條件主要由 key、operator、value 組成，並且使用一個 { } 包起來，看起來很像 JS 的 物件型態，整體大概會長像這樣： selector:matchExpression:- {key: app, operator: In, values:[demo, test]} 看起來似乎很複雜但其實很容易理解，上面的示範中 Expression 翻成中文就是只要 Label 的 key 是 app 且值符合 [demo, test] 陣列中的其中一個值的 Pod 就會被選取到。 我們在隨便取得例子：假設有一個 matchExpression 長得像這樣： selector:matchExpression:- {key: env, operator: NotIn, values:[hello, hi]} 我們可以得知要選取 Label 的 key 為 env 且值不能是 [hello, hi] 其中一個值的 Pod。 ","date":"2022-05-03","objectID":"/k8s-advanced/:5:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Deployment ? Deployment 是一種負責管理 ReplicaSet 以及控制 Pod 更新的物件，在先前的文章都沒有提到 Pod 的更新，是因為 Pod 無法直接做更新，必須砍掉重建才會是新的內容，有了 Deployment 之後我們就可以很方便的進行 Pod 的更新了！ 由於 ReplicaSet 本身也會控制 Pod，所以整個看起來會像是 Deployment 控制 Pod，但其實真正控制 Pod 的是 ReplicaSet ~ Deployment 與 ReplicaSet 架構圖\" Deployment 與 ReplicaSet 架構圖 ","date":"2022-05-03","objectID":"/k8s-advanced/:6:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Deployment 的特性 部署一個應用服務 上面我們提到 Deployment 可以幫助 Pod 進行更新，通常在開發一個產品的時候一定會不斷的更新，透過 Deployment 我們可以快速的更新 Pod 內部的 container，所以通常在部署應用的時候都會使用 Deployment 來進行部署。 在服務升級過程中可以達成無停機服務遷移 (Zero downtime deployment) 在 Deployment 幫 Pod 內部 container 進行更新的過程有一個專有名稱叫做 RollingUpdate ，RollingUpdate 翻成中文的意思是滾動更新，在更新的過程中 Deployment 會先產生一個新的 ReplicaSet 而這個 ReplicaSet 內部的 Pod 會運行新的內容，待新的 Pod 被 Kubernetes 確認可以正常運行後 Deployment 才會將舊的 ReplicaSet 進行取代的動作，這樣就完成了無停機服務遷移了。 可以 Rollback 到先前版本 每一次的 Deployment 在進行 RollingUpdate 的時候都會把當前的 ReplicaSet 做一個版本控制的紀錄，就像是 git commit 一樣，所以我們也可以利用這些紀錄來快速恢復成以前的版本，這些 Pod 也就會變成先前的內容。 講完基本的介紹後，接下來要介紹的是要如何撰寫以及建立一個 Deployment： ","date":"2022-05-03","objectID":"/k8s-advanced/:6:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Deployment 搭配 ReplicaSet 寫法 Github 程式碼連結 apiVersion:apps/v1kind:Deploymentmetadata:name:kubernetes-deploymentspec:replicas:3strategy:type:RollingUpdaterollingUpdate:maxSurge:1maxUnavailable:1minReadySeconds:60revisionHistoryLimit:10template:metadata:labels:app:demospec:containers:- name:kubernetes-demo-containerimage:880831ian/kubernetes-demoports:- containerPort:3000selector:matchLabels:app:demo 看到 Deployment 是不是覺得跟 Replication Controller 非常相似呢？其實 Deployment 就多了再 RollingUpdate 時的設定以及 ReplicaSet 的設定而已，下面來說明一下這些設定： 首先一開始的 apiVersion 的值已經不是 v1 了，改成 apps/v1，由於 Kubernetes 針對 Deployment、RollingUpdate、ReplicaSet 等等設定了新的 apiVersion 值，通常都用 apps/v1 都是用來設定跟應用程式有關的架設，所以 Deployment 這邊要記得改成 apps/v1 歐！ 在 spec 的地方有看到 strategy 新的設定值，這個主要用來設定 Deployment 更新的策略，這裡的 strategy.type 有兩種設定： RollingUpdate 此為預設值，先建立新的 ReplicaSet 並控制新內容的 Pod，待新 Pod 也可以正常運作後，才會通知 ReplicaSet 將原有的 Pod 給移除，由於過程中會有新舊兩種 Pod 同時上線，因此會有一段時間是新舊內容會隨機出現的情形發生。 這邊可以看到除了 type 以外還寫了 maxSurage 以及 maxUnavailablle，這兩個設定值為 RollingUpdate 過程的設定，接下來一樣說明一下兩個設定的功能： macSurge：代表 ReplicaSet 可以產生比 Deployment 設定中的 replica 所設定的數量還多幾個出來，多新增 Pod 的好處是在 RollingUpdate 過程中可以減少舊內容顯示在頁面的機率。 macUnavailable：代表在 RollingUpdate 過程中，可以允許多少的 Pod 無法使用，假設 macSurge 設定非 0，maxUnavailable 也要設定非 0。 Recreate 先通知當前 ReplicaSet 把舊的 Pod 砍掉再產生新的 ReplicaSet 並控制新內容的 Pod，由於先砍掉 Pod 才建立新的 Pod ，所以中間有一段時間伺服器會無法連線。 也因為 Recreate 會砍掉重建，因此 Recreate 無法像 RollingUpdate 設定 maxSurge 以及 macUnavailable。 講完 Deployment 的更新流程設定後，接下來要講 Deployment 完成更新後的設定，這邊有兩種設定： minReadySeconds minReadySeconds 代表當新的 Pod 建立好並且運行的 container 沒有 crash 的情況下，最少需要多少時間可以開始接受 Request，預設為 0 秒，代表當 Pod 一被建立起來，就可以馬上開始接受 Request，假設今天 container 在剛運行的時後需要花時間做初始化，這時候就可以利用 minReadySeconds 讓此 Pod 不會馬上接受到 Request ，這個是選填的設定。 revisionHistoryLimit 每次 Deployment 在進行更新的時候，都會產生一個新的 ReplicaSet 用來進行版本控制，在 Deployment 中這個專有名稱為 revision，所以這個設定就是要設定最多只會有多少個 revision，這個也是選填的設定。 ","date":"2022-05-03","objectID":"/k8s-advanced/:6:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Deployment 建立 老樣子，使用 apply 來建立 Deployment，我們可使用 kubectl get deploy 來查看是否建立成功： $ kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE kubernetes-deployment 3/3 3 3 8m31s 由於 Deployment 直接管理 ReplcaSet，因此我們可以查看 ReplcaSet 是否也有被建立起來： $ kubectl get rs NAME DESIRED CURRENT READY AGE kubernetes-deployment-dc5c59fdb 3 3 3 10m 可以看到 ReplcaSet 後面會自動加上一小段亂數，這邊是 Deployment 在建立 ReplicaSet 的時候加進去的，這樣之後可以更方便的利用 ReplcaSet 進行 rollback 的動作。 由於 ReplicaSet 會直接管理 Pod，因此我們也可以查看 Pod 是否有被建立起來： $ kubectl get po NAME READY STATUS RESTARTS AGE kubernetes-deployment-dc5c59fdb-cjbz6 1/1 Running 0 12m kubernetes-deployment-dc5c59fdb-mjvd7 1/1 Running 0 12m kubernetes-deployment-dc5c59fdb-r92zt 1/1 Running 0 11m 那我們用 minikube dashboard 來查看一下： minikube dashboard 查看 Deployment 與 ReplicaSet\" minikube dashboard 查看 Deployment 與 ReplicaSet Deployment 的最後要來說的是要如何更新底下的 Pod 呢，大家就接著往下看囉！ ","date":"2022-05-03","objectID":"/k8s-advanced/:6:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"如何更新 Deployment 內部的 Pod 大家都知道 Pod 是 Kubernetes 最小的運行單位，所以更新 Pod 的意思就是把內部運行的 container 進行更新，也就是說我們只要更新 Pod 的 image 就可以順利的讓 Pod 運行最新的內容，Deployment 就是運用這個原理才進行 Pod 的內容更新，方法也很簡單只要利用 Set 這個參數就可以了，可以使用 kubectl set -h 可以看 set 這個參數真正的用法。 kubectl set\" kubectl set 可以看到 set 後面還要接 SUBCOMMAND，而 SUBCOMMAND 就是 Available Commands 的內容，由於我們要更新的是 image 所以這邊的 SUBCOMMAND 會是 image，完整指令是： $ kubectl set image deployment/kubernetes-deployment kubernetes-demo-container=880831ian/kubernetes-demo:v1 --record deployment.apps/kubernetes-deployment image updated 使用 set 來更新 Pod，格式是 kubectl set image deployment/\u003cdeployment name\u003e \u003cpod name\u003e=\u003c要更新的 image\u003e，後面加上 --record 參數，這樣會紀錄每次更新的時候到底更新哪些內容，這樣日後要進行 rollback 也會比較容易知道要 rollback 回哪個 revision，由於要顯示差異，所以在 dockerhub 上又多推一個版本 v1，將原本柴犬的圖片改成 kubernetes logo，等於我們更新是從 kubernetes-demo:latest 更新至 kubernetes-demo:v1，我們來看看它的變化吧！ 這是還沒更新 Pod 前的 Deployment 與 ReplicaSet： Deployment 與 ReplicaSet\" Deployment 與 ReplicaSet 我們用 set 下完更新指令後，可以查看 ReplicaSet 以及 Pod 在更新過程中的變化： ReplicaSet 以及 Pod 在更新過程中的變化\" ReplicaSet 以及 Pod 在更新過程中的變化 可以發現 strategy 為 RollingUpdate 的時候並不會把舊有的 Pod 移除反而會讓新舊 Pod 同時上線，以達到無停機服務的作用，但這樣在網頁中就有可能會同時出現新舊內容。 因為 strategy 為 RollingUpdate，所以會同時出現新舊內容\" 因為 strategy 為 RollingUpdate，所以會同時出現新舊內容 最後等到新的 Pod 已經建立完成，且正常運作，ReplicaSet 就會把舊的 Pod 給移掉： 新的 Pod 建立成功，並刪除舊 Pod\" 新的 Pod 建立成功，並刪除舊 Pod 再次瀏覽就可以發現已經變成新的內容了！代表我們完成更新動作～ 更新至 kubernetes-demo:v1\" 更新至 kubernetes-demo:v1 ","date":"2022-05-03","objectID":"/k8s-advanced/:6:4","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Deployment 回朔版本 我們講完更新後，接著要講如何 rollback 回以前的版本，首先我們必須使用 rollout 這個參數，一樣使用 kubectl rollout -h 可以查看 rollout 的用法，跟 set 十分相似。 更新至 kubernetes-demo:v1\" 更新至 kubernetes-demo:v1 由於我們這邊要 rollback ，所以 SUBCOMMAND 會使用 undo，我們上面有用 --record 可以查看要 rollback 的版本，所以我們這邊寫法會長像這樣： $ kubectl rollout undo deployment/kubernetes-deployment --to-revision=1 deployment.apps/kubernetes-deployment rolled back 格式是 kubectl rollout undo deployment/\u003cdeployment name\u003e --to-revision=\u003c--record 版本\u003e 就可以看到又回復成以前的柴犬囉 \u003e\u003c 成功還原柴犬\" 成功還原柴犬 ","date":"2022-05-03","objectID":"/k8s-advanced/:6:5","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"為甚麼不用 Replication Controller 最後要討論的是為什麼要不用 Replication Controller 而是改用 ReplicaSet + Deployment？ 由於實際再使用 Kubernetes 時架構會比現在練習的還要複雜，所以用 ReplicaSet 讓 selector 用更彈性的方式選取 Pod 會是比較好的做法。 ","date":"2022-05-03","objectID":"/k8s-advanced/:6:6","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Stateless 和 Stateful ","date":"2022-05-03","objectID":"/k8s-advanced/:7:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Stateless Stateless 顧名思義就是無狀態，我們可以想成我們每次與伺服器要資料的過程中都不會被伺服器記錄狀態，每一次的 Request 都是獨立的，彼此是沒有關聯性的，也就是我們當下獲得的資料只能當下使用沒有辦法保存，靜態網頁通常都是一種 Stateless 的應用。 舉個例子來說：今天我想要查詢火車時刻表，我可以藉由 Google 搜尋火車時刻表，並點選連結，或是直接在瀏覽器輸入 https://tip.railway.gov.tw/ ，這兩種結果最後都會一致，並不會因為我的操作不同而產生不同結果，這就是一種 Stateless 的表現。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Stateful Stateful 就是 Stateless 的相反，也就是每次的 Request 都會被記錄下來，日後都可以進行存取，Stateful 最常見的例子是資料庫，所以我們可以理解成 Stateful 背後一定會有一個負責更新內容的儲存空間。 幾個例子來說：今天我們想要查看 Google 雲端硬碟的內容，我們必須先登入自己的帳號才可以查看內容，這種有操作先後順序才會有結果的就是一種 Stateful 的表現。 Stateless vs Stateful\" Stateless vs Stateful 那為什麼要提到 Stateless 跟 Stateful 呢？ 因為跟 Pod 有很大的關係，在 Kubernetes 中 Pod 就屬於 Stateless 的，我們前面有提到 Stateless 的特性就是每次的 Request 都是獨立的，這樣有一個好處是可以快速的擴充。 在 Kubernetes - 基本篇中的 Pod 有提到：Pod 是 Kubernetes 中最小的單位，由於 Pod 是屬於 Stateless 的，即便今天同一種內容的 Pod 有很多個也沒有關係，因為每次的 Request 都是獨立的，多個 Pod 就多個連線的端點而已。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Kubernetes 的 Stateful 上面有說到 Kubernetes 的 Pod 是 Stateless 的，那難道 Kubernetes 沒有辦法做 Stateful 應用嗎？其實是可以的，Kubernetes 為了 Stateful 有特別開啟一個類別叫：StatefulSet 這邊會簡單說明一下 StatefulSet 的架構： ","date":"2022-05-03","objectID":"/k8s-advanced/:7:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"StatefulSet StatefulSet 一共有兩個重要的部分： Persistent Volume Claim 前面有說到 Stateful 背後有一個更新內容的儲存空間，在 Kubernetes 中負責管理儲存的空間是 Volume，作用與 Docker 的 Volume 幾乎一模一樣，但 Kuberntes 的 Volume 只是在 Pod 中暫時存放的儲存空間，當 Pod 移除之後這個儲存空間就會消失，為了要在 Kubernetes 中建立一個像是資料庫可以永久儲存的空間，這個 Volume 不能被包含在 Pod 中，而這個就是 Persistent Volume (PV)。 Persistent Volume Claim (PVC) 就是負責連接 Persistent Volume (PV) 的物件，所以可以想像一下今天有多少的 Persistent Volume 就會有多少的 Persistent Volume Claim。 Headless Service 還記得在 Service 有提到 ClusterIP 嗎？其實每個 Service 都會有自己一組的 ClusterIP (ExternalName 形式的除外)，所以 Headless 的意思其實就是不要有 ClusterIP，方法也很簡單，直接在設定檔中加入 ClusterIP: None 就可以了！ 這麼做有什麼好處？由於 Headless Service 並沒有直接跟 Pod 有對應關係，因此 Service 本身沒有 ClusterIP，所以 Kubernetes 內部在溝通時就沒有辦法把我們設定好的 Service 名稱進行 IP 轉換，不過 Headless Service 會將內部的 Pod 的都建立屬於自己的 domain，所以我們可以自由的選擇要連接到哪一個 Pod。 這時候你會說可以用手動來連接呀？但因為 Service 一般是跟著 Pod 的 Label ，所以一個 Service 都會連接許多個 Pod，這樣我們就沒有辦法針對某個 Pod 來做事情，所以 Headless Service 在 Stateful 中也會被建立。 我們一直強調說 Kubernetes 最小的單位是 Pod，即便是 StatefulSet 也會有 Pod，只是這個 Pod 會歸 StatefulSet 管理，綜合上面所述可以知道一個 StatefulSet 裡面除了執行的 Pod 外還會有負責跟 Persistent Volume 連接的 Persistent Volume Claim，整體的 StatefulSet 架構會長得像這樣： Kubernetes StatefulSet 架構\" Kubernetes StatefulSet 架構 基本上 StatefulSet 中在 Pod 的管理上都是與 Deployment 相同，基於相同的 container spec 來進行; 而其中的差別在於 StatefulSet controller 會為每一個 Pod 產生一個固定識別資訊，不會因為 Pod 改變後而有所變動。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:4","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼時候需要使用 StatefulSet ? 如何研判哪些 Application 需要使用 StatefulSet 來部署？只要符合以下條件，就需要使用 StatefulSet 來進行部署 需要穩定 \u0026 唯一的網路識別 (pod 改變後的 pod name \u0026 hostname 都不會變動) 需要穩定的 Persistent storage (pod 改變後還是能存取相同的資料，基本上用 PVC 就可以解決) 部署 \u0026 擴展的時候，每個 Pod 的產生都是有其順序且逐一慢慢完成的 進行更新操作時，也是與上面的需求相同 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:5","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"StatefulSet 有什麼限制？ v1.5 以前版本不支援，v1.5 ~ v1.9 之間是 beta，v1.9 後正式支援 storage 的部分一定要綁定 PVC，並綁定到特定的 StorageClass or 預先配置好的 Persistent Volume，確保 Pod 被刪除後資料依然存在。 需要額外定義一個 Headless Service 與 StatefulSet 搭配，確保 Pod 有固定的 network identity。 network identity 代表可以直接透過 domain name 直接取的 Pod IP; 實現的方法則是部署一個 ClusterIP=None 的 Service，讓 Cluster 內部存取 Service 時，可以直接連到 Pod 而不是 Service IP。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:6","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"StatefulSet 寫法 要寫一個 StatefulSet ，有幾個重要的部分必須涵蓋： Application \u0026 Persistent Volume Claim Headless Service .spec.selector 所定義的內容 (matchLabels) 必須與 .spec.template.metadata.labels 相同。 其他部分都與 Deployment 幾乎相同 ~ 我們先來看看要怎麼定義 Application \u0026 Persistent Volume Claim (把 Service 跟 StatefulSet 寫在一起) (Github 程式碼連結) apiVersion:v1kind:Servicemetadata:name:nginxlabels:app:nginxspec:ports:- port:80name:webclusterIP:Noneselector:app:nginx---apiVersion:apps/v1kind:StatefulSetmetadata:name:webspec:serviceName:\"nginx\"replicas:2selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:k8s.gcr.io/nginx-slim:0.8ports:- containerPort:80name:webvolumeMounts:- name:wwwmountPath:/usr/share/nginx/htmlvolumeClaimTemplates:- metadata:name:wwwspec:accessModes:[\"ReadWriteOnce\"]resources:requests:storage:1Gi 我們先打開一個 Terminal 來觀察 StatefulSet 創建 Pod 的過程： $ kubectl get pods -w -l app=nginx 我們一樣使用 kubectl apply 來創建定義在 web.yaml 中的 Headless Service 和 StatefulSet。 $ kubectl apply -f web.yaml 我們看一下剛剛的 StatefulSet 創建 Pod 的過程，可以發現我們擁有 N 的副本的 StatefulSet ， Pod 部署時會按照 {0 …. N-1} 的序號依序創建。 NAME READY STATUS RESTARTS AGE web-0 0/1 Pending 0 0s web-0 0/1 Pending 0 0s web-0 0/1 ContainerCreating 0 0s web-0 1/1 Running 0 2s web-1 0/1 Pending 0 0s web-1 0/1 Pending 0 0s web-1 0/1 ContainerCreating 0 0s web-1 1/1 Running 0 3s 可以發現 web-1 Pod 是在 web-0 Pod 處在 Running 狀態才會被啟動。此外，可以發現就跟我們上面講的一樣，StatefulSet 中的 Pod 擁有一個獨一無二的身份標記，基於 StatefulSet 控制器分配給每個 Pod 的唯一順序索引。 Pod 名稱的格式是 \u003c statefulset name \u003e-\u003c ordinal index \u003e，像我們 web 這個 StatefulSet 有兩個副本，所以它創建了兩個 Pod：web-0、web-1。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:7","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"StatefulSet 測試 我們知道 StatefulSet 它有使用穩定的網路身份以及 PV 的永久儲存，那我們就分別來測試看看： StatefulSet 穩定的網路身份 我們先使用 kubectl exec 在每個 Pod 中執行 hostname $ for i in 0 1; do kubectl exec \"web-$i\" -- sh -c 'hostname'; done web-0 web-1 再使用 kubectl run 來運行一個提供 nslookup 命令的容器，通過對 Pod 的主機名執行 nslookup，我們可以檢查他在集群內部的 DNS 位置。 $ kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm /bin/sh 啟動一個新的 shell ，並運行 nslookup web-0.nginx 跟 nslookup web-1.nginx： / # nslookup web-0.nginx Server: 10.96.0.10 Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local Name: web-0.nginx Address 1: 172.17.0.5 web-0.nginx.default.svc.cluster.local / # nslookup web-1.nginx Server: 10.96.0.10 Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local Name: web-1.nginx Address 1: 172.17.0.6 web-1.nginx.default.svc.cluster.local 可以看到 Headless Service 的 CHANCE 指向 SRV 記錄 (記錄每個 Running 的 Pod)。SRV 紀錄指向一個包含 Pod IP 位址的記錄表。 我們使用 kubectl delete pod -l app=nginx 刪除 Pod 後，會發現 Pod 的序號、主機名、SRV 條目和記錄名稱都沒有改變！ StatefulSet 永久儲存 我們先查看 web-0 跟 web-1 的 PersistentVolumeClaims： $ kubectl get pvc -l app=nginx NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE www-web-0 Bound pvc-e9a23104-d018-4d73-8cd9-89e5ea67f96c 1Gi RWO standard 39m www-web-1 Bound pvc-00dd6c87-6d95-4d04-9c1b-49b43441f4a1 1Gi RWO standard 38m StatefulSet 控制器創建兩個 PersistentVolumeClaims，綁定兩個 PersistentVolumes，因為我們配置是動態提供PersistentVolume，所有的PersistentVolume 都是自動創建和綁定的。 Nginx web 服務器默認會加載位於 /usr/share/nginx/html/index.html 的 index 文件。因此我們在 spec 中的 volumeMounts 將 /usr/share/nginx/html 資料夾由一個 PersistentVolume 支持。 那我們將 Pod 主機名稱寫入 index.html ，再刪掉 Pod 看看寫入內容是否還會存在： $ for i in 0 1; do kubectl exec \"web-$i\" -- sh -c 'echo \"$(hostname)\" \u003e /usr/share/nginx/html/index.html'; done $ for i in 0 1; do kubectl exec -i -t \"web-$i\" -- curl http://localhost/; done web-0 web-1 當我們刪除 Pod 後，如果沒有使用 PersistentVolumeClaims 去綁定 PersistentVolumes 的話，資料就會消失，那我們來看看有綁定的結果： 使用 kubectl delete pod -l app=nginx 刪除 Pod： pod \"web-0\" deleted pod \"web-1\" deleted 再次使用 kubectl get pod -w -l app=nginx 來檢查 Pod 的狀態： web-0 0/1 ContainerCreating 0 0s web-0 1/1 Running 0 2s web-1 0/1 Pending 0 0s web-1 0/1 Pending 0 0s web-1 0/1 ContainerCreating 0 0s web-1 1/1 Running 0 1s 一樣使用 for i in 0 1; do kubectl exec -i -t \"web-$i\" -- curl http://localhost/; done 來查看： web-0 web-1 可以發現 web-0、web-1 雖然重新啟動，但依舊會監聽它們主機名，因為和它們的 PersistentVolumeClaim 相關聯的 PersistentVolume 被重新掛載到了各自的 volumeMount 上。 ","date":"2022-05-03","objectID":"/k8s-advanced/:7:8","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 ConfigMap ? 看到 Config 應該會聯想到與設定檔有關，沒錯 ConfigMap 通常都是用來存放設定檔用的，換句話來說這個物件會直接連結一個或多個檔案，而 ConfigMap 通常都是用來存放偏向部署面的設定檔，像是資料庫的初始化設定、nginx 設定檔等等，這種不用被包進去 image 內，但需要讓 container 可以使用的檔案。 ","date":"2022-05-03","objectID":"/k8s-advanced/:8:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"ConfigMap 特性 一個 ConfigMap 物件可以放一個或多個設定檔：我們上面有提到它是用來存放設定檔用的，會直接連接該設定檔。 無需修改程式碼，可以替換不同環境的設定檔：由於設定檔都交由 ConfigMap 管理，並不是包在 image 內，因此可以藉由修改 ConfigMap 的方式來達到不用更新 Pod 內容就可以更換設定檔的作用。 統一存放所有的設定檔：一個 ConfigMap 可以連結一個以上的設定檔，因此也可以將該專案會用到的所有設定檔通通存放在同一個 ConfigMap 物件中進行管理。 ","date":"2022-05-03","objectID":"/k8s-advanced/:8:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"如何建立 ConfigMap？ 由於 ConfigMap 可以直接存入設定檔，所以我們以現有設定檔為基準，接下來要用 create 這個參數來建立 ConfipMap 物件出來，這時可能會想，之前都是使用 apply 怎麼這次要改用 create呢！？ 雖然兩者都有建立的意思，但背後實作的技術完全不同： create 使用的是 Imperative Management，Imperative Management 會告訴 Kubernetes 我目前的動作要做什麼，例如：create、delete、replace 某個物件。 apply 是使用 Declarative Management，Declarative Management 是用宣告的方式來建立物件，更白話一點就是我希望這個物件要長怎麼樣，所以 apply 通常都會搭配 yaml 檔，而這份 yaml 檔就會在 kind 這個設定值告訴 Kubernetes 這個物件要長成什麼樣子。 因為我們這次要直接使用現有的設定檔來建立 ConfigMap，所以這時候不能使用 apply 的方式，只能使用 create 來建立，指令也很簡單： $ kubectl create configmap \u003cconfigmapName\u003e --from-file=\u003cfilePath\u003e 建立 ConfigMap\" 建立 ConfigMap 建立完成使用 get 來查詢是否正確建立 ConfigMap： 使用 get 查詢是否正確 ConfigMap\" 使用 get 查詢是否正確 ConfigMap 最後可以下 describe 這個參數來查看 ConfigMap 的內容，會發現裡面就是我們設定檔的完整內容： 使用 describe 查看 ConfigMap 的內容\" 使用 describe 查看 ConfigMap 的內容 ","date":"2022-05-03","objectID":"/k8s-advanced/:8:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"什麼是 Secrets ? 看到 Secrets 這個名字就知道這是非常機密的物件，相較於 ConfigMap 是用來存放部署面的檔案，Secrets 通常都是用來存機密的資料，像是使用者帳號、SSL 憑證等。 ","date":"2022-05-03","objectID":"/k8s-advanced/:9:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"Secrets 特性 上面 ConfigMap 提到的特性 Secrets 一樣，比較特別的是 Secrets 會將內部的資料進行 base64 編碼。因為重新編碼所以可以確保資料相較於 ConfigMap 下安全一些，所以建議如果是機密性的資料就存在 Secrets 裡面吧！ ","date":"2022-05-03","objectID":"/k8s-advanced/:9:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"如何建立 Secrets？ 我們一樣用現有的檔案來做基準作為示範，由於上面 ConfigMap 只存入一個檔案而已，所以這邊 Secrets 我們改成存入多個檔案： 一樣用 create 的參數進行 Secrets 建立，但這邊要多加一個 SUBCOMMAND 叫 generic，generic 代表意思是從本機檔案、目錄建立 Secrets，接下來只要下： kubectl create secret generic \u003csecretName\u003e --from-file=\u003cfilePath\u003e 建立 Secrets\" 建立 Secrets 建立完成使用 get 來查詢是否正確建立 Secrets： 使用 get 查詢是否正確 Secrets\" 使用 get 查詢是否正確 Secrets 最後一樣可以下 describe 這個參數來查看 Secrets 的內容，但因為加密所以不會顯示原本內容，只會看到的確有兩個檔案： 使用 describe 查看 Secrets 的內容\" 使用 describe 查看 Secrets 的內容 ","date":"2022-05-03","objectID":"/k8s-advanced/:9:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"參考資料 Kubernetes 那些事 — Service 篇 Kubernetes 那些事 — Ingress 篇（一） Kubernetes 那些事 — Ingress 篇（二） Kubernetes 那些事 — Stateless 與Stateful kubernetes ReplicationController Kubernetes 那些事 — Replication Controller Kubernetes 那些事 — Deployment 與 ReplicaSet（一） Kubernetes 那些事 — Deployment 與 ReplicaSet（二） Kubernetes 那些事 — Deployment 與 ReplicaSet（三） kubernetes Deployments [Kubernetes] StatefulSet Overview ","date":"2022-05-03","objectID":"/k8s-advanced/:10:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 進階 (Service、Ingress、StatefulSet、Deployment、ReplicaSet、ConfigMap)","uri":"/k8s-advanced/"},{"categories":["codenotes"],"content":"此文章是介紹 Kubernetes 以及如何建立第一個 Pod，文章內容大多參考其他網路大神，並加入自己了解的思路與語氣，文章純屬個人筆記性質，無營利之用途，參考資料也附在文章最後，有興趣的朋友也可以先去了解看看歐 😎","date":"2022-04-28","objectID":"/k8s/","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"什麼是 Kubernetes (K8s)? Kubernetes 也可以叫 K8s，這個名稱來源希臘語，意思是舵手或是飛行員，所以我們可以看到它的 logo 是一個船舵的標誌，之所以叫 K8s 是因為 Kubernetes 的 k 到 s 中間有 8 的英文字母，為了方便，大家常以這個名稱來稱呼他！ kubernetes logo\" kubernetes logo Kubernetes 是一種開源可用來自動化部屬、擴展以及管理多個容器的系統，適用於當容器數量增加，需要穩定容器環境，以及管理資源或權限分配的狀況。 我們之前在 Docker 介紹 文章中，已經有介紹以往傳統虛擬機以及容器化的 Docker 差異以及優點，那當我們在管理容器時，其中一個容器出現故障，則需要啟動另一個容器，如果要用手動，會十分麻煩，所以這時就是 Kubernetes 的厲害的地方了，Kubernetes 提供： 服務發現和負載平衡：K8s 可以使用 DNS 名稱或是自己的 IP 位址來公開容器。如果容器流量過高，Kubernetes 能夠使用負載平衡和分配網路流量，能使部署更穩定。 編排儲存：Kubernetes 允許使用自動掛載來選擇儲存系統，例如使用本地儲存，或是公共雲等。 自動部署、刪除：可以使用 Kubernetes 來幫我們自動化部屬新的容器、刪除現有的容器並將其資源用於新容器。 自動打包：當我們為 Kubernetes 提供一個節點叢集，它可以用來運行容器化的任務，告訴 Kubernetes 每個容器需要多少 CPU 和 RAM。Kubernetes 可以將容器安裝到節點上，充分利用資源。 自動修復：Kubernetes 會重新啟動失敗的容器、替換容器、刪除不回應用戶的不健康容器，並且在容器準備好服務之前不會通知客戶端。 機密和配置管理：Kubernetes 允許儲存和管理敏感訊息，例如密碼、OAuth token 和 SSH 金鑰。可以部署和更新機密的應用程序配置。 kubernetes 官網\" kubernetes 官網 Kubernetes 很常被拿來與 Docker Swarm 做比較，兩者不同的是，Docker Swarm 必須建構在 Docker 的架構下，功能侷限、無法跳脫。 Kubernetes 則因為功能較為廣泛，而逐漸取代 Docker Swarm 在市場上的地位。下方有簡易的比較表格： 比較 Kubernetes Docker Swarm 說明 Kubernetes 是一個開源容器的編排平台，Kubernetes 的叢集結構比 Docker Swarm 更為複雜。 Kubernetes 通常有建構器和工作節點，還可進一步分為 Pod、命名空間、配置映射等。 Docker Swarm 是一個由 Docker 構建和維護的開源容器編排平台。 一個 Docker Swarm 叢集通常包含三個項目：Nodes、Services and tasks、Load balancers。 優點 它有龐大的開源社群，由 Google 支持。 它可以維持和管理大型架構和複雜的工作負載。 它是自動化，並支持自動化擴展的自我修護能力。 它有內建監控和廣泛的可用集成。 Docker Swarm 安裝簡單，它輕量化且容易學習使用。 Docker Swarm 與 Docker CLI 一起運作，因此不需要多運行或是安裝新的 CLI 缺點 它複雜的安裝過程以及較難學習 它需要安裝單獨的 CLI 工具並且學習每一項功能 它是輕量級且與 Docker API 相關聯，與 Kubernetes 相比，Docker Swarm 被限制很多功能，且自動化也沒有 Kubernetes 強大。 ","date":"2022-04-28","objectID":"/k8s/:1:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Kubernetes 元件介紹與說明 Kubernetes 是如何幫我們管理以及部署 Container ? 要了解 Kubernetes 如何運作，就要先了解它的元件以及架構： 那我們由小的往大的來做介紹：依序是 Pod、Worker Node、Master Node、Cluster ","date":"2022-04-28","objectID":"/k8s/:2:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Pod Kubernetes 運作中最小的單位，一個 Pod 會對應到一個應用服務 (Application)，舉例來說一個 Pod 可能會對應到一個 NginxServer。 每個 Pod 都有一個定義文件，也就是屬於這個 Pod 的 yaml 檔。 一個 Pod 裡面可以有一個或多個 Container，但一般情況一個 Pod 最好只有一個 Container。 同一個 Pod 中的 Containers 共享相同的資源以及網路，彼此透過 local port number 溝通。 ","date":"2022-04-28","objectID":"/k8s/:2:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Worker Node Kubernetes 運作的最小硬體單位，一個 Worker Node (簡稱 Node) 對應到一台機器，可以是實體例如你的筆電、或是虛擬機例如 GCP 上的一台 Computer Engine。 每一個 Node 都有三個組件所組成：kubelet、kube-proxy、Container Runtime kubelet 該 Node 的管理員，負責管理該 Node 上的所有 Pods 的狀態並負責與 Master Node 溝通。 kube-proxy 該 Node 的傳訊員，負責更新 Node 的 iptables，讓 Kubernetes 中不在該 Node 的其他物件可以得知該 Node 上的所有 Pods 的最新狀態。 Container Runtime 該 Node 真正負責容器執行的程式，K8s 預設是 Docker，但也支援其他 Runtime Engine，例如 Mirantis Container Runtime、CRI-O、containerd 常見誤解 很多人認為 Kubernetes 是 docker container 的管理工具，包含我一開始也是這樣認為，但其實 Kubernetes 是用來管理容器化 (containerized applications) 並不是專屬於 docker 獨享，作為一個 container orchestrator 的角色，Kubernetes 希望能夠管理所有容器化的應用程式 ","date":"2022-04-28","objectID":"/k8s/:2:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Master Node Kubernetes 運作的指揮中心，可以簡化看成一個特殊化的 Node 來負責管理所有其他的 Node。 一個 Master Node (簡稱 Master) 中有四個組件組成：kube-apiserver、etcd、kube-scheduler、kube-controller-manager kube-apiserver 管理整個 Kubernetes 所需 API 的接口 (Endpoint)，例如從 Command Line 下 kubectl 指令就會把指令送到這裡。 負責 Node 之間的構通橋樑，每個 Node 彼此不能直接溝通，必須要透過 apiserver 轉介。 負責 Kubernetes 中的請求的身份認證與授權。 etcd etcd 是兼具一制性和高可用性的分散式鍵值數據庫，可以保存 Kubernetes 所有 Cluster 的後台數據庫。 kube-scheduler 整個 Kubernetes 的 Pods 調度員，scheduler 會監視新建立但還沒有被指定要跑在哪個 Node 上的 Pod ，並根據每個 Node 上面資源規定，硬體限制等條件去協調出一個最適合放置 Node 來讓該 Pod 運行。 kube-controller-manager 負責管理並運行 Kubernetes controller 的組件，簡單來說 controller 就是 Kubernetes 裡一個負責監視 Cluster 狀態的 Process，例如：Node Controller、Replication Controller。 這些 Process 會在 Cluster 與預期狀態 (desire state) 不符時嘗試更新現有狀態 (current state)。例如：現在要多開一台機器以應付突然增加的流量，那我的預期狀態就會更新成 N+1，現有狀態是 N，這時相對應的 controller 就會想辦法多開一台機器。 controller-manager 的監視與嘗試更新也都需要透過訪問 kube-apiserver 達成。 ","date":"2022-04-28","objectID":"/k8s/:2:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Cluster Cluster 也叫叢集，可以管理眾多機器的存在，在一般的系統架設中我們不會只有一台機器而已，通常都是多個機器一起運行同一種內容，在沒有 Kubernetes 的時候就必須要土法煉鋼的一台一台機器去更新，但有了 Kubernetes 我們就可以透過 Cluster 進行控管，只要更新 Master 旗下的機器，也會一併將更新的內容放上去，十分方便。在 Kubernetes 中多個 Worker Node 與 Master Node 的集合。 ","date":"2022-04-28","objectID":"/k8s/:2:4","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"基本運作 kubernetes 組件 Kubernetes 基礎教學（一）原理介紹\" kubernetes 組件 Kubernetes 基礎教學（一）原理介紹 接下來我們用 「Kuberntes 是如何建立一個 Pod ？」來複習一下整個 Kubernetes 的架構。 (上圖是一個簡易的 Kubernetes Cluster ，通常 Cluster 為了高穩定性都會有多個 Master 作為備援，但為了簡化我們只顯示一個。) 當使用者要部署一個新的 Pod 到 Kubernetes Cluster 時，使用者要先透過 User Command (kubectl) 輸入建立 Pod 對應的指令 (後面會說明要如何實際的動手建立一個 Pod)。此時指令會經過一層確認使用者身份後，傳遞到 Master Node 中的 API Server，API Server 會把指令備份到 etcd。 controller-manager 會從 API Server 收到需要創建一個新的 Pod 的訊息，並檢查如果資源許可，就會建立一個新的 Pod。最後 Scheduler 在定期訪問 API Server 時，會詢問 controller-manager 是否有建置新的 Pod，如果發現新建立的 Pod 時，Scheduler 就會負責把 Pod 配送到最適合的 Node 上面。 雖然上面基本的運作看起來十分複雜，但其實我們在實際操作時，只是需入一行指令後，剩下的都是 Kubernetes 會自動幫我們完成後續的動作。 ","date":"2022-04-28","objectID":"/k8s/:3:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"安裝 Kubernetes 在我們開始操作 Kubernetes 之前，需要先下載 Minikube、Hyperkit、Kubectl 套件： Minikube 一個 Google 發佈的輕量級工具，讓開發者可以輕鬆體驗一個 Kubernetes Cluster。(僅限開發測試環境) 安裝 minikube\" 安裝 minikube (Mac專用) Hyperkit Hyperkit 是 MacOS 系統細部設定的驅動程式。 安裝 Hyperkit\" 安裝 Hyperkit Kubectl Kubectl 是 Kubernetes 的 Command Line 工具，我們之後會透過 Kubectl 去操作我們的 Kubernetes Cluster。 安裝 kubectl\" 安裝 kubectl ","date":"2022-04-28","objectID":"/k8s/:4:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"如何建立一個 Pod 版本資訊 Minikube：v1.25.2 hyperkit：0.20200908 Kubectl：Client Version：v1.22.5、Server Version：v1.23.3 下載完 Minikube 後，我們可以先透過 Minikube 來查詢全部的指令，由於我們前面有安裝 Hyperkit 這個驅動程式，啟動 Minikube 預設是使用 Docker，我們這邊要利用 Hyperkit 來啟動，所以使用 Minikube start --vm-driver=hyperkit 來啟動 Minikube。 Minikube 其他指令介紹 顯示 minikube 狀態 minikube status 停止 minikube 運行 minikube stop ssh 進入 minikube 中 minikube ssh 查詢 minikube 對外的 ip minikube ip 使用 minikube 所提供的瀏覽器 GUI minikube dashboard (可以加 - - url 看網址歐) 我們啟動 minikube 後，我們要打做一個可以在 Pod 運行的小程式。這個小程式是一個 Node.js 的 Web 程式，他會建立一個 Server 來監聽 3000 Port，收到 request 進來後會渲染 index.html 這個檔案，這個檔案裡面會有一隻可愛的小柴犬。 因為本文章是在介紹 kubernetes 所以在程式部分就不多做說明，我把程式碼放在 Github，以及附上 Dockerhub 的 Repository 可以直接使用包好的 image 來做測試！ ","date":"2022-04-28","objectID":"/k8s/:5:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"Pod yaml 檔案說明 接下來我們要先撰寫一個 Pod 的定義文件 (.yaml) 檔，這個 .yaml 檔就可以建立出 Pod 了！ kubernetes-demo.yaml (程式縮排要正確，不然會無法執行歐！) apiVersion:v1kind:Podmetadata:name:kubernetes-demo-podlabels:app:demospec:containers:- name:kubernetes-demo-containerimage:880831ian/kubernetes-demoports:- containerPort:3000 apiVersion 該元件的版本號，必須依照 Server 上 K8s 版本來做設定 (想要知道k8s 版本，可以使用 kubectl version 指令來查詢，會顯示 client 跟 server 的版本訊息，client 代表 kubectl 版本訊息，server 代表的是 master node 的 k8s 版本訊息)，目前 k8s 都使用 1.23 版本以上，所以 apiVersion 直接寫 v1 即可。 kind 該元件的屬性，用來決定此設定檔的類型，常見的有 Pod、Node、Service、Namespace、ReplicationController 等等 metadata 用來擺放描述性資料的地方，像是 Pod 名稱或是標籤等等都會放在此處。 name：指定該 Pod 的名稱 labels：指定該 Pod 的標籤 spec 用來描述物件生成的細節，像是 Pod 內其實是跑 Dokcer container，所以在 Pod 的 spec 內就會描述 container 的細節。 container.name：指定運行的 Container 的名稱 container.image：指定 Container 要使用哪個 Image，這裡會從 DockerHub 上搜尋 container.ports：指定該 Container 有哪些 Port number 是允許外部存取的 ","date":"2022-04-28","objectID":"/k8s/:5:1","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"使用 kubectl 建立 Pod 當我們有了定義文件後，我們就可以使用 kubectl 的指令來建立 Pod kubectl create -f kubernetes-demo.yaml kubectl apply -f kubernetes-demo.yaml 可以使用 create or apply 來建立 Pod ，那這兩個的差異是什麼呢？ kubectl create kubectl create 是所謂的 “命令式管理” (Imperative Management)。通過這種方式，可以告訴 Kubernets API 你要建立、更新、刪除的內容。 kubectl create 命令是先刪除所有現有的東西，重新根據 YAML 文件生成新的 Pod。所以要求 YAML 文件中的配置必須完整。 kubectl create 命令，使用同一個 YAML 文件重複建立會失敗。 kubectl apply kubectl apply 是 “聲明式管理” (Declarative Management)方法的一部分。在該方法中，即使對目標用了其他更新，也可以保持你對目標應用的更新。 kubectl apply 命令，根據配置文件裡面出來的內容，生成就有的。所以 YAML 文件的內容可以只寫需要升級的欄位。 如果看到 pod/kubernetes-demo-pod created 就代表我們成功建立第一個 Pod 了，接下來我們可以使用： kubectl get pods 可以查看我們運行中的 Pod： NAME READY STATUS RESTARTS AGE kubernetes-demo-pod 1/1 Running 0 3m5s Pod 指令介紹 查詢現有 Pod 狀態 kubectl get po/pod/pods 查看該 Pod 詳細資訊 kubectl describe pods \u003cpod-name\u003e 刪除 Pod kubectl delete pods 查看 Pod log kubectl logs \u003cpod-name\u003e 也可以使用 minikube 圖形化頁面來看一下是否成功！ minikube dashboard --url 🤔 Verifying dashboard health ... 🚀 Launching proxy ... 🤔 Verifying proxy health ... http://127.0.0.1:55991/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ minikube dashboard\" minikube dashboard ","date":"2022-04-28","objectID":"/k8s/:5:2","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"連線到 Pod 的服務 當我們建立好 Pod 之後，打開瀏覽器 localhost:3000 會發現，什麼都沒有，是因為我們剛剛在 .yaml 裡面設定的是 Pod 的 Port ，它與本機的 Port 是不相通的，因此我們需要使用 kubectl port-forward \u003cpod\u003e \u003cexternal-port\u003e:\u003cpod-port\u003e ，來將 Pod 與本機端做 mapping。 kubectl port-forward kubernetes-demo-pod 3000:3000 Forwarding from 127.0.0.1:3000 -\u003e 3000 Forwarding from [::1]:3000 -\u003e 3000 Handling connection for 3000 我們在此瀏覽 localhost:3000，就會看到可愛的柴犬囉！ 成功顯示柴犬\" 成功顯示柴犬 前面我們已經創建屬於我們第一個 Pod 了，但當我們 Pod 越建越多時，要怎麼快速的得知每個 Pod 在做什麼事情？除了用 Pod 的 metadata name 來命名外，還有另一種方式： ","date":"2022-04-28","objectID":"/k8s/:5:3","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"什麼是 Label ? Label 顧名思義就是標籤，可以為每一個 Pod 貼上標籤，讓 Kubernetes 更方便的管控這些 Pod。 Label 的寫法很簡單，可以自己自訂一對具有辨識度的 key/value，舉我們上面的例子來說：我們可以在 labels 內加入 app: demo，那 Label 有什麼好處呢? 這邊要稍微提一下 Selector，它的功用是選取對應的物件。為了要方便選取到我們設定好的 Pod，這時候 Label 就派上用場了！ Selector 的寫法也很簡單，只要把我們在 Label 定義的 key/value 直接完整的貼過來就可以了～ 就像這樣： selectors:app:demo 那選取後有什麼功用呢！請看 Kubernetes - 進階 - Service 講完 Label 後，順邊提一下跟 Label 有相似的： ","date":"2022-04-28","objectID":"/k8s/:6:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"什麼是 Annotation ? 前面提到的 Label 功用其目的是要讓 Kubernetes 知道可以去更方便管理的，那我們如果想要貼標籤但不想讓 Kubernetes 知道，要怎麼做呢？ 這時我們就可以用 Annotation，透過 Annotation 可以將標籤單純給開發人員查看，那聽起來 Annotation 好像沒有什麼實質上的用途，因為 Kubernetes 不會採用這些標籤，但其實 Annotation 還是有用的歐！後續文章會再提到 \u003e\u003c 那既然 Label 跟 Annotation 有相似，所以寫法想必也是差不多吧： annotations:author:Pin-YIcontact:880831ian@gmail.com 一樣也是定義一組具有辨識度的 key/value ，我們這邊就先放 author、contact 那 Label 與 Annotation 要放在 Pod 的哪一處呢？ 還記得我們上面說 metadata 是用來擺描述性資料的地方嗎，所以不管是 Label 或是 Annotation 都是放在 metadata 中歐！ metadata:name:kubernetes-demo-podlabels:app:demoannotations:author:Pin-YIcontact:880831ian@gmail.com ","date":"2022-04-28","objectID":"/k8s/:7:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"參考資料 kubernetes 官網 Kubernetes（K8s）是什麼？基礎介紹+3大優點解析 Docker Swarm vs Kubernetes: how to choose a container orchestration tool Kubernetes 基礎教學（一）原理介紹 Kubernetes那些事 — 基礎觀念與操作 Kubernetes 那些事 — Pod 篇 Kubernetes 那些事 — Label 篇 ","date":"2022-04-28","objectID":"/k8s/:8:0","tags":["Kubernetes","K8s","Docker","介紹","實作"],"title":"Kubernetes (K8s) 介紹 - 基本","uri":"/k8s/"},{"categories":["codenotes"],"content":"前情提要：本篇是 用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose) 以及 Redis 哨兵模式 (Sentinel) 搭配 Docker-compose 實作 的後續文章，主要會優化原本的程式碼，並使用 EFK 來收集LOG！ ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:0:0","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"什麼是 EFK ? 隨著現在各種程式系統複雜度越來越高，特別是現在都往雲上開始作部署，當我們想要查看 log 的時候，不可能一個一個去登入各節點去查看 log，不僅效率低，也會有安全性的問題，所以不可能讓工程師直接去訪問每一個節點。 而且現在大規模的系統基本上都採用叢集的部署方式，意味著對每個 service，會啟動多個完全一樣的 POD 對外提供服務，每個 container 都會產生自己的 log，從產生 log 來看，你根本不知道是由哪個 POD 產生的，這樣對查看分佈式的日誌更加困難。 所以在雲時代，需要一個收集並分析 log 的解決方案。首先需要將分佈在各個角落的 log 統一收集到一個集中的地方，方便查看。收集之後，還可以進行各種統計以及分析，甚至用流行的大數據或機器學習的方法來進行分析。 所以誕生了 ELK 或是 EFK 的解決方式： ELK 是由 Elasticsearch、Logstash、Kibana 所組成， EFK 是由 Elasticsearch、(Filebeats or Fluentd)、Kibana 所組成，兩者的差異在中間使用的開源程式，我會分別介紹一下每一個程式主要的用途： Elasticsearch：它是一個集中儲存 log 的地方，更重要的是它是一個全文檢索以及分析的引擎，它能讓用戶以近乎實時的方式來查看、分析海量的數據。 Logstash、Filebeats、Fluentd：它們主要是收集分佈在各處的 log 並進行處理(Filebeats 僅收集)。 Kibana：它是為 Elasticsearch 開發的前端 GUI，可以讓用戶很方便的以圖形化進行查詢 Elasticsearch 中儲存的數據，同時也提供各式各樣的模組可以使用。 Logstash、Filebeats、Fluentd 關係： Filebeats 是一個輕量級收集本地 log 數據的方案，它僅能收集本地的 log，不能對 log 做處理，所以 Filebeats 通常會將 log 送到 Logstash 做進一步的處理。 那為什麼不直接使用 Logstash 來收集收集並處理 log 呢？ 因為 Logstash 會消耗許多的記憶體，所以才會先透過 Filebeats 收集資料再傳給 Logstash 做處理。 另外 Filebeats、Logstash、Elasticsearch 和 Kibana 都是屬於同一家公司的開源項目：https://www.elastic.co/guide/ 而 Fluentd 則是另一家公司的開源項目：https://docs.fluentd.org/ 那我們在這邊就使用 Fluentd 來做我們的 EFK 示範： EFK 示意圖 EFK Stack: Elasticsearch, Fluentd and Kibana on Docker\" EFK 示意圖 EFK Stack: Elasticsearch, Fluentd and Kibana on Docker 上面這張圖代表我們會有很多 Docker 容器的 log (也就是之前的 redis 以及其他 nginx 等的容器)，會先透過 Fluentd 收集並處理各容器的 log 在傳送到 Elasticsearch 集中儲存，再使用 Kibana 圖形化介面來查詢或檢索儲在 Elasticsearch 的 log。 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:1:0","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"實作 那接下來會使用 Docker-compose 實作 EFK 的 LOG 分析，範例程式連結 點我 😘 版本資訊 macOS：11.6 Docker：Docker version 20.10.12, build e91ed57 Nginx：1.20 PHP：7.4-fpm Redis：6.2.6 HAProxy：HAProxy version 2.5.5-384c5c5 2022/03/14 - https://haproxy.org/ Elasticsearch：8.1.3 Fluentd：v1.14 Kibana：8.1.3 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:0","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"檔案結構 . ├── docker-volume │ ├── fluentd │ │ └── fluent.conf │ ├── haproxy │ │ └── haproxy.cfg │ ├── nginx │ │ └── nginx.conf │ ├── php │ │ ├── info.php │ │ ├── r.php │ │ └── rw.php │ └── redis │ ├── redis.conf │ ├── redis1 │ ├── redis2 │ └── redis3 ├── docker.sh ├── efk │ └── Docker-compose.yaml ├── fluentd │ └── Dockerfile ├── haproxy_sentinel │ ├── Docker-compose.yaml │ ├── sentinel1 │ │ └── sentinel.conf │ ├── sentinel2 │ │ └── sentinel.conf │ └── sentinel3 │ └── sentinel.conf ├── nginx_php_redis │ └── Docker-compose.yaml └── php └── Dockerfile 這是主要的結構，簡單說明一下：(檔案越來越多了XD，這次把每一個都有分類，所以結構會與之前不太相同) docker-volume/fluentd/fluent.conf：fluentd 的設定檔。 docker-volume/haproxy/haproxy.cfg：haproxy 的設定檔。 docker-volume/nginx/nginx.conf：nginx 的設定檔。 docker-volume/php/(r.php、rw.php)：測試用檔案。 docker-volume/redis/redis.conf：redis 的設定檔。 docker-volume/redis/(redis1、redis2、redis3)：放 redis 的資料。 docker.sh：是我另外多寫的腳本，可以查看相對應的角色。 efk/Docker-compose.yaml：會放置要產生的 elasticsearch、kibana、fluentd 的容器設定檔。 fluentd/Dockerfile：因為 fluentd 需要另外安裝 fluent-plugin-elasticsearch 才能使用，所以用 Dockerfile 另外寫 fluent 的映像檔。 haproxy_sentinel/Docker-compose.yaml：會放置要產生的 haproxy、sentinel1、sentinel2、sentinel3 的容器設定檔。 haproxy_sentinel/(sentinel1、sentinel2、sentinel3)/.conf：哨兵的設定檔。 nginx_php_redis/Docker-compose.yaml：會放置要產生的 nginx、php、redis1、redis2、redis3 的容器設定檔。 php/Dokcerfile：因為在 php 要使用 redis 需要多安裝一些設定，所以用 Dockerfile 另外寫 PHP 的映像檔。 那我們就依照安裝的設定開始說明：(這邊只說明與上一篇不同地方，重複的就請大家回去看之前的文章) ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:1","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"docker-volume/fluentd/fluent.conf \u003csource\u003e @type forward bind 0.0.0.0 port 24224 \u003c/source\u003e \u003cmatch *.**\u003e @type copy \u003cstore\u003e @type elasticsearch host elasticsearch port 9200 logstash_format true logstash_prefix fluentd logstash_dateformat %Y%m%d include_tag_key true type_name access_log tag_key @log_name flush_interval 1s \u003c/store\u003e \u003cstore\u003e @type stdout \u003c/store\u003e \u003c/match\u003e 這是 fluent 的設定檔，可以在這邊做自訂的設定，例如 host、port、預設日期、tag_key 等等。 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:2","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"fluentd/Dockerfile FROMfluent/fluentd:v1.14USERrootRUN [\"gem\", \"install\", \"fluent-plugin-elasticsearch\"] 因為我們需要先安裝 fluent-plugin-elasticsearch 才可以讓 fluentd 來使用 elasticsearch，所以多寫一個 Dockerfile 來設定。 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:3","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"efk/Docker-compose.yaml version:'3.8'services:elasticsearch:image:elasticsearch:8.1.3container_name:elasticsearchenvironment:- discovery.type=single-node- xpack.security.enabled=false# elasticsearch 8.x版本後會自動開啟SSLnetworks:efk_network:ipv4_address:172.20.0.3ports:- 9200:9200kibana:image:kibana:8.1.3container_name:kibanaenvironment:- ELASTICSEARCH_HOSTS=http://elasticsearch:9200# - I18N_LOCALE=zh-CNnetworks:efk_network:ipv4_address:172.20.0.4ports:- 5601:5601depends_on:- elasticsearchfluentd:build:../fluentdcontainer_name:fluentdvolumes:- ../docker-volume/fluentd:/fluentd/etcdepends_on:- elasticsearchports:- \"24224:24224\"- \"24224:24224/udp\"networks:efk_network:ipv4_address:172.20.0.5networks:efk_network:driver:bridgename:efk_networkipam:config:- subnet:172.20.0.0/16gateway:172.20.0.1 這邊是設定 EFK 三個容器的檔案，比較特別的是 elasticsearch 在 8.x 版本後會自動開啟 SSL 連線，所以沒有使用的或是在測試中的要先把它關掉，不然會連不上！，kibana 它支援 I18N 多語系，但目前沒有繁體中文，所以想要看中文的可以切成 zh-CH 的簡體中文來使用，其他就是基本的設定 Posts 以及我們全部設定好 IP，在後續測試會比較方便～ ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:4","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"nginx_php_redis/Docker-compose.yaml version:\"3.8\"services:nginx:image:nginxcontainer_name:nginxnetworks:efk_network:ports:- 8080:80volumes:- ../docker-volume/nginx/:/etc/nginx/conf.d/environment:- TZ=Asia/Taipeilogging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:nginxphp:build:../phpcontainer_name:phpnetworks:efk_network:expose:- 9000volumes:- ../docker-volume/php/:/var/www/htmlenvironment:- TZ=Asia/Taipeilogging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:phpredis1:image:rediscontainer_name:redis1command:redis-server /usr/local/etc/redis/redis.conf --appendonly yesvolumes:- ../docker-volume/redis/redis1/:/data- ../docker-volume/redis/:/usr/local/etc/redis/environment:- TZ=Asia/Taipeinetworks:efk_network:ipv4_address:172.20.0.11ports:- 6379:6379logging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:redis1redis2:image:rediscontainer_name:redis2command:redis-server /usr/local/etc/redis/redis.conf --slaveof redis1 6379 --appendonly yesvolumes:- ../docker-volume/redis/redis2/:/data- ../docker-volume/redis/:/usr/local/etc/redis/environment:- TZ=Asia/Taipeinetworks:efk_network:ipv4_address:172.20.0.12ports:- 6380:6379depends_on:- redis1logging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:redis2redis3:image:rediscontainer_name:redis3command:redis-server /usr/local/etc/redis/redis.conf --slaveof redis1 6379 --appendonly yesvolumes:- ../docker-volume/redis/redis3/:/data- ../docker-volume/redis/:/usr/local/etc/redis/environment:- TZ=Asia/Taipeinetworks:efk_network:ipv4_address:172.20.0.13ports:- 6381:6379depends_on:- redis1- redis2logging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:redis3networks:efk_network:external:name:efk_network 那這邊基本上都與上一篇一樣，沒有修改特別的地方，只有修改網路名稱以及： logging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:nginx 我們要把每一個容器的 log 進行收集與處理，所以我們使用 logging 然後 driver 選擇 fluentd，並且要設定 fluentd 的 IP 位置以及每一個容器可設定不同的 tag 方便我們查詢。 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:5","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"haproxy_sentinel/Docker-compose.yaml version:'3.8'services:haproxy:image:haproxycontainer_name:haproxyvolumes:- ../docker-volume/haproxy/:/usr/local/etc/haproxyenvironment:- TZ=Asia/Taipeinetworks:efk_network:ipv4_address:172.20.0.20ports:- 16379:6379- 8404:8404logging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:haproxysentinel1:image:rediscontainer_name:redis-sentinel-1networks:efk_network:ports:- 26379:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel1:/usr/local/etc/redis/environment:- TZ=Asia/Taipeilogging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:sentinel1sentinel2:image:rediscontainer_name:redis-sentinel-2networks:efk_network:ports:- 26380:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel2:/usr/local/etc/redis/environment:- TZ=Asia/Taipeilogging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:sentinel2sentinel3:image:rediscontainer_name:redis-sentinel-3networks:efk_network:ports:- 26381:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel3:/usr/local/etc/redis/environment:- TZ=Asia/Taipeilogging:driver:\"fluentd\"options:fluentd-address:172.20.0.5:24224tag:sentinel3networks:efk_network:external:name:efk_network 與前面一樣，多了一個 logging 來設定 fluentd 位置以及 tag。 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:2:6","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"測試 我們先用 docker-compose up 來啟動 efk/Docker-compose.yaml，接著再啟動 nginx_php_redis/Docker-compose.yaml，最後啟動 haproxy_sentinel/Docker-compose.yaml： 啟動 efk/Docker-compose.yaml\" 啟動 efk/Docker-compose.yaml 啟動 nginx_php_redis/Docker-compose.yaml\" 啟動 nginx_php_redis/Docker-compose.yaml 啟動 haproxy_sentinel/Docker-compose.yaml\" 啟動 haproxy_sentinel/Docker-compose.yaml (啟動 efk 時要等他跑完，因為他需要啟動一陣子，如果還沒等他啟動完畢就啟動下一個，會導致 fluentd 的 fluentd-address 尚未設定好，導致啟動錯誤) 這時候可以使用瀏覽器搜尋以下網址： test.com:5601：Kibana GUI 頁面。 kibana 設定\" kibana 設定 如果連線成功進來，就代表我們有安裝好 Elasticsearch 以及 kibana，那我們來做一些設定，讓我們可以在 kibana 上面看到 log。 先點選左邊的欄位，點選 “Stack Management” ，可以看到目前的 kibana 的版本，再點選左邊的 “Kibana \u003e Date Views”： kibana 設定\" kibana 設定 然後會跳出一個視窗點選 “Create data view”，在 name 欄位輸入 fluentd* (右側有 fluentd 加時間，代表我們接 fluentd 有成功)，按下 “Create data view” kibana 設定\" kibana 設定 接著點選左側的欄位，點選 “Analytics \u003e Discover” ，就可以看到我們目前所有的 log 囉！ kibana 設定\" kibana 設定 kibana Analytics \u003e Discover\" kibana Analytics \u003e Discover ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:3:0","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["codenotes"],"content":"參考資料 elastic 官網 fluentd 官網 Build the EFK system used for simulating logging server on Docker 開源日誌管理方案ELK 和EFK 的區別 ","date":"2022-04-28","objectID":"/docker-compose-redis-sentinel-haproxy-efk/:4:0","tags":["EFK","HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 EFK 收集容器日誌 (HAProxy、Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy-efk/"},{"categories":["youtube"],"content":"與許久不見的朋友，相約去宜蘭露營，希望疫情能夠趕快結束，才可以一起去更多地方遊玩！ 其中片段因為GoPro有點小問題，所以導致畫面會卡卡的，請大家見諒 🥲 設備/剪輯/BGM 設備： 主攝影：GoPro 9 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Sunshine by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3DewYEU Music promoted by Audio Library https://youtu.be/A_d217KItFg One Day by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3J4gEZf Music promoted by Audio Library https://youtu.be/P8CCI0o1yUo 相關連結 影片🎬：下方請收看 👇 ","date":"2022-04-24","objectID":"/glamping/:0:0","tags":["露營","朋友","旅遊","YouTube"],"title":"【豪華露營】宜起去露營VLOG","uri":"/glamping/"},{"categories":["codenotes"],"content":"前情提要：本篇是 Redis 哨兵模式 (Sentinel) 搭配 Docker-compose 實作 的後續文章，主要會優化原本的程式碼，並加上 HAProxy 來做負載平衡！ ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:0:0","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"什麼是 HAProxy 以及負載均衡 ? HAProxy 是一個使用 C 語言編寫的自由及開放原始碼軟體，其提供高可用性、負載均衡，以及基於 TCP 和 HTTP 的應用程式代理。 負載平衡 (Load Balance)： 現在很多網路服務都需要服務大量使用者，以前可以砸錢擴充機器硬體設施，但隨著網路服務的用量暴增，增加伺服器硬體設備已經無法解決問題。 為了可以擴充服務，負載平衡成為主流的技術，這幾年雖然雲端與分散式儲存運算技術火紅，除非有特別的使用需求，不然在技術上負載均衡算是比較容易達成與掌握的技術。 負載平衡除了分流能力之外，有另一個很大的好處就是可以提供 High Availability，也就是傳說中的 HA 架構，好讓你一台機器掛了其他伺服器可以繼續服務，降低斷線率。 HAProxy 與 Reids Sentinel 示意圖 selcukusta/redis-sentinel-with-haproxy\" HAProxy 與 Reids Sentinel 示意圖 selcukusta/redis-sentinel-with-haproxy ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:1:0","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"實作 那接下來會使用 Docker-compose 實作 Redis 哨兵模式 + HAProxy，範例程式連結 點我 😘 版本資訊 macOS：11.6 Docker：Docker version 20.10.12, build e91ed57 Nginx：1.20 PHP：7.4-fpm Redis：6.2.6 HAProxy：HAProxy version 2.5.5-384c5c5 2022/03/14 - https://haproxy.org/ ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:0","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"檔案結構 . ├── Docker-compose.yaml ├── docker-volume │ ├── haproxy │ │ └── haproxy.cfg │ ├── nginx │ │ └── nginx.conf │ ├── php │ │ ├── info.php │ │ ├── r.php │ │ └── rw.php │ └── redis │ ├── redis.conf │ ├── redis1 │ ├── redis2 │ └── redis3 ├── php │ └── Dockerfile ├── redis.sh └── sentinel ├── Docker-compose.yaml ├── sentinel1 │ └── sentinel.conf ├── sentinel2 │ └── sentinel.conf └── sentinel3 └── sentinel.conf 這是主要的結構，簡單說明一下： Docker-compose.yaml：會放置要產生的 Nginx、PHP、redis1、redis2、redis3 容器設定檔。 docker-volume/haproxy/haproxy.cfg：haproxy 的設定檔。 docker-volume/nginx/nginx.conf：nginx 的設定檔。 docker-volume/php/(r.php、rw.php)：測試用檔案。 docker-volume/redis/redis.conf：redis 的設定檔。 docker-volume/redis/(redis1、redis2、redis3)：放 redis 的資料。 php/Dokcerfile：因為在 php 要使用 redis 需要多安裝一些設定，所以用 Dockerfile 另外寫 PHP 的映像檔。 redis.sh：是我另外多寫的腳本，可以查看相對應的角色。 sentinel/Docker-compose.yaml：會放置要產生的 haproxy、sentinel1、sentinel2、sentinel3 的容器設定檔。 sentinel/(sentinel1、sentinel2、sentinel3)/.conf：哨兵的設定檔。 那我們就依照安裝的設定開始說明： ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:1","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"Docker-compose.yaml version:'3.8'services:nginx:image:nginx:1.20container_name:nginxnetworks:HAProxy_Redis:ports:- \"8888:80\"volumes:- ./docker-volume/nginx/:/etc/nginx/conf.d/- ./log/nginx/:/var/log/nginx/environment:- TZ=Asia/Taipeiphp:build:./phpcontainer_name:phpnetworks:HAProxy_Redis:expose:- 9000volumes:- ./docker-volume/php/:/var/www/htmlredis1:image:rediscontainer_name:redis1command:redis-server /usr/local/etc/redis/redis.conf --appendonly yesvolumes:- ./docker-volume/redis/redis1/:/data- ./docker-volume/redis/:/usr/local/etc/redis/- ./log/redis1:/var/log/redis/environment:- TZ=Asia/Taipeinetworks:HAProxy_Redis:ipv4_address:172.20.0.11ports:- 6379:6379redis2:image:rediscontainer_name:redis2command:redis-server /usr/local/etc/redis/redis.conf --slaveof redis1 6379 --appendonly yesvolumes:- ./docker-volume/redis/redis2/:/data- ./docker-volume/redis/:/usr/local/etc/redis/- ./log/redis2:/var/log/redis/environment:- TZ=Asia/Taipeinetworks:HAProxy_Redis:ipv4_address:172.20.0.12ports:- 6380:6379depends_on:- redis1redis3:image:rediscontainer_name:redis3command:redis-server /usr/local/etc/redis/redis.conf --slaveof redis1 6379 --appendonly yesvolumes:- ./docker-volume/redis/redis3/:/data- ./docker-volume/redis/:/usr/local/etc/redis/- ./log/redis3:/var/log/redis/environment:- TZ=Asia/Taipeinetworks:HAProxy_Redis:ipv4_address:172.20.0.13ports:- 6381:6379depends_on:- redis1- redis2networks:HAProxy_Redis:driver:bridgename:HAProxy_Redisipam:config:- subnet:172.20.0.0/16gateway:172.20.0.1 一樣詳細的 Docker 設定說明，可以參考 Docker 介紹 內有詳細設定說明。其他比較特別的地方是： 幫每一個容器都設定好 IP ，方便後續測試使用。 有掛載 log 目錄，可以將我們設定好的 log 做收集。 呈上，有加入 environment 時區，這樣在看 log 的時候才知道正確時間。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:2","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"docker-volume/haproxy/haproxy.cfg global log stdout format raw local0 info defaults mode http # 默認模式 { tcp | http | health }，tcp 是4層，http 是7層，health 只會返回 OK timeout client 10s # 客戶端超時 timeout connect 5s # 連接超時 timeout server 10s # 伺服器超時 timeout http-request 10s log global listen admin_status bind 0.0.0.0:8404 mode http stats enable stats uri /redis stats realm Global\\ statistics stats refresh 1s listen rw-redis # 判斷是否為 master 並可讀可寫 bind 0.0.0.0:16379 mode tcp balance roundrobin option tcp-check # redis 健康检查，確保是 master tcp-check connect tcp-check send PING\\r\\n tcp-check expect string +PONG tcp-check send info\\ replication\\r\\n tcp-check expect string role:master tcp-check send QUIT\\r\\n tcp-check expect string +OK server redis1 redis1:6379 check inter 2000 server redis2 redis2:6379 check inter 2000 server redis3 redis3:6379 check inter 2000 listen r-redis # 判斷是否為 master、slave 並可讀 bind 0.0.0.0:16380 mode tcp balance roundrobin server redis1 redis1:6379 check inter 2000 server redis2 redis2:6379 check inter 2000 server redis3 redis3:6379 check inter 2000 這裡是本章的重點，我們會在這邊設定好 haproxy，詳細說明請看： defaults： 一些初始值，像是 mode 我們預設 http，它主要有三種模式 { tcp | http | health }，tcp 是4層，http 是7層，health 只會返回 OK，以及客戶端、連接、伺服器、http 請求超時時間設定。 listen admin_status： bind：我們要開啟 HAProxy 監控平台的 port。 mode：模式，我們使用 http 模式。 stats ：是否要啟動平台。 stats uri：平台網址，我們使用 redis。 stats refresh：平台自動更新時間，我們設定 1 秒。 listen rw-redis： bind ：rw 使用 16379 Port 來當輸出。 balance：使用負載平衡。 option tcp-check # redis 健康检查，確保是 master tcp-check connect tcp-check send PING\\r\\n tcp-check expect string +PONG tcp-check send info\\ replication\\r\\n tcp-check expect string role:master tcp-check send QUIT\\r\\n tcp-check expect string +OK 上面這些是用來判斷角色是不是 master。 最後放我們 3 個 redis 服務： server redis1 redis1:6379 check inter 2000 server redis2 redis2:6379 check inter 2000 server redis3 redis3:6379 check inter 2000 check：開啟健康偵測。 inter：參數更改檢查間隔，預設是 2 秒。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:3","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"docker-volume/nginx/nginx.conf server { listen 80; server_name default_server; return 404; } server { listen 80; server_name test.com; index index.php index.html; error_log /var/log/nginx/error.log warn; access_log /var/log/nginx/access.log; root /var/www/html; location / { try_files $uri $uri/ /index.php?$query_string; } location ~ \\.php$ { fastcgi_pass php:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; } } Nginx 設定檔案。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:4","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"docker-volume/php/rw.php \u003c?php $redis = new Redis(); $redis-\u003econnect('172.20.0.20', 16379); $r = $redis-\u003einfo(); echo $r['run_id'] . '\u003cbr\u003e' . $r['role'] . '\u003cbr\u003e\u003cbr\u003e'; echo '\u003cpre\u003e', print_r($r), '\u003c/pre\u003e'; 跟 r.php 比較不同的是，使用 16379 Port，我們在 haproxy.cfg 有設定 rw-redis，來判斷是不是 master 並且是可讀可寫。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:5","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"docker-volume/php/r.php \u003c?php $redis = new Redis(); $redis-\u003econnect('172.20.0.20', 16380); $r = $redis-\u003einfo(); echo $r['run_id'] . '\u003cbr\u003e' . $r['role'] . '\u003cbr\u003e\u003cbr\u003e'; echo '\u003cpre\u003e', print_r($r), '\u003c/pre\u003e'; 使用 16380 Port，在 haproxy.cfg 有設定 r-redis，來顯示是不是 master、slave 且可讀。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:6","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"php/Dockerfile FROMphp:7.4-fpmRUN pecl install -o -f redis \\ \u0026\u0026 rm -rf /tmp/pear \\ \u0026\u0026 echo \"extension=redis.so\" \u003e /usr/local/etc/php/conf.d/redis.ini \\ \u0026\u0026 echo \"session.save_handler = redis\" \u003e\u003e /usr/local/etc/php/conf.d/redis.ini \\ \u0026\u0026 echo \"session.save_path = tcp://redis:6379\" \u003e\u003e /usr/local/etc/php/conf.d/redis.ini 因為 PHP 要使用 Redis，會需要安裝一些套件，所以我們將 PHP 分開來，使用 Dockerfile 來設定映像檔。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:7","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"redis.sh #!/bin/bash green=\"\\033[1;32m\";white=\"\\033[1;0m\";red=\"\\033[1;31m\"; echo \"redis1 IPAddress:\" redis1_ip=`docker inspect redis1 | grep \"IPv4\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $redis1_ip; echo \"------------------------------\" echo \"redis2 IPAddress:\" redis2_ip=`docker inspect redis2 | grep \"IPv4\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $redis2_ip; echo \"------------------------------\" echo \"redis3 IPAddress:\" redis3_ip=`docker inspect redis3 | grep \"IPv4\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $redis3_ip; echo \"------------------------------\" echo \"haproxy IPAddress:\" haproxy_ip=`docker inspect haproxy | grep \"IPv4\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $haproxy_ip; echo \"------------------------------\" echo \"redis1:\" docker exec -it redis1 redis-cli info Replication | grep role echo \"redis2:\" docker exec -it redis2 redis-cli info Replication | grep role echo \"redis3:\" docker exec -it redis3 redis-cli info Replication | grep role 這個是我自己所寫的腳本，可以詳細知道目前服務的角色轉移狀況。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:8","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"sentinel/Docker-compose.yaml version:'3.8'services:haproxy:image:haproxycontainer_name:haproxyvolumes:- ../docker-volume/haproxy/:/usr/local/etc/haproxyenvironment:- TZ=Asia/Taipeinetworks:HAProxy_Redis:ipv4_address:172.20.0.20ports:- 16379:6379- 8404:8404sentinel1:image:rediscontainer_name:redis-sentinel-1networks:HAProxy_Redis:ports:- 26379:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel1:/usr/local/etc/redis/- ../log/sentinel1:/var/log/redis/environment:- TZ=Asia/Taipeisentinel2:image:rediscontainer_name:redis-sentinel-2networks:HAProxy_Redis:ports:- 26380:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel2:/usr/local/etc/redis/- ../log/sentinel2:/var/log/redis/environment:- TZ=Asia/Taipeisentinel3:image:rediscontainer_name:redis-sentinel-3networks:HAProxy_Redis:ports:- 26381:26379command:redis-server /usr/local/etc/redis/sentinel.conf --sentinelvolumes:- ./sentinel3:/usr/local/etc/redis/- ../log/sentinel3:/var/log/redis/environment:- TZ=Asia/Taipeinetworks:HAProxy_Redis:external:name:HAProxy_Redis ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:9","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"sentinel/sentine.conf 因為 sentine 內容都基本上相同，所以舉一個來說明： port 26379 logfile \"/var/log/redis/redis-sentinel.log\" protected-mode no #設定要監控的 Master，最後的 2 代表判定客觀下線所需的哨兵數 sentinel monitor mymaster 172.20.0.11 6379 2 #哨兵 Ping 不到 Master 超過此毫秒數會認定主觀下線 sentinel down-after-milliseconds mymaster 5000 要設定指定的 Port sentine1 是 26379、sentine2 是 26380、sentine3 是 26381。接下來要設定要監控的 Master，最後的數字代表我們前面有提到客觀下線需要達到的哨兵數。以及主觀下線的時間跟 failover 超過的時間。 ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:2:10","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"測試 我們先用 docker-compose up 來啟動 Docker-compose.yaml，接著再啟動 sentinel/Docker-compose.yaml： 啟動 Docker-compose.yaml\" 啟動 Docker-compose.yaml 啟動 sentinel/Docker-compose.yaml\" 啟動 sentinel/Docker-compose.yaml 由於為了測試，有先將所有容器設定好 IP，就不會像上一篇文章一樣要去抓 IP ，才能啟動 Sentinel。 這時候可以使用瀏覽器搜尋以下網址： test.com:8404/redis：HAProxy 監看平台(只取片段)。 HAProxy 監控平台\" HAProxy 監控平台 test.com:8888/rw.php：只會顯示 master，並且可讀可寫。 master (redis1)\" master (redis1) test.com:8888/r.php：會顯示 master、slave，且可讀。 master (redis1)\" master (redis1) slave (redis2)\" slave (redis2) slave (redis3)\" slave (redis3) 接下來可以執行： $ sh redis.sh redis1 IPAddress: 172.20.0.11 ------------------------------ redis2 IPAddress: 172.20.0.12 ------------------------------ redis3 IPAddress: 172.20.0.13 ------------------------------ haproxy IPAddress: 172.20.0.20 ------------------------------ redis1: role:master redis2: role:slave redis3: role:slave 就會顯示三個 redis 的 IP 以及 haproxy 的 IP，這些都是已經寫在 Docker-compose.yaml 檔案內的，如果忘記的可以再往前看 ↑ 接下來我們可以先一直 F5 test.com:8888/r.php，來模擬大量的讀取請求，如果發現網站內容一直在更換，就代表我們成功透過 HAProxy 做到負載平衡了，可以將讀取的需求分給三個服務做處理！那因為 test.com:8888/rw.php 他只會抓 master，所以刷新還是同一個 master。 還記得我們上次用 Redis 的哨兵模式嗎？那我們用它來搭配 Haproxy 會有什麼結果呢？ 我們先使用 docker stop 來模擬服務中斷： $ docker stop redis1 redis1 可以看到 test.com:8404/redis 原本綠色的 redis1 開始變成黃色，最後變成紅色： 模擬中斷服務 HAProxy 監控平台\" 模擬中斷服務 HAProxy 監控平台 最後可以看到 Redis Sentinel 作動，將 master 轉移到 redis3： 模擬中斷服務 HAProxy 監控平台\" 模擬中斷服務 HAProxy 監控平台 這時候我們再去看 test.com:8888/rw.php ，就會發現與剛剛的 master 不太一樣囉，因為已經變成 redis2 了！ master (redis2)\" master (redis2) 代表我們 HAProxy 也有成功將 master 給顯示出來！ 我們再去看 test.com:8888/r.php ，就可以發現剩下 redis2 以及 redis 3 了，因為 redis1 被我們給暫停服務了，而且 redis2 變成 master！ master (redis2)\" master (redis2) slave (redis3)\" slave (redis3) ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:3:0","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"參考資料 HAProxy 首頁 HAproxy的安裝設定及範例 redis sentinel集群配置及haproxy配置 富人用 L4 Switch，窮人用 Linux HAProxy！ selcukusta/redis-sentinel-with-haproxy How to Enable Health Checks in HAProxy ","date":"2022-04-22","objectID":"/docker-compose-redis-sentinel-haproxy/:4:0","tags":["HAProxy","Redis","Docker","Sentinel","負載平衡","哨兵模式","實作"],"title":"用 HAProxy 對 Redis 做負載平衡 (Redis Sentinel、Docker-compose)","uri":"/docker-compose-redis-sentinel-haproxy/"},{"categories":["codenotes"],"content":"什麼是 Redis 哨兵模式 (Sentinel) ? 有關 Redis 之前有寫一篇 Redis 的介紹文，有興趣可以去看看！ Redis 提供非常實用的功能來讓我們實現多機的 in-memory 資料庫： 主從複製模式 (Master-Slave Replication) 哨兵模式 (Sentinel) 叢集模式 (Cluster) 我們這邊主要介紹哨兵模式 (Sentinel)，但主要也是由主從複製模式 (Master-Slave Replication) 修改而來： 哨兵模式就是用來監視 Redis 系統，哨兵會監控 Master 是否正常運作。如果遇到 Master 出現故障或是離線時，哨兵之間會開始判斷，直到我們所設定需達到的判斷數量後，哨兵會將其所屬的 Slave 變成 Master，並再將其他的 Slave 指向新的 Master。 哨兵模式 (Sentinel)\" 哨兵模式 (Sentinel) ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:1:0","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"監控 哨兵會和要監控的 Master 建立兩條連接，Cmd 和 Pub/Sub： Cmd 是哨兵用來定期向 Master 發送 Info 命令以取得 Master 的訊息，訊息中會包含 Master 有哪些 Slave。當與 Master 獲得 Slave 訊息後，哨兵也會和 Slave 建立連接。 哨兵也會定期透過 Cmd 向 Master、Slave 和其他哨兵發送 Ping 指令來檢查是否存在，確認節點狀態等。 Pub/Sub 讓哨兵可以透過訂閱 Master 和 Slave 的 __Sentinel__:hello 這個頻道來和其他哨兵定期的進行資訊交換。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:1:1","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"主觀下線 (SDOWN) 主觀下線是指單個哨兵認為 Master 已經停止服務了，有可能是網路不通或是接收不到訂閱等，而哨兵的判斷是依據傳送 Ping 指令之後一定時間內是否收到回覆或是錯誤訊息，如果有哨兵就會主觀認為這個 Master 已經下線停止服務了。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:1:2","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"客觀下線 (ODOWN) 客觀下線是指由多個哨兵對同一個 Master 各自進行主觀下線的判斷後，再綜合所有哨兵的判斷。若是認為主觀下線的哨兵到達我們所配置的數量後，即為客觀下線。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:1:3","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"故障轉移 (Failover) 當 Master 已經被標記為客觀下線時，起初發現 Master 下線的哨兵會發起一個選舉 (採用的是 Raft 演算法)，並要求其他哨兵選他做為領頭哨兵，領頭哨兵會負責進行故障的恢復。當選的標準是要有超過一半的哨兵同意，所以哨兵的數量建議設定成奇數個。 此時若有多個哨兵同時參選領頭哨兵，則有可能會發生一輪後沒有產生勝選者，則所有的哨兵會再等隨機一個時間再次發起參選的請求，進行下一輪的選舉，一直到選出領頭為止。所以若哨兵數量為偶數就很有可能一直無法選出領頭哨兵。 選出領頭哨兵後，領頭哨兵會開始從下線的 Master 所屬 Slave 中跳選出一個來變成新的 Master，挑選的依據如下： 所有在線的 Slave 擁有最高優先權的，優先權可以透過 slave-priority 來做設定。 如果有多個同為最高優先權的 Slave，則會選擇複製最完整的。 若還是有多個 Slave 皆符合上述條件，則選擇 id 最小的。 接著領頭哨兵會將舊的 Master 更新成新的 Master 的 Slave ，讓其恢復服務後以 Slave 的身份繼續運作。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:1:4","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"用 Docker 實作 Redis 哨兵模式 那接下來會使用 Docker 來實作 Redis 的哨兵模式，範例程式連結 點我 😘 版本資訊 macOS：11.6 Docker：Docker version 20.10.12, build e91ed57 Nginx：1.20 PHP：7.4-fpm Redis：latest ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:0","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"檔案結構 . ├── Docker-compose.yaml ├── docker-volume │ ├── log │ │ └── nginx │ │ ├── access.log │ │ └── error.log │ ├── nginx │ │ └── nginx.conf │ ├── php │ │ └── index.php │ ├── redis-master │ ├── redis-slave1 │ └── redis-slave2 ├── redis.sh ├── php │ └── Dockerfile └── sentinel ├── Docker-compose.yaml ├── sentinel1.conf ├── sentinel2.conf └── sentinel3.conf 這是主要的結構，簡單說明一下： Docker-compose.yaml：會放置要產生的 Nginx、PHP、redis-master、redis-slave1、redis-slave2 容器設定檔。 docker-volume：是我們要掛載進去到容器內的檔案，包含像是 nginx.conf 或是 log/nginx 以及 redis 記憶體儲存內容。 redis.sh：是我另外多寫的腳本，可以在最後方面我們測試 Redis sentinel 是否成功。 php/Dokcerfile：因為在 php 要使用 redis 需要多安裝一些設定，所以用 Dockerfile 另外寫 PHP 的映像檔。 sentinel/Docker-compose.yaml：會放置要產生的 sentinel1、sentinel2、sentinel3 的容器設定檔。 sentinel(1、2、3).conf：哨兵的設定檔。 那我們就依照安裝的設定開始說明： ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:1","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"Docker-compose.yaml version:'3.8'services:nginx:image:nginx:1.20container_name:nginxports:- \"8888:80\"volumes:- ./docker-volume/nginx/:/etc/nginx/conf.d/- ./docker-volume/log/nginx/:/var/log/nginx/php:build:./phpcontainer_name:phpexpose:- 9000volumes:- ./docker-volume/php/:/var/www/htmlredis-master:image:rediscontainer_name:redis-mastervolumes:- ./docker-volume/redis-master/:/data ports:- 6379:6379command:redis-server --appendonly yesredis-slave1:image:rediscontainer_name:redis-slave1volumes:- ./docker-volume/redis-slave1/:/dataports:- 6380:6379command:redis-server --slaveof redis-master 6379 --appendonly yesdepends_on:- redis-masterredis-slave2:image:rediscontainer_name:redis-slave2volumes:- ./docker-volume/redis-slave2/:/dataports:- 6381:6379command:redis-server --slaveof redis-master 6379 --appendonly yesdepends_on:- redis-master- redis-slave1 詳細的 Docker 設定說明，可以參考 Docker 介紹 內有詳細設定說明。比較特別的地方是： redis-(master、slave1、slave2) volumes：將 redis 的資料掛載到 docker-volume/redis-(master、slave1、slave2)。 command：使用 redis-server 啟動，並且將該服務器轉變成指定服務器的從屬服務器 (slave server)。(如果想要保存 redis 的資料，要記得在 後面加上 –appendonly yes) ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:2","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"docker-volume/nginx/nginx.conf server { listen 80; server_name default_server; return 404; } server { listen 80; server_name test.com; index index.php index.html; error_log /var/log/nginx/error.log warn; access_log /var/log/nginx/access.log; root /var/www/html; location / { try_files $uri $uri/ /index.php?$query_string; } location ~ \\.php$ { fastcgi_pass php:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; } } Nginx 設定檔案。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:3","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"php/Dockerfile FROMphp:7.4-fpmRUN pecl install -o -f redis \\ \u0026\u0026 rm -rf /tmp/pear \\ \u0026\u0026 echo \"extension=redis.so\" \u003e /usr/local/etc/php/conf.d/redis.ini \\ \u0026\u0026 echo \"session.save_handler = redis\" \u003e\u003e /usr/local/etc/php/conf.d/redis.ini \\ \u0026\u0026 echo \"session.save_path = tcp://redis:6379\" \u003e\u003e /usr/local/etc/php/conf.d/redis.ini 因為 PHP 要使用 Redis，會需要安裝一些套件，所以我們將 PHP 分開來，使用 Dockerfile 來設定映像檔。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:4","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"sentinel/sentine.conf 因為 sentine 內容都基本上相同，所以舉一個來說明： port 26379 #設定要監控的 Master，最後的 2 代表判定客觀下線所需的哨兵數 sentinel monitor mymaster 192.168.176.4 6379 2 #哨兵 Ping 不到 Master 超過此毫秒數會認定主觀下線 sentinel down-after-milliseconds mymaster 5000 #failover 超過次毫秒數即代表 failover 失敗 sentinel failover-timeout mymaster 180000 要設定指定的 Port sentine1 是 26379、sentine2 是 26380、sentine3 是 26381。接下來要設定要監控的 Master，最後的數字代表我們前面有提到客觀下線需要達到的哨兵數。以及主觀下線的時間跟 failover 超過的時間。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:5","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"sentinel/Docker-compose.yaml version:'3.8'services:sentinel1:image:rediscontainer_name:redis-sentinel-1ports:- 26379:26379command:redis-sentinel /usr/local/etc/redis/sentinel.confvolumes:- ./sentinel1.conf:/usr/local/etc/redis/sentinel.confsentinel2:image:rediscontainer_name:redis-sentinel-2ports:- 26380:26379command:redis-sentinel /usr/local/etc/redis/sentinel.confvolumes:- ./sentinel2.conf:/usr/local/etc/redis/sentinel.confsentinel3:image:rediscontainer_name:redis-sentinel-3ports:- 26381:26379command:redis-sentinel /usr/local/etc/redis/sentinel.confvolumes:- ./sentinel3.conf:/usr/local/etc/redis/sentinel.confnetworks:default:external:name:redis_default ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:6","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"docker-volume/php/index.php \u003c?php $redis = new Redis(); $sentinel = array( array( 'host' =\u003e '192.168.176.4', 'port' =\u003e 6379, 'role' =\u003e 'master', ), array( 'host' =\u003e '192.168.176.5', 'port' =\u003e 6379, 'role' =\u003e 'slave1', ), array( 'host' =\u003e '192.168.176.6', 'port' =\u003e 6379, 'role' =\u003e 'slave2', ), ); foreach ($sentinel as $value) { try { $redis-\u003econnect($value['host'], $value['port']); $redis-\u003eset('foo', 'bar'); echo \"連線成功 \" . $value['host'] . \"\u003cbr\u003e目前 master：\" . $value['role'] . \"\u003cbr\u003e\"; } catch (\\Exception $e) { continue; } } 為了要讓 PHP 可以知道目前的 Master 是哪一個服務器，所以寫了一個 try…catch 來做判斷，並且把3個服務內容都放到陣列中，後續再測試中會再說明。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:7","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"redis.sh #!/bin/bash green=\"\\033[1;32m\";white=\"\\033[1;0m\";red=\"\\033[1;31m\"; echo \"master IPAddress:\" master_ip=`docker inspect redis-master | grep \"IP\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $master_ip; echo \"------------------------------\" echo \"slave1 IPAddress:\" slave1_ip=`docker inspect redis-slave1 | grep \"IP\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $slave1_ip; echo \"------------------------------\" echo \"slave2 IPAddress:\" slave2_ip=`docker inspect redis-slave2 | grep \"IP\" | egrep -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"` echo $slave2_ip; echo \"------------------------------\" echo \"master:\" docker exec -it redis-master redis-cli info Replication | grep role echo \"slave1:\" docker exec -it redis-slave1 redis-cli info Replication | grep role echo \"slave2:\" docker exec -it redis-slave2 redis-cli info Replication | grep role 這個是我自己所寫的腳本，再等等測試時，可以詳細知道目前服務的角色轉移狀況。 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:2:8","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"測試 我們先用 docker-compose up 來啟動 Docker-compose.yaml ，接著下 sh redis.sh 指令來查看各服務的 IP 位置以及目前角色： 啟動 Docker-compose.yaml\" 啟動 Docker-compose.yaml 使用 redis.sh 檢查目前 IP 及角色\" 使用 redis.sh 檢查目前 IP 及角色 接下來先修改 docker-volume/php/index.php $sentinel = array( array( 'host' =\u003e '192.168.208.4', 'port' =\u003e 6379, 'role' =\u003e 'master', ), array( 'host' =\u003e '192.168.208.5', 'port' =\u003e 6379, 'role' =\u003e 'slave1', ), array( 'host' =\u003e '192.168.208.6', 'port' =\u003e 6379, 'role' =\u003e 'slave2', ), ); 將各自的 IP 帶入測試的網站中。 可以瀏覽 test.com:8888 是否有正常抓到 redis 的 master test.com:8888 測試網站\" test.com:8888 測試網站 再來修改 sentinel 內的 sentinel(1、2、3).conf 檔案 port 26379 #設定要監控的 Master，最後的 2 代表判定客觀下線所需的哨兵數 sentinel monitor mymaster 192.168.208.4 6379 2 #哨兵 Ping 不到 Master 超過此毫秒數會認定主觀下線 sentinel down-after-milliseconds mymaster 5000 #failover 超過次毫秒數即代表 failover 失敗 sentinel failover-timeout mymaster 180000 將要監控的 Master IP 帶入 sentinel monitor mymaster。 再啟動 sentinel/Docker-compose.yaml 啟動 Docker-compose.yaml\" 啟動 Docker-compose.yaml 接下來我們來模擬假設 Master 服務中斷後，sentinel 會發生什麼事情： $ docker stop redis-master 下完指令後，再使用 sh redis.sh 來看看目前的 role 狀態： 使用 redis.sh 檢查目前 IP 及角色\" 使用 redis.sh 檢查目前 IP 及角色 發現已經抓不到 master IP 以及他的角色。 等待一下子後，重新下 sh redis.sh 來看目前的 role 狀態： 使用 redis.sh 檢查目前 IP 及角色\" 使用 redis.sh 檢查目前 IP 及角色 就會發現已經將 master 轉移到原 slave1。 那我們來看一下 sentinel 在背後做了哪些事情： 判斷是否主觀下線及客觀下線，並發起投票\" 判斷是否主觀下線及客觀下線，並發起投票 可以看到三個哨兵都認為 master 為 主觀下線 (sdown)，這時 sentinel-2 就認定為 客觀下線 (odown)，並發起投票要求成為領頭哨兵。 進行透票，確認誰當選\" 進行透票，確認誰當選 我們可以看到 Sentinel2 和 Sentinel3 都投給 Sentinel2，所以最後 Sentinel2 當選。 領頭哨兵選定新 master\" 領頭哨兵選定新 master 接著 sentinel2 選出 redis-slave1 (192.168.208.5:6379) 作為 Master ，並且使用 failover-state-send-slaveof-noone 來將 redis-slave1 解除 Slave 狀態變成獨立的 master，隨後將 redis-slave1 升成 master。 設定 master 並修改原 master 變成 slave\" 設定 master 並修改原 master 變成 slave 設定完新的 Master 後，Sentinel2 讓原本的 Master 轉為 Slave，並且讓 redis-slave2(192.168.208.6:6379) 指向新的 Master。最後 Sentinel1 和 Sentinel3 開始從 Sentinel2 取得設定然後更新自己的設定，至此整個故障轉移就完成了。 最後我們來看一下我們用 PHP 連線的測試： 連線 master\" 連線 master 就會發現，已經 slave1 變成現在的 master。 那我們最後把原本的 master 恢復，看看會發生什麼事情： 連線 master\" 連線 master 會發現因為該啟動 master，所以他還認為他是 master，但過一下下，在查看就正常顯示 slave1 為 master，舊的 master 就變成 slave。 Redis 常見錯誤問題 在學習的時候，有發現啟動 sentinel 的時候，會跳出 WARNING: Sentinel was not able to save the new configuration on disk!!!: Permission denied 錯誤訊息，後來再去翻 redis github 的 issus 才發現作者也有發現這個問題，且已經修復了，主要是權限的問題，以及要掛載目錄而非 conf 檔案。 redis WARNING 錯誤訊息 github issus\" redis WARNING 錯誤訊息 github issus ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:3:0","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"參考資料 Redis (六) - 主從複製、哨兵與叢集模式 ","date":"2022-04-19","objectID":"/docker-compose-redis-sentinel/:4:0","tags":["Redis","Docker","Sentinel","哨兵模式","實作"],"title":"Redis 哨兵模式 (Sentinel) 搭配 Docker 實作","uri":"/docker-compose-redis-sentinel/"},{"categories":["codenotes"],"content":"什麼是 Git ? 不管是不是工程師，只要常常需要使用電腦工作，每天一定都會新增、修改、刪除許多檔案，我們看到這張圖： 很多人的電腦裡面都有這樣的內容\" 很多人的電腦裡面都有這樣的內容 這張圖是一個菜鳥工程師在整理檔案時的方法，因為每一天都會對這份檔案做不同的處理，但為了保留以前的版本，所以也不會刪除舊的檔案，只好用日期或是版本來做分類，時間越久，檔案就累積越多，假如不小心刪除，也找不回來紀錄，也不清楚不同檔案的差異，所以有了 Git 這項工具。 Git 為分散式版本控制系統，是為了更好管理Linux內核而開發的。 Git 的優點：免費開源、速度快、檔案體積小、分散式系統。 Git 的缺點：指令繁雜，但可以透過 GUI 工具解決。 Git 會紀錄哪些資料：更動前 vs 更動後的程式碼、修改者、修改時間、修改原因（修改者需要自行撰寫 commit message）。 我們也常常聽到 GitHub or GitLab 那跟 Git 是一樣的東西嗎？ Ans：GitHub(GitLab) 是基於 Web 的平台，結合了 Git 的版本控制功能，為開發團隊提供了儲存、分享、發布和合作開發項目的中心化雲存儲的場所。 ","date":"2022-04-15","objectID":"/git/:1:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"Git 操作指令 Git 的操作指令繁多，包含環境類、查看類、提交類、分支類、遠端類、合併類、還原類等等，所以才有了 Git GUI 工具，筆者很推薦 Gitkraken，雖然需要付費，但真的很方便，畫面也很乾淨簡潔。如果是學生的話，還可以使用 GitHub Student Developer Pack 免費使用歐！ Git GUI 工具 (Gitkraken)\" Git GUI 工具 (Gitkraken) 接下來我們會依照環境類、查看類、提交類、分支類、遠端類、合併類、還原類依序下去介紹～ ","date":"2022-04-15","objectID":"/git/:2:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"環境類 使用每一個程式或工具，必須先把它安裝到自己電腦上對吧！但因為大家使用的系統都不一樣，所以這邊就不列出要怎麼進行安裝，可以參考 Git 安裝教學 當我們安裝好後，我們就可以一起進入 Git 的世界囉！ init 首先，找一個你要開始進行版本控制 (Git) 的資料夾， 使用： $ git init 要記得要到版本控制的資料夾目錄下才使用這個指令歐！ 使用完後，會看到跑出下面這些文字： Git init\" Git init 此外資料夾內也會多一個隱藏檔案 .git ，他是用來存放 git 的紀錄，所以不要亂刪除歐： $ tree -a -d . └── .git ├── hooks ├── info ├── objects │ ├── info │ └── pack └── refs ├── heads └── tags 回到剛剛圖片，它說明默認會使用 master 這個來作為初始分支，並記得要使用 git config 來做設定，那 git config 是要做什麼用的呢！？ config 在推送 Commit 的時候，會顯示使用者名稱以及電子郵件，所以要先在推送前設定好，這時就使用： $ git config --global user.name \"your name\" $ git config --global user.email \"your email\" 分別設定使用者名稱以及電子郵件，這樣共同使用版本控制的人，才分的出來誰是誰！ (若只要在單個專案下設定使用者名稱及電子郵件，就不需要設定 –global 參數) ","date":"2022-04-15","objectID":"/git/:2:1","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"查看類 status 我們剛剛已經設定好 config ，如果想查看檔案的 git 狀態，就使用： $ git status 可以查看現在資料夾內有哪些檔案還沒加入版本控制，或是已經加入但還沒 Commit 變成新版本。 Git status\" Git status 綠色代表已經加入版本控制但還沒有 Commit ，紅色代表尚未加入追蹤。 log 當我們想要查看 Commit 的幾個版本，或是是誰 Commit 的等等資訊，可以使用： $ git log Git log\" Git log 可以看到一串英文加數字，它是SHA-1 校驗碼也代表你推的這一個版本的識別 ID，也可以看到是由誰推送跟時間與推送的文字說明。 diff 當我們假設已經 Commit 後，想要比較不同版本內容的差異，就使用： $ git diff 116e 442c 116e 代表最新的版本，442c 代表上一個版本，可以看上面 log 的辨識 ID，因為校驗碼很長，最少需要前4個數字跟英文，才可以知道是哪一個版本。 Git diff\" Git diff 紅色代表最新版本因為我們是用 116e 最新版本來跟綠色上一個版本 442c 來做比較。 reflog 如果我們在操作 Git 的時候執行錯誤，需要回復到前幾個版本，但還想要查看歷史紀錄，如果我們使用前面說的 git log 是看不到已經舊的紀錄，這時要使用： $ git reflog Git reflog (圖一)\" Git reflog (圖一) Git log (圖二)\" Git log (圖二) 可以看到圖一是使用 reflog 就可以知道我們還原的紀錄，但使用 log 查看，會發現沒有辦法看到 test-2 的紀錄。 ","date":"2022-04-15","objectID":"/git/:2:2","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"提交類 add 當我們上面使用 git init 初始化資料夾後，還沒有開始進行版本控制，需要使用： $ git add . $ git add test.txt 將檔案加入版本控制的暫存區。它的格式是 git add [檔案名稱] ，如果想要把資料夾全部檔案都加入版本控制，可以使用 . 來加入。 commit 當我們新增完後，要將它提交出去，就要使用： $ git commit -m \"內容打這\" Git commit\" Git commit 我們可以在雙引號內輸入我們修改的內容，方便其他人了解該版本的差異。 ","date":"2022-04-15","objectID":"/git/:2:3","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"分支類 branch 我們專案初始化後，一開始都只會有一個 master 分支，如果想要新增分支，可以使用： $ git branch \"分支名稱\" 會將所在分支的檔案狀態複製到新增的分支上，當該分支改動時，不會影響到原本的分支。 Git branch\" Git branch checkout 如果想要切換不同版本或是分支，就可以使用： $ git checkout \"分支名稱/分支ID\" 來切換不同的分支或是以前的版本。 Git checkout\" Git checkout 如果想要同時建立分支並切換，可以使用： $ git chechout -b \"分支名稱\" -b 這個參數就等於是 git branch \"分支\" \u0026 git checkout \"分支\"。 Git checkout -b\" Git checkout -b ","date":"2022-04-15","objectID":"/git/:2:4","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"遠端類 clone 如果我們遠端上已經有版本庫，想要下載到本地端，就可以使用： $ git clone [遠端網址] 會在下指令的當前路徑下，下載整個遠端的專案。 remote 如果要新增遠端版本庫，就可以使用： $ git remote add [簡稱] [遠端網址] 取一個可以代表要新增的遠端 Git 版本庫簡稱。 Git remote\" Git remote 如果想要檢視已經設定好的遠端版本庫，就可以使用： $ git remote 他會列出每個遠端本版本庫的簡稱。 也可以使用 git remote -v 指令，會顯示 Git 用來讀寫遠端簡稱時所用的網址： Git remote -v\" Git remote -v push 當我們已經設定好遠端版本庫的位址，我們如果想要將本地端的專案版本庫放到遠端，就可以使用： $ git push [簡稱] [分支名稱] 將本地端版本庫推到遠端的版本庫。 Git push\" Git push 上面這張圖片，就是把本地端的 master 分支內容，推一份到 origin 這個地方 (可能是 GitHub 或公司內部 Git 伺服器)，並且在 origin 這個地方形成同名的 master 分支。 但很多人不知道的是，其實 push 指令的完整型態長這樣： $ git push origin master:master 意思就是「把本地的 master 分支內容，推一份到 origin 上，並且在 origin 上建立一個 master 分支」 如果我們把指令改為： $ git push origin master:dog 意思就會變成「把本地的 master 分支內容，推一份到 origin 上，並且在 origin 上建立一個 dog 分支」 pull 如果我們想要將遠端的專案 下載並合併 至本地端，就可以使用： $ git pull [簡稱] [分支名稱] 將遠端專案資料下載並合併到本地端。 Git pull\" Git pull fetch 如果我們單純只想要將遠端的專案 下載 至本地端，就可以使用： $ git fetch [簡稱] [分支名稱] 將遠端專案資料下載到本地端。 Git pull\" Git pull clone、pull、fetch 差異 差異 clone fetch pull 功能 會把遠端整份專案都下載到本地端 只會下載，並不會合併 會下載且合併檔案 補充說明 適用於專案一開始時使用，如果 clone 之後要再更新，通常是執行 git fetch or git pull 假設我遠端叫 orgin，當執行時，Git 會比對本地端與遠端，會「下載 origin 上有但本地端沒有的檔案下來」 pull 與 fetch 做的事情差不多，多了一個進行合併的功能 ","date":"2022-04-15","objectID":"/git/:2:5","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"合併類 merge 如果想要將不同分支內容合併，就可以使用： $ git merge [分支名稱] 像下面這張圖，我們將分支 123 合併到分支 master。(要記得先切換到要合併的主分支，才可以合併其他的分支進來) Git pull\" Git pull merge (fast-fastward) merge 有一個參數叫做 fast-fastward，我們先看圖片再來說明： Git merge fast-fastward 圖一 (CS Visualized: Useful Git Commands)\" Git merge fast-fastward 圖一 (CS Visualized: Useful Git Commands) Git merge no fast-fastward 圖二 (CS Visualized: Useful Git Commands)\" Git merge no fast-fastward 圖二 (CS Visualized: Useful Git Commands) 圖一是我們的 fast-fastward，也是 Git 預設的合併方式，當我們要將 dev 合併到 master，fast-fastward 會將 dev 分支的 commit 紀錄合併到 master 上，然而圖二是不使用 fast-fastward 方式，會保留 dev 分支上的 commit 紀錄，並在 master 上新增一個。 no fast-fastward 好處是可以完整保留每個分支的 commit 紀錄，壞處是假如 commit 紀錄只有一個，合併多次就會出現很多小叉路。要怎麽使用 no fast-fastward： $ git merge --no-ff [分支名稱] rebase (合併) 如果想要重新修改特定分支的「 基礎版本 」，要把另一個分支的變更，當成我這隻分支的基礎，就可以使用： $ git rebase [分支名稱] Git rebase (合併) (CS Visualized: Useful Git Commands)\" Git rebase (合併) (CS Visualized: Useful Git Commands) rebase (修改) 如果想要修改特定分支上任何一個版本資訊，就可以使用： $ git rebase -i [HEAD~?] 但要記得，如果再使用前，要先詢問是否有人正在使用此分支，因為 rebase 會改變歷史紀錄。 Git rebase (修改) (CS Visualized: Useful Git Commands)\" Git rebase (修改) (CS Visualized: Useful Git Commands) cherry-pick 如果想要從某個分支，拉幾個 Commit 進來該分支，就可以使用： $ git cherry-pick [分支ID] 但做此動作，需要解決修改後的版本衝突。 ","date":"2022-04-15","objectID":"/git/:2:6","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"還原類 reset 如果想要還原任意 Commit，就可以使用： $ git reset [HEAD~?] 會還原選擇的 Commit，且檔案還是維持最新版本。 reset 指令可以搭配參數使用，常見到的三種參數，方別是 --mixed、--soft、--hard，不同的參數執行之後會有稍微不太一樣的結果。 mixed 模式：--mixed 是預設的參數，如果沒有特別加其他參數，got reset 會使用 --mix 模式。這個模式會把暫存區的檔案丟掉，但不會影響到工作目錄的檔案，也就是說 Commit 拆出來的檔案會留在工作目錄(實體的檔案)，但不會留在暫存區。 soft 模式：這個模式下的 reset，工作目錄跟暫存區檔案都不會被丟掉，所以看起來只有 HEAD 的移動而已。也因此，Commit 拆出來的檔案會直接放在暫存區。 hard 模式：在這個模式下，不管是工作目錄以及暫存區的檔案都會丟掉。 以下用表格在整理一次： 模式 mixed 模式 soft 模式 hard 模式 工作目錄(實體的檔案) 不變 不變 丟掉 暫存區 丟掉 不變 丟掉 文字說明也不太懂對吧！沒錯我也是 😂，所以我整理了三種不同的範例，我們一起做看看吧！ 我們先開一個新專案，在 master 上面 commit 2 次，可以參考下方圖片： Git reset 示範\" Git reset 示範 我們用 git log 來看一下記錄： Git reset 示範 log 紀錄\" Git reset 示範 log 紀錄 都設定好後，我們要來測試每個參數的不同之處，先以預設的 --mixed 來測試： reset - mixed 我們下 git reset --minxed 按 Tab 可以看要還原的 commit，我們之後的測試都是還原到 24aeb0d -- [HEAD^] add a.txt 這個，來觀察 add b.txt 這個 commit 的變化。 Git reset mixed 模式\" Git reset mixed 模式 所以我們的指令是 git reset --mixed 24aebo4，我們再來觀看看看，檔案狀態也就是 b.txt 以及暫存區狀態。 Git reset mixed 模式\" Git reset mixed 模式 可以看到使用 --mixed 模式，檔案 b.txt 還會存在，只是移除暫存區。 reset - soft 我們指令是 git reset --soft 24aebo4： Git reset soft 模式\" Git reset soft 模式 可以看到使用 --soft 模式，檔案 b.txt 還會存在，且會在暫存區。 reset - hard 我們指令是 git reset --hard 24aebo4： Git reset hard 模式\" Git reset hard 模式 可以看到使用 --hard 模式，檔案 b.txt 不見了，所以也不會在暫存區。 revert 如果想要還原任意 Commit，但又想保留在歷史紀錄，就可以使用： $ git revert [HEAD~?] 會還原選擇的 Commit，檔案也會還原到舊的版本 reset 與 revert 差異 指令 reset revert 改變歷史狀態 是 否 說明 把目前狀態設定成某個指定的 Commit 狀態，通常適用於尚未推到遠端的 Commit 新增一個 Commit 來取消另一個 Commit 的內容，原本的 Commit 依舊會保留在歷史紀錄中。通常適用於已經推到遠端的 Commit ","date":"2022-04-15","objectID":"/git/:2:7","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"其他 tag 標籤是用於標記特定的點或是提交的歷史，通常會用來標記發佈版本的名稱或是編號，例如：v1.0。標籤看起來有點像是分支，但打上標籤的提交是固定的，不能隨意的變更位置。 Git 中有兩種標籤類型：輕量標籤(lightweight tag)和標示標籤(annotated tag)，他們有什麼區別呢？我們分別列出他們不同之處。 輕量標籤(lightweight tag) 不可以變更的暫時標籤 可以添加名稱 標示標籤(annotated tag) 可以添加打標籤者的名稱、email、日期 可以添加名稱 可以添加註解 可以添加簽名 一般情況下，標示標籤都會用在較為重要的提交上，如發布提交可以使用標示標籤來新增註解或簽名，另一方面，輕量標籤通常使用在本機端最為暫時性的使用或是一次性使用。 我們分別來看一下要如何新增輕量標籤(lightweight tag)以及標示標籤(annotated tag)吧！ 我們先隨意在分支上推一次 commit ，如下圖，讓我們等等有 commit 可以來新增標籤： 在隨意的分支推一個 commit\" 在隨意的分支推一個 commit 輕量標籤 使用 tag 且不帶其他的參數來下指令： $ git tag lightweight bc4c597 lightweight 是我們 tag 名稱，bc4c597 是剛剛 commit 的 SHA-1 接著我們使用 git show lightweight 來查看標籤： 輕量標籤 lightweight\" 輕量標籤 lightweight 可以發現因為我們使用「輕量標籤」，所以沒有存任何資訊，但可以在圖片第一行最後面看到我們使用的 tag。 標示標籤 我們一樣使用 tag，但後面可以加上 -a -m 參數： $ git tag annotated bc4c597 -a -m \"可以備註\" -a 參數是請 Git 幫我們建立有附註的標籤，後面的 -m 則是跟我們 commit 一樣可以來輸入訊息 接著我們使用 git show annotated 來查看標籤： 標示標籤 annotated\" 標示標籤 annotated 可以看到我們使用標示標籤，所以可以查看標籤是誰填寫、他的信箱、填寫時間以及他的備註內容。 官方文件對於這兩種標籤的說明： 有標示標籤主要用來做像是軟體版號之類的用途，而輕量標籤則是來於個人使用或暫時的標記用途。簡單來說，有標示標籤的好處是有更多關於這張標籤的資訊，假設不是很在乎這些資訊，使用一般的輕量標籤也是沒有問題的！ ","date":"2022-04-15","objectID":"/git/:2:8","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"Git 常見問題 Git 裡的 HEAD 是什麼？ HEAD 本身是一個指標，通常會指向某個本地端分支或是其他 Commit，所以也可以把 HEAD 當作目前所在的分支。 刪除合併後的分支會發生什麼事情嗎？ 分支本身就像指標或是貼紙一樣，貼在某個 Commit 上面，分支並不是目錄或是檔案，所以當我們刪除已經合併過的分支，不會造成檔案或目錄跟著被刪除。 ","date":"2022-04-15","objectID":"/git/:3:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"參考資料 什麼是 Git？為什麼要學習它？ Git：基本概念介紹與指令 [Git] 初始設定 連猴子都能懂的Git入門指南 Git教學】分支合併: merge 與 rebase 差異 Git 面試題 Reset、Revert 跟 Rebase 指令有什麼差別？ ","date":"2022-04-15","objectID":"/git/:4:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":null,"content":"本文章是使用 Node.js 來寫一個 Repository Restful API 的留言板，並且會使用 express 以及 sequelize (使用 Mysql)套件。 建議可以先觀看 Node.js 介紹 文章來簡單學習 Node 語言。 範例程式連結 點我 😘 版本資訊 macOS：11.6 node：v16.14.2 npm：8.5.0 Mysql：mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:0:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"實作 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"檔案結構 . ├── app.js ├── config │ └── config.json ├── controllers │ ├── auth.js │ ├── message.js │ └── reply.js ├── middleware │ └── index.js ├── migrations │ ├── 20220331054531-create-user.js │ ├── 20220401093019-create-message.js │ └── 20220404041905-create-reply.js ├── models │ ├── index.js │ ├── message.js │ ├── reply.js │ └── user.js ├── node_modules(以下檔案省略) ├── package-lock.json ├── package.json ├── repositories │ ├── auth.js │ ├── message.js │ └── reply.js └── router └── index.js 我們來說明一下上面的資料夾以及檔案各別功能與作用 app.js：程式的啟動入口，裡面會放置有關程式系統需要呼叫哪些套件等等。 config：放置資料庫連線資料 (使用 sequelize-cli 套件自動產生)。 controllers：商用邏輯控制。 middleware：用來檢查登入權限。 migrations：放置產生不同 Model 資料表 (使用 sequelize-cli 套件自動產生)。 models：定義資料表資料型態 (使用 sequelize-cli 套件自動產生)。 node_modules：放置下載使用的套件位置。 package.json/package-lock.json：專案資訊的重要檔案 (使用 npm init 自動產生)。 repositories：處理與資料庫進行交握。 router：設定網站網址路由。 以下詳細說明部分，只會說明 app.js、config、controllers、middleware、migrations、models、repositories、router (介紹會依照程式流程來介紹)。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:1","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"config { \"development\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" }, \"test\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" }, \"production\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" } } 由 sequelize-cli 套件自動產生，可以依照不同程式狀態(開發 development、測試 test、上線 production)來修改連線時的參數。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:2","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"migrations 檔案基本上都雷同，舉其中一個為說明。migrations 也是由 sequelize-cli 套件自動產生，相關指令會統一放在最後。 20220401093019-create-message.js \"use strict\";module.exports = {async up(queryInterface, Sequelize) {await queryInterface.createTable(\"message\", {id:{allowNull:false,autoIncrement:true,primaryKey:true,type:Sequelize.INTEGER,},user_id:{allowNull:false,type:Sequelize.INTEGER,references:{model:\"user\",key:\"id\",},},content:{allowNull:false,type:Sequelize.STRING,},version:{type:Sequelize.INTEGER,defaultValue:0,},createdAt:{allowNull:false,type:Sequelize.DATE,},updatedAt:{allowNull:true,type:Sequelize.DATE,},deletedAt:{allowNull:true,type:Sequelize.DATE,},});},async down(queryInterface, Sequelize) {await queryInterface.dropTable(\"message\");},}; 這個檔案的格式也是透過指令產生，會有 up 跟 down，up 就是執行指令後會產生什麼，主要都會是新增資料表或是修改資料表，down 則是回復的功能，可以將資料表給 dropTable 。我們主要會修改的地方是 createTable 內的資料，裡面的資料代表資料表的欄位，以下列出常用的格式： allowNull：是否為空值 autoIncrement：自動累加 primaryKey：主鍵 type：裡面就放欄位類型，例如 INTEGER、STRING、DATE等等 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:3","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"app.js \"use strict\"; const express = require(\"express\"); const sessions = require(\"express-session\"); const app = express(); const port = 8888; // 設定 Session const oneDay = 1000 * 60 * 60 * 1; app.use( sessions({ secret: \"mySecret\", name: \"user\", saveUninitialized: false, rolling: true, cookie: { maxAge: oneDay }, resave: false, }) ); // 註冊路由 app.use(\"/api/v1\", require(\"./router\")); // 檢查是否有table，沒有就建立 // const Message = require(\"./models\").message; // const User = require(\"./models\").user; // Message.sync(); // User.sync(); // 開啟監聽 app.listen(port, console.log(\"啟動 Server,Port:\" + port)); 先引入會使用的套件 (express：node web 框架、express-session：session 套件) 設定 app 為 express() 實例，port 為 8888。 設定 session 失效時間、名稱等設定。 secret(必要)：用來簽章 sessionID 的cookie, 可以是一secret字串或是多個secret組成的一個陣列。 name：在response中，設定的 sessionID cookie 名字。預設是 connect.sid。 saveUninitialized：強制將未初始化的session存回 session store，未初始化的意思是它是新的而且未被修改。 rolling：強制在每一次回應時，重新設置一個sessionID cookie。 cookie：設定sessionID 的cookie相關選項。 resave：強制將session存回 session store, 即使它沒有被修改。 註冊路由，連線 http://127.0.0.1/api/v1 後面會導向 router 檔案。 註解部分為可以每次啟動後先檢查是否有table，沒有就建立。 開啟 port(8888) 監聽。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:4","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"router \"use strict\"; const express = require(\"express\"); const middleware = require(\"../middleware\"); const router = express(); const { register, login, lojsut } = require(\"../controllers/auth\"); const { getAllMessage, getMessage, createMessage, updateMessage, deleteMessage, } = require(\"../controllers/message\"); const { createReply, updateReply, deleteReply, } = require(\"../controllers/reply\"); // 註冊、登入、登出 router.post(\"/register\", express.json(), register); router.post(\"/login\", express.json(), login); router.post(\"/lojsut\", lojsut); // 查詢留言 router.get(\"/message\", getAllMessage); router.get(\"/message/:message_id\", getMessage); //需要驗證才可以使用（新增留言、修改留言、刪除留言、新增留言回覆、修改留言回覆、刪除留言回覆） router.use(middleware); router.post(\"/message\", express.json(), createMessage); router.patch(\"/message/:message_id\", express.json(), updateMessage); router.delete(\"/message/:message_id\", deleteMessage); router.post(\"/message/:message_id\", express.json(), createReply); router.patch(\"/message/:message_id/:reply_id\", express.json(), updateReply); router.delete(\"/message/:message_id/:reply_id\", deleteReply); module.exports = router; 設定路由，分別是註冊、登入、登出、新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function。express.json() 函數是為了要讓 body-parser 解析帶有 JSON 傳入後面的 controller，其中比較特別的是因為新增留言、修改留言、刪除留言、新增留言回覆、修改留言回覆、刪除留言回覆需要登入後才可以使用，所以多一個 middleware 來驗證是否登入。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:5","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"middleware \"use strict\"; module.exports = (req, res, next) =\u003e { if (!req.session.userid) { return res.status(401).json({ message: \"用戶需要認證\" }); } next(); }; 使用 session 來驗證是否有登入。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:6","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"models 會放置與資料表資料型態有關的資訊，其中 index.js 是由 sequelize-cli 套件自動產生，用來讀取目前寫在 config 的連線設定檔等資訊。 index.js \"use strict\"; const fs = require(\"fs\"); const path = require(\"path\"); const Sequelize = require(\"sequelize\"); const basename = path.basename(__filename); const env = process.env.NODE_ENV || \"development\"; const config = require(__dirname + \"/../config/config.json\")[env]; const db = {}; let sequelize; if (config.use_env_variable) { sequelize = new Sequelize(process.env[config.use_env_variable], config); } else { sequelize = new Sequelize( config.database, config.username, config.password, config ); } fs.readdirSync(__dirname) .filter((file) =\u003e { return ( file.indexOf(\".\") !== 0 \u0026\u0026 file !== basename \u0026\u0026 file.slice(-3) === \".js\" ); }) .forEach((file) =\u003e { const model = require(path.join(__dirname, file))( sequelize, Sequelize.DataTypes ); db[model.name] = model; }); Object.keys(db).forEach((modelName) =\u003e { if (db[modelName].associate) { db[modelName].associate(db); } }); db.sequelize = sequelize; db.Sequelize = Sequelize; module.exports = db; user.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class user extends Model { static associate(models) { user.hasMany(models.message, { foreignKey: \"user_id\", }); } } user.init( { username: { type: DataTypes.STRING, unique: true, }, password: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"user\", } ); return user; }; 此為 user 資料表的欄位資料，有預設的 init 初始化，比較特別的是如果有用到關聯性的外鍵等等要記得在 associate 做設定，user.hasMany(models.message,{foreignKey: \"user_id\",}) 代表 user 這張表可以有很多個 message，其 message 外鍵是 user_id。 paranoid：代表會執行軟刪除而不是硬刪除，但必須要多一個 deletedAt 來存放軟刪除時間。 freezeTableName：因為 sequelize 會自動再產生資料表時加上複數，如果不想要就必須使用它讓 sequelize 不會自動加入 s (複數)。 modelName：此 model 名稱。 message.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class message extends Model { static associate(models) { message.hasMany(models.reply, { foreignKey: \"message_id\", }); message.belongsTo(models.user, { foreignKey: \"user_id\", }); } } message.init( { user_id: { type: DataTypes.INTEGER, allowNull: false, }, content: { type: DataTypes.STRING, allowNull: false, }, version: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"message\", } ); return message; }; 此為 message 資料表的欄位資料，associate 設定有 message.hasMany(models.reply,{foreignKey: \"message_id\",}) 代表 message 這張表可以有很多個 reply，其 reply 外鍵是 message_id。以及 message.belongsTo(models.user, {foreignKey: \"user_id\",}); 代表 message 存在一對一的關係，外鍵是 user_id。 reply.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class reply extends Model { static associate(models) { reply.belongsTo(models.message, { foreignKey: \"message_id\", }); reply.belongsTo(models.user, { foreignKey: \"user_id\", }); } } reply.init( { message_id: { type: DataTypes.INTEGER, allowNull: false, }, user_id: { type: DataTypes.INTEGER, allowNull: false, }, content: { type: DataTypes.STRING, allowNull: false, }, version: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"reply\", } ); return reply; }; 此為 reply 資料表的欄位資料，associate 設定有reply.belongsTo(models.message, {foreignKey: \"message_id\",}); 代表 reply 存在一對一的關係，外鍵是 message_id，以及 reply.belongsTo(models.user, {foreignKey: \"user_id\",}); 代表 reply 存在一對一的關係，外鍵是 user_id。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:7","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"controllers 我們遵循 MVC 的設計規範，所有的商用邏輯都會放在 controller 內，repository 只負責與資料庫進行交握。 auth.js const Auth = require(\"../repositories/auth\"); const bcrypt = require(\"bcrypt\"); // 註冊 const register = async (req, res) =\u003e { if (!req.body.username || !req.body.password) { return res.status(400).json({ user: \"沒有正確輸入帳號或密碼\" }); } const salt = await bcrypt.genSalt(10); const bcrypt_password = await bcrypt.hash(req.body.password, salt); user = await Auth.register(req.body.username, bcrypt_password); if (!user[1]) { return res.status(400).json({ user: \"username已存在\" }); } return res.status(201).json({ user: user }); }; // 登入 const login = async (req, res) =\u003e { if (!req.body.username || !req.body.password) { return res.status(400).json({ user: \"沒有正確輸入帳號或密碼\" }); } user = await Auth.login(req.body.username, req.body.password); if (!user) { return res.status(400).json({ user: \"帳號或密碼錯誤\" }); } session = req.session; session.userid = user.id; return res.status(200).json({ user: \"登入成功\" }); }; // 登出 const logout = async (req, res) =\u003e { session = req.session; session.destroy(); return res.status(200).json({ user: \"登出成功\" }); }; module.exports = { register, login, logout, }; 主要有3 個部份，註冊、登入、登出： 註冊：會先驗證是否正確輸入資料(包含欄位是否錯誤等)，如果有錯，就會回應 400 以及沒有正確輸入帳號或密碼。接下來會使用到 bcrypt 來幫密碼進行加密處理，再把加密後的密碼以及帳號丟到 Auth.register repository 來進行資料庫的存取，如果錯誤會回應 400 以及 username 已存在，成功會回應 201 以及新增的帳號資訊。 登入：一樣會先檢查輸入資料，接著把資料丟到 Auth.login repository 來進行資料庫的驗證，如果錯誤會回應 400 以及帳號或密碼錯誤，成功會回應 200 以及登出成功。 登出：將 session 給清除，然後回應 200 以及登出成功。 message.js (由於內容較多，所以依照功能拆分後說明) 查詢留言功能 const Message = require(\"../repositories/message\"); const Reply = require(\"../repositories/reply\"); // 查詢所有留言 const getAllMessage = async (req, res) =\u003e { message = await Message.getAll(); return res.status(200).json({ message: message }); }; //查詢{id}留言 const getMessage = async (req, res) =\u003e { if (!(message = await Message.get(req.params.message_id))) { return res.status(404).json({ message: \"找不到留言\" }); } return res.status(200).json({ message: message }); }; 先載入要使用的 repository ，查詢所有留言會使用 Message.getAll() repository 來進行資料庫的讀取，會回應 200 以及查詢內容，若是尚未有留言則會顯示空陣列。查詢{id}留言會將 req.params.message_id 丟到 Message.get repository 來進行資料庫的讀取，如果錯誤會回應 404 以及 找不到留言，成功會回應 200 以及查詢內容。 新增留言功能 //新增留言 const createMessage = async (req, res) =\u003e { if (!req.body.content || req.body.content.length \u003e 20) { return res.status(400).json({ message: \"沒有輸入內容或長度超過20個字元\" }); } message = await Message.create(req.session.userid, req.body.content); return res.status(201).json({ message: message }); }; 新增留言會先檢查輸入內容是否為空以及不能大於20個字元，如果錯誤就回應 400 以及沒有輸入內容或長度超過20個字元，再將 req.session.userid、req.body.content 丟到 Message.create repository 來進行資料庫的存取，成功會回應 201 以及新增的留言。 修改留言功能 //修改留言 const updateMessage = async (req, res) =\u003e { if (!(message = await Message.get(req.params.message_id))) { return res.status(404).json({ message: \"找不到留言\" }); } if (!req.body.content || req.body.content.length \u003e 20) { return res.status(400).json({ message: \"沒有輸入內容或長度超過20個字元\" }); } if ( (await Message.update( req.params.message_id, req.session.userid, req.body.content, message[\"version\"] )) == \"0\" ) { return res.status(400).json({ message: \"修改留言失敗\" }); } return res.status(200).json({ message: \"修改留言成功\" }); }; 修改留言因為需要先從資料中取得 version 來檢查樂觀鎖，所以會先將 req.params.message_id 丟到 Message.get repository 來進行資料庫的查詢，錯誤會回應 404 以及找不到留言。 先檢查輸入內容是否為空以及不能大於20個字元，如果錯誤就回應 400 以及沒有輸入內容或長度超過20個字元，再將 req.params.message_id、req.session.userid、req.body.content、message[\"version\"] 丟到 Message.update repository 來進行資料庫的更新，錯誤會回應 400 以及修改留言失敗，成功會回應 200 以及修改留言成功。 刪除留言功能 //刪除留言 const deleteMessage = async (req, res) =\u003e { if (!(await Message.delete(req.params.message_id, req.session.userid))) { return res.status(400).json({ message: \"刪除留言失敗\" }); } // 刪除留言時同步刪除所有回覆 await Reply.deleteMessage(req.params.message_id); return res.status(204).json({ message: \"刪除留言成功\" }); }; 刪除留言會將 req.params.message_id、req.session.userid 丟到 Message.delete repository 來進行資料庫的軟刪除，錯誤會回應 400 以及刪除留言失敗，因為我們刪除留言後，不能在對該留言進行回覆的任何功能，所以一同軟刪除所有的回覆，成功後會回應 204 以及刪除留言成功。 reply.js (由於內容較多，所以依照功","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:8","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"repositories 此會放置與資料庫進行交握的程式。 auth.js const User = require(\"../models\").user; const bcrypt = require(\"bcrypt\"); const auth = { // 註冊 async register(username, bcrypt_password) { return await User.findOrCreate({ where: { username: username }, defaults: { username: username, password: bcrypt_password }, }); }, // 登入 async login(username, password) { const user = await User.findOne({ where: { username: username } }); if (user) { return (await bcrypt.compare(password, user.password)) ? user : false; } }, }; module.exports = auth; auth 內主要有兩個與資料庫進行互動，分別是，註冊以及登入，註冊會將傳入的帳號以及加密過後密碼使用 User.findOrCreate 來進行查詢或新增，如果帳號不存在才會進行新增動作。登入會將傳入的帳號及密碼使用 User.findOne 來檢查是否存在，如果存在再檢查密碼與資料庫是否正確。 message.js const Message = require(\"../models\").message; const Reply = require(\"../models\").reply; const repository = { async getAll() { return await Message.findAll({ include: { model: Reply } }); }, async get(message_id) { return await Message.findOne({ include: { model: Reply, }, where: { id: message_id }, }); }, async create(user_id, content) { return await Message.create({ user_id: user_id, content: content }); }, async update(message_id, user_id, content, version) { return await Message.update( { content: content, version: version + 1, }, { where: { id: message_id, user_id: user_id, version: version, }, } ); }, async delete(message_id, user_id) { return await Message.destroy({ where: { id: message_id, user_id: user_id }, }); }, }; module.exports = repository; message.js 裡面有會查詢全部留言、查詢{id}留言、新增留言、修改{id}留言、刪除{id}留言等，以下會說明各別負責功用： 查詢全部留言 getAll()：使用 Message.findAll 來顯示查詢結果，並且 include model Reply 回覆內容。 查詢{id}留言 get()：使用 Message.findOne 查詢 message.id 等於 message_id 的結果，並且 include model Reply 回覆內容。 新增留言 create()：使用 Message.create 新增 message.user_id 以及 message.content。 修改{id}留言 update()：使用 Message.update 更新 content 以及 version，且 message.id 要等於 message_id 及 message.user_id 等於 user_id 及 message.version 等於 version。 刪除{id}留言 delete()：使用 Message.destroy 刪除符合 message.id 等於 message_id 及 message.user_id 等於 user_id。 reply.js const Message = require(\"../models\").message; const Reply = require(\"../models\").reply; const reply = { async get(reply_id, message_id) { return await Reply.findOne({ where: { id: reply_id, message_id: message_id }, }); }, async create(message_id, user_id, content) { is_exist = await Message.findOne({ where: { id: message_id }, }); if (is_exist) { return await Reply.create({ message_id: message_id, user_id: user_id, content: content, }); } }, async update(reply_id, message_id, user_id, content, version) { return await Reply.update( { content: content, version: version + 1, }, { where: { id: reply_id, message_id: message_id, user_id: user_id, version: version, }, } ); }, async delete(reply_id, message_id, user_id) { return await Reply.destroy({ where: { id: reply_id, message_id: message_id, user_id: user_id, }, }); }, async deleteMessage(message_id) { return await Reply.destroy({ where: { message_id: message_id, }, }); }, }; module.exports = reply; reply.js 裡面有會新增回覆、修改{id}回覆、刪除{id}回覆等，除此之外還多了兩個 get、deleteMessage 用來取得 version 樂觀鎖以及同步刪除回覆功能，那以下會說明各別負責功用： 新增回覆 create()：因為要先確認留言是否被刪除，所以先使用 Message.findOne 檢查留言是否被刪除，在用 Reply.create 新增 reply.message_id 跟 reply.user_id 以及 reply.content。 修改{id}回覆 update()：使用 Reply.update 更新 content 以及 version，且 reply.id 要等於 reply_id 及 reply.message_id 等於 message_id 及 reply.user_id 等於 user_id 及 reply.version 等於 version。 刪除{id}回覆 delete()：使用 Reply.destroy 刪除符合 reply.id 等於 reply_id 跟 reply.message_id 等於 message_id 及 reply.user_id 等於 user_id。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:9","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"常用指令 (sequelize-cli) sequelize db:migrate：將資料表依照 up 內容執行(migrate 檔案)。 sequelize db:migrate:undo:all：將資料表依照 down 內容執行(migrate 檔案)。 sequelize db:seed：產生假資料 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:2:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"Postman 測試 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 成功 註冊 成功\" 註冊 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:1","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 失敗(無輸入) 註冊 失敗(無輸入)\" 註冊 失敗(無輸入) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:2","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 失敗(已經註冊過) 註冊 失敗(已經註冊過)\" 註冊 失敗(已經註冊過) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:3","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"登入 - 成功 登入 成功\" 登入 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:4","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"登入 - 失敗 登入 失敗\" 登入 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:5","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢全部留言 - 成功(無資料) 查詢留言 成功(無資料)\" 查詢留言 成功(無資料) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:6","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢全部留言 - 成功(有資料) 查詢留言 成功(有資料)\" 查詢留言 成功(有資料) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:7","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢{id}留言 - 成功 查詢{id}留言 成功\" 查詢{id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:8","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢{id}留言 - 失敗 查詢{id}留言 失敗\" 查詢{id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:9","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增留言 - 成功 新增留言 成功\" 新增留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:10","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增留言 - 失敗 新增留言 失敗\" 新增留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:11","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}留言 - 成功 修改 {id}留言 成功\" 修改 {id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:12","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}留言 - 失敗 修改 {id}留言 失敗\" 修改 {id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:13","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}留言 - 成功 刪除 {id}留言 成功\" 刪除 {id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:14","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}留言 - 失敗 刪除 {id}留言 失敗\" 刪除 {id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:15","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增回覆 - 成功 新增回覆 成功\" 新增回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:16","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增回覆 - 失敗 新增回覆 失敗\" 新增回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:17","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}回覆 - 成功 修改 {id}回覆 成功\" 修改 {id}回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:18","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}回覆 - 失敗 修改 {id}回覆 失敗\" 修改 {id}回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:19","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}回覆 - 成功 刪除 {id}回覆 成功\" 刪除 {id}回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:20","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}回覆 - 失敗 刪除 {id}回覆 失敗\" 刪除 {id}回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:21","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"參考資料 Node.js 官網 Sequelize 透過 sequelize 來達成 DB Schema Migration How to create JOIN queries with Sequelize ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:4:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"什麼是 Node.js ? Node.js 是能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台執行環境。 Node.js 的出現，讓前端網站開發人員可以使用 JaveScript 來做後端或是系統層面的工作。讓前端開發網站開發人員使用已懂的 JavaScript 語言就可以自行設定網站伺服器。 Node.js 採用 Google 開發的 Chrome V8 JavaScript 引擎和 libuv 函式庫，可以用指令去執行 JavaScript，使用非阻塞輸入輸出、非同步、事件驅動等技術來提高效能，可最佳化應用程式的傳輸量和規模。這些技術通常用於資料密集的即時應用程式。 主要的 Node.js 組件 (An Intro to Node.js That You May Have Missed)\" 主要的 Node.js 組件 (An Intro to Node.js That You May Have Missed) 其他開源、低級組件，主要用 C/C++ 編寫： c-ares : 用於非同步 DNS 請求的 C 函式庫，用於 Node.js 中的一些 DNS 請求。 http-parser：一個輕量級的 HTTP 請求/回應解析器。 OpenSSL：一個著名的通用密碼庫。用於 tls 和 cryto 模組。 zlib：無損數據壓縮庫。 Node.js 能快速的原因是因為他對資源的調校不同，當程式收到一筆連線， 相較於 PHP 的每次連線都會新生成一個執行緒，當連線數量暴增時很快就會消耗掉系統的資源，並且容易產生阻塞 (block)， 而 Node.js 則是會通知作業系統透過 epoll、kqueue、/dev/poll、select 等將連線保留，並放入 heap 中配置，先讓連線進入休眠 (Sleep) 狀態，等系統通知才觸發連線的 callback。 這種處理方式只會佔用記憶體，並不會使用到 CPU 資源。另外因為 JavaScript 語言的特性，每一個 request 都會有一個 callback，可以避免發生阻塞的狀況發生。 以下會先從非阻塞輸入輸出、非同步，再談到事件驅動。 ","date":"2022-03-30","objectID":"/node/:1:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"非阻塞 (non-blocking) 輸入輸出(I/O) 是程式跟系統記憶體或網路的互動，例如發送 HTTP 請求、對資料庫CRUD 操作等等。 以網站開發者角度來看，大部分的網站程式都不需要太多的 CPU 計算，反而是在等待大量的 I/O 處理完畢 (HTTP 請求、資料庫的取得資料或是更新資料等)，所以處理 I/O 的速度會是網頁程式效能的關鍵。 那要怎麼才能讓等待 I/O 的時間，不要卡住後續的程式碼呢？可以讓程式一邊等 I/O 處理，一邊繼續執行其他部分的程式碼，主要有兩種方法： 多執行緒 (multi-threaded)：使用阻塞 (blocking) I/O 的設計。 單執行緒 (single-threaded)：使用非阻塞 (non-blocking) I/O 的設計 + 非同步 (asynchronous) 處理。 阻塞就是 I/O 的處理阻擋了其他後續程式碼的執行。舉個例子： 阻塞 (blocking) 非阻塞 (non-blocking) 阻塞後續程式碼的執行，就好像是我們去附近買烤肉，交給老闆後，為了想吃到熱騰騰的食物，所以只能留在原地，不能先去其他地方 非阻塞不會阻擋後續程式碼的執行，就好像是我們去百貨公司美食街點餐，點完餐後會拿到一個呼叫器，就可以先離開，等到呼叫器響了再回去拿即可 像是 Python、Ruby 等語言是使用多執行緒 (multi-threaded)，使用阻塞 I/O ： 程式會等網路或是記憶體的作業結束後才會繼續往下，等待時間這個作業中的執行緒不會去做其他事情。 如果想要達到『等待 I/O 期間不要卡住其他程式碼』，的做法就是新開一個執行緒，直到任務完成，再告訴主執行緒說( 我完成囉！) 即可。 Node.js 使用單執行緒 (single-threaded) ，非阻塞 I/O + 非同步函式： Node.js 使用非阻塞設計，那要怎麼去操作資料庫或是 HTTP 請求的輸入輸出呢？就要透過非同步 (asynchronous) 來處理囉！ ","date":"2022-03-30","objectID":"/node/:1:1","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"非同步 (asynchronous) 非同步也可以稱為異步，它的作用就是讓程式不要被阻擋等 I/O 處理完，才可以跑下一行程式碼，是直到函式中的 callback 被呼叫的時候再執行後續要做的事情。 同步 vs. 非同步 非同步 (asynchronous) 可以想像一下你去咖啡廳買拿鐵跟黑咖啡，可能會發生的情況是： 你點了拿鐵跟黑咖啡 店員在收銀機上輸入點餐內容 店員請同事 A 準備拿鐵、請同事 B 準備黑咖啡，並告知做完後，要提醒店員 黑咖啡製作會比較快，B 同事會先完成，而剛好店員剛幫你結帳完沒事，所以把黑咖啡拿給你 拿鐵製作包含較多步驟，花費時間較久，等 A 同事完成後，店員剛好沒事，所以把拿鐵拿給你 可以看到，櫃檯店員一次只能做一件事情，但為了節省時間，店員將工作分配給其他同事，在下完指令後，店員會繼續幫你結帳，等同事們各自完成後會告知店員，店員在依序把飲料交給你 - 最終等待時間減少，也不會浪費閒置的資源，這就是現實生活中非同步的情況。 同步 (synchronous) 一樣我們點了拿鐵跟黑咖啡，換成同步的話： 店員在收銀機上輸入點餐內容 店員請同事 A 開始準備拿鐵 A 同事準備完拿鐵，店員轉交給你 店員請同事 B 開始準備黑咖啡 B 同事準備完黑咖啡，店員交給你 店員幫你刷載具、打統編、找錢等等 同樣的餐點內容，如果是同步處理，代表要等每一件事情做完，才可以做下一步。也就是說同事 A 完成拿鐵後，店員才請 B 同事準備黑咖啡。相對於非同步來說，會花費不少時間以及浪費不少閒置資源。 從咖啡店的例子中可以發現： 櫃檯店員手上一次能做的事情只有一件 (Single thread 單執行緒)，只是在非同步的例子中，將製作咖啡的事情委派給其他同事處理，讓自己可以繼續幫你結帳，來提高效率 — JavaScript 是 Single thread，一次只能做一件事情。 在非同步的例子中，櫃檯店員將製作咖啡的事情委派出去，其實店員也不知道哪一個任務會先被完成，但店員還是可以繼續完成結帳的任務，不會因為同事 A、B 還在製作咖啡，就不能接下去動作 (non-blocking) — JavaScript 一次只能做一件事，但藉由 Node 提供的 API 協助，在背後處理這些事件 (同事在背後製作咖啡)，可以等待製作同時，不會被阻塞 (blocking) 到下一件事情的執行。 非同步的例子中，店員委派事情的流程很簡單：就是請同事完成製作咖啡 (event) + 在收到同事通知完成後接手咖啡，並轉交給你 (callback function) — 若是採用非同步處理，會有 callback function 來指定事件完成後要接續做什麼：它不會立即被執行，而是等待委託的事情被完成後才觸發。 當同事 A、B 分別通知完成後，就會依序把咖啡放在店員的旁邊排成一排 (event queue)。想向店員有一個小助手 (event loop) ，他的工作內容是確認店員結帳完了沒有：如果結帳完了，就會把隊伍中第一杯咖啡叫給店員，讓店員交給你 (觸發 callback function) ; 如果店員還在結帳，就會讓隊伍中的咖啡擺在旁邊繼續等待。 JaveScript 實現非同步的方法不斷演進著：從 callback、promise 到最新的 async-await 函式。 Callback 什麼是 Callback 假設有 A、B、C 三件工作，其中 B 必須等待 C 做完才能執行。大部份的人幾乎都是做 A，再做 C，等待 C 做完以後最後做 B。但對於可多工的人來說，卻可能是同時做 A 與 C（多工），等待 C 完成後做 B。 Callback function 是一個被作為參數帶入另一個函式中的「函式」，這個被作為參數帶入的函式將在「未來某個時間點」被呼叫和執行 — 這是處理非同步事件的一種方式。 再次舉 A、B、C 三件工作的例子，其中 B 必須等待 C 做完才能執行，於是我們將 B 放到 C 的 callback 中，讓宿主環境在收到 C 完成的回應時後 B 放到佇列中準備執行。 doA(); doC(function() { doB(); }); 常見的例子： 使用瀏覽器所提供的 setTimeout()或是 setInterval() setTimeout(() =\u003e { console.log('這個訊息將在三秒後被印出來') }, 3000) 提供一個匿名函式作為參數帶入 setTimeout() 函式中，目的就是請 setTimeout() 在未來某個時間點（三秒後）呼叫和執行這個匿名函式。 DOM 的事件監聽 const btn = document.querySelector('button') btn.addEventListener('click', callbackFunctionName) callbackFunctionName 做為參數被帶入 addEventListener() 中，callbackFunctionName 不會立即被執行，而是未來按鈕被點擊時才會執行。 Callback 主要有一個缺點：回呼地獄 回呼地獄 (Callback Hell) 回呼地獄 (Callback Hell) 又稱為「毀滅金字塔」，指的是層次太深的巢狀 Callback，讓程式變的更複雜且難以預測或是追蹤。 向遠端伺服器發出請求並獲得資訊後，執行 Callback，再發出請求，獲得資訊後執行 Callback，再發出請求，獲得資訊後執行 Callback，就會不小心一層包一層，變成所謂的 Callback Hell。 doA(function() { doB(); doC(function() { doD(); }); doE(); }); doF(); 缺點： 可讀性低：如果程式碼出錯，要回頭慢慢找錯誤的地方 可維護性低：如果要修改其中一組函式，牽一髮而動全身 那在同步執行情況下，可以使用 try...catch 來捕捉錯誤訊息，但如果是在非同步情況下，要怎麼處理錯誤或是例外訊息呢！？ 主要有兩種方式： 分別回呼 (Split Callback) 分別的回呼要設定兩個 Callback，一個用於成功通知，另一個則用於錯誤通知。如下，第一個參數是用於成功的 Callback，第二個參數是用於失敗的 Callback： function success(data) { console.log(data); } function failure(err) { console.error(error); } ajax('http://sample.url', success, failure); 那如果在 Callback 中發生錯誤，要怎麼辦呢!? function success(data) { console.log(x); } function failure(err) { console.error(error); } ajax('http://sample.url', success, failure); // Uncaught (in promise) ReferenceError: x is not defined 會直接報錯，並不會進入到 failure 這個 Callback 裡面，也就是說，如果是在 Callback 內發生錯誤，是不會被捕捉到的。 錯誤優先處理 (Error-First Style) Node.js 的 API 常見這樣的設計方式，第一個參數是 error ，第二個參數是回應的資料 (data)。檢查 error 是否有值或是 true，否則就接續處理 data。 function response(err, data) { if(err) { console.error(err); } else { console.log(data); } } ajax('http://sample.url', response); 接下來我們來看 Promise，可以解決 callback 可讀性低的 Callback Hell 問題。 Promise Promise：Callback 以外的另一種方式來處理非同步事件，且可讀性與可維護性比 Callback 好很多。 Promise 是一個物件，代表著一個尚未完成，但最終會完成的一個動作 - 在一個非同步處理流程中，它只是一個暫存的值。 我們一樣來說剛剛咖啡店的例子： 當我們點完拿鐵跟黑咖啡後，店員會給你一張印有號碼的收據，然後告訴你等等聽到號碼，就可以來領咖啡了，而這張收據就是 Promise，代表這個任務完成後，就可以接著執行接下來的動作了。 在等待過程中，其實無法百分百確定最後一定會拿到咖啡 (Promise) ; 店員可能順利做完咖啡交到你手上 (Resolved) ; 可能牛奶或是咖啡豆沒了，所以店員告訴你今天做不出來咖啡 (Rejected)。 Promise 就像上面的例子中，會處在三個任意階段中： Pedning：等待事情完成中，但不確定最終會順利完成或失敗 Resolved（或稱 Fulfilled）：代表順利完成了，並轉交結果 Rejectesd：代表失敗了，並告知失敗原因 const getData = new Promise((resolve, reject) =\u003e { // 製作咖啡..... // 作業完成，並回傳錯誤訊息時 if (error) { return reject('牛奶或是咖啡豆沒了') } // 作業成功完成 resolve(","date":"2022-03-30","objectID":"/node/:1:2","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"事件驅動 (event-driven) 在講事件驅動前，我們先來了解一下什麼是事件： 事件 (event) 事件是指用戶或是系統作出的動作，例如使用者點選按鈕，或是檔案讀取完成、某種錯誤產生等等，都叫做事件。 事件驅動 (event-driven) 事件驅動是一種程式執行模型，表示程式的進行是依據事件的發生而定，監聽到事件就處理、處理完就執行 callback ，透過不斷的監聽跟回應事件執行程式。 而事件驅動在不同的地方有不同的實現。瀏覽器 (前端) 和 Node.js (後端) 基於不同的技術實現了各自的事件迴圈。就 Ndoe.js 來說，事件就是交給 libuv 去處理 ; 至於瀏覽器的事件迴圈在 HTML 5 的規範中有定義。 事件迴圈 (event loop) 因為 Node.js 只有一個執行緒，所以當 libuv 把非同步事件處理完後，callback 要被丟回應用程式中排隊，等待主執行緒的 stack 為空的時候，才會開始執行。這個排隊的地方就是事件佇列 (event queue)。 libuv 會不斷檢查有沒有 callback 需要被執行，有的話分配到主執行緒結束手邊的程式後處理，因此這個過程稱為 『事件迴圈』。 事件迴圈(event loop) (Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈)\" 事件迴圈(event loop) (Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈) libuv 事件迴圈有哪些階段呢？ libuv 事件迴圈 (nexocode)\" libuv 事件迴圈 (nexocode) libuv 的事件迴圈共有六個階段，每個階段的作用如下： Timers：等計時器 (setTimeout、setInterval) 的時間一到，會把他們的 callback 放到這裡等待執行。 Pending callbacks：會把作業系統層級的錯誤給callback (TCP errors、sockets 連線被拒絕)。 Idle, prepare：內部使用。 Poll：最重要的一個階段。 如果 Queue 不為空，依次取出 callback 函數執行，直到 Queue 為空或是抵達系統最大限制。 如果 Queue 為空但有設置 「setImmediate」，就進入 check 階段。 如果 Queue 為空但沒有設置 「setImmediate」，就會在 Poll 階段等到直到 Queue 有東西或是 Timers 時間抵達。 Check：處理 setImmediate 的 callback。 Close callbacks：執行 close 事件的 callback，利如 socket.destroy()。 事件迴圈就是不斷重複以上階段。每個階段都有自己的 callback 佇列，在進入某個階段時，都會從所屬的佇列中取出 callback 來執行，當佇列為空或者被執行 callback 的數量達到系統的最大數量時，就會進入下一階段。 根據以上提到事件驅動、單執行緒和非同步、非阻塞的 I/O 處理特性，Node.js 很適合拿來開發 I/O 密集型應用程式，如影音串流、即時互動、在線聊天、遊戲、協作工具、股票行情等軟體。 ","date":"2022-03-30","objectID":"/node/:1:3","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"NPM NPM 是跟 Node.js 一起安裝的線上套件庫，可以下載各式各樣的 JavaScript 套件來使用，能解決 Node.js 代碼部署上的很多問題。 安裝好後，可以使用 npm -v 來檢查版本： $ npm -v 8.5.0 跟 NPM 息息相關的是 package.json 這個檔案，他是掌管專案資訊的重要檔案，我們可以使用 init 指令來設定 package.json： $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. .... 省略 .... Press ^C at any time to quit. package name: (message) demo version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: ian \u003c880831ian@gmail.com\u003e license: (ISC) name: 就是該專案的名字，它預設就是該目錄名。 description: 專案描述。 entry point: 專案切入點，這有點複雜，之後再說。 test command: 專案測試指令，之後說。 git repository: 專案原始碼的版本控管位置。 keywoard: 專案關鍵字 author: 專案作者，以 author-name author@email.com 寫之。 license: 專案版權。 設定好後，專案資料夾就會多一個 package.json 的檔案，打開後可以看到，是我們剛剛所設定好的資訊： { \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"ian \u003c880831ian@gmail.com\u003e\", \"license\": \"ISC\" } 接下來，要如何下載網路上的模組，要使用 install 指令來下載，我們下載 Node.js 最小又靈活的 Web 應用程式框架 express 來做示範： $ npm install express added 50 packages, and audited 51 packages in 1s 2 packages are looking for funding run `npm fund` for details found 0 vulnerabilities 下載好後，可以看到剛剛 package.json 檔案多了 dependencies 欄位，它裡面會紀錄我們安裝了哪些套件，所以未來我們想知道專案使用了哪些套件，我們可以從 dependencies 這個欄位知道。 { \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"ian \u003c880831ian@gmail.com\u003e\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"^4.17.3\" } } 除此之外，還會多一個 node_modules 資料夾，這個資料夾就會存放我們所下載的套件 $ ls node_modules/ accepts cookie-signature etag inherits mime-types qs setprototypeof array-flatten debug express ipaddr.js ms range-parser statuses body-parser depd finalhandler media-typer negotiator raw-body toidentifier bytes destroy forwarded merge-descriptors on-finished safe-buffer type-is content-disposition ee-first fresh methods parseurl safer-buffer unpipe content-type encodeurl http-errors mime path-to-regexp send utils-merge cookie escape-html iconv-lite mime-db proxy-addr serve-static vary 當我們都安裝好後，express 已經包在 node_modules 目錄內，在專案裡面，就可以使用 require(‘套件名稱‘) 來使用套件囉！ var express = require('express'); 因為這些套件都可以直接在網路上下載到，所以在推送 git 專案時，可以使用 .gitignore 來隱藏不想被 push 的檔案，當我們想要下載套件回來時，只要使用： $ npm install 就可以依照 package.json 裡面的 dependencies 來下載套件！ ","date":"2022-03-30","objectID":"/node/:2:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"REPL Node.js REPL (交互式解釋器)：表示一個電腦環境，類似 Windoes 系統的終端或是 Unix/Linux 的 Shell，我們可以在終端機上輸入命令，並接收系統的響應。 Node 自帶了交互式解釋器，可以執行以下任務： 讀取：讀取用戶輸入，解析輸入的 JavaScript 數據結構並儲存在內存中。 執行：執行輸入的數據結構。 顯示：輸出結果。 循環：循環以上任務直到用戶按下兩次的 ctrl+c 按鈕退出。 我們可以輸入以下命令來啟動 Node 的終端： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e 可以執行簡單的數學運算： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e 1+4 5 \u003e 5/2 2.5 \u003e 3*7 21 \u003e 4-3 1 \u003e 1 + (2*4) -5 4 \u003e 也可以將數據存在變數中，在需要時使用它。變數宣告需要使用 var 關鍵字，如果沒有使用關鍵字，會直接顯示出來。也可以使用 console.log() 來輸出變數 $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e x = 19 19 \u003e var y = 10 undefined \u003e x + y 29 \u003e console.log(\"Hello\") Hello undefined \u003e Node REPL 也支持輸入多行程式，我們試著寫一個 do-while 迴圈： Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e var x = 0 undefined \u003e do { ... x++; ... console.log(\"x:\" + x); ... } while (x\u003c5); x:1 x:2 x:3 x:4 x:5 undefined \u003e 也可以使用下底線(_)來獲得上一個程式的運算結果： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e var x = 10 undefined \u003e var y = 20 undefined \u003e x + y 30 \u003e var sum = _ undefined \u003e console.log(sum) 30 undefined \u003e ","date":"2022-03-30","objectID":"/node/:3:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"Express 框架 Node.js 在實作上不會單獨使用，通常會搭配框架去使用，像是 Express JS 後端框架，可以讓開發人員在寫同一個功能時，少寫很多程式的工具。 Express 是 Node.js 環境下提供的輕量後端架構，自由度極高，透過豐富的 HTTP 工具，能快速發開後端應用程式，它提供： 替不同 HTTP Method、不同 URL 路徑的 requests 編寫不同的處理方法。 透過整合「畫面」的渲染引擎來達到插入資料到樣板產生 response。 設定常見的 web 應用程式，例如：連線用的 Port 和產生 response 樣板的位置。 在 request 的處理流程中增加而外的中間層 (Middleware) 進行處理。 第一個 Express Hello world 程式： const express = require('express') const app = express() const port = 3000 app.get('/', (req, res) =\u003e { res.send('Hello World!') }) app.listen(port, () =\u003e { console.log(`Example app listening on port ${port}`) }) $ node app.js Example app listening on port 3000 使用 node 來啟動伺服器，並使用 Port 3000 來連線。應用程式指向 URL (/) 的路由，以 “Hello World!” 回應如果是其他路徑，res 就會回應 404 找不到。 ","date":"2022-03-30","objectID":"/node/:4:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"畫面 (view) 剛剛有提到說它可以使用整合「畫面」的渲染引擎來顯示到樣板，我們可以透過 --view 指令來產生樣板以及應用程式的目錄： $ express --view=pub create : public/ create : public/javascripts/ create : public/images/ create : public/stylesheets/ create : public/stylesheets/style.css create : routes/ create : routes/index.js create : routes/users.js create : views/ create : app.js create : package.json create : bin/ create : bin/www ","date":"2022-03-30","objectID":"/node/:4:1","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"路由 (router) 路由是判斷應用程式如何回應用戶端對特定端點的要求，而特定端點是一個 URL 或是路徑，與一個特定的 HTTP 要求方法 (GET、POST) 等，路由定義的結構如下： app.METHOD(PATH, HANDLER) 其中 app 是 express 的實例。 METHOD 是 HTTP 要求的方法。 PATH 是伺服器上的路徑。 HANDLER 是當路由相符時要執行的函數。 以下範例簡單說明不同 HTTP 要求的方法： 首頁中以 Hello World! 回應。 app.get('/', function (req, res) { res.send('Hello World!'); }); 對根路由 (/)（應用程式的首頁）發出 POST 要求時的回應： app.post('/', function (req, res) { res.send('Got a POST request'); }); 對 /user 路由發出 PUT 要求時的回應： app.put('/user', function (req, res) { res.send('Got a PUT request at /user'); }); 對 /user 路由發出 DELETE 要求時的回應： app.delete('/user', function (req, res) { res.send('Got a DELETE request at /user'); }); ","date":"2022-03-30","objectID":"/node/:4:2","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"參考資料 Node.js 官網 Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈 An Intro to Node.js That You May Have Missed Sequelize 透過 sequelize 來達成 DB Schema Migration 認識同步與非同步 — Callback + Promise + Async/Await 你懂 JavaScript 嗎？#23 Callback How to create JOIN queries with Sequelize ","date":"2022-03-30","objectID":"/node/:5:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"本文章是使用 Go 來寫一個 Repository Restful API 的留言板，並且會使用 gin 以及 gorm (使用 Mysql)套件。 建議可以先觀看 Go 介紹 文章來簡單學習 Go 語言。 範例程式連結 點我 😘 版本資訊 macOS：11.6 Go：go version go1.18 darwin/amd64 Mysql：mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:0:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"實作 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"檔案結構 . ├── controller │ └── controller.go ├── go.mod ├── go.sum ├── main.go ├── model │ └── model.go ├── repository │ └── repository.go ├── router │ └── router.go └── sql ├── connect.yaml └── sql.go 我們來說明一下上面的資料夾個別功能與作用 sql：放置連線資料庫檔案。 controller：商用邏輯控制。 model：定義資料表資料型態。 repository：處理與資料庫進行交握。 router：設定網站網址路由。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:1","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"go.mod 一開始我們創好資料夾後，要先來設定 go.mod 的 module $ go mod init message go.mod 檔案 module message go 1.18 接著使用 go get 來引入 gin、gorm、mysql、yaml 套件 $ go get -u github.com/gin-gonic/gin $ go get -u gorm.io/gorm $ go get -u gorm.io/driver/mysql $ go get -u gopkg.in/yaml.v2 可以在查看一下 go.mod 檔案是否多了很多 indirect ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:2","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"main.go package main import ( \"fmt\" \"message/model\" \"message/router\" \"message/sql\" ) func main() { //連線資料庫 if err := sql.InitMySql(); err != nil { panic(err) } //連結模型 sql.Connect.AutoMigrate(\u0026model.Message{}) //sql.Connect.Table(\"message\") //也可以使用連線已有資料表方式 //註冊路由 r := router.SetRouter() //啟動埠為8081的專案 fmt.Println(\"開啟127.0.0.0.1:8081...\") r.Run(\"127.0.0.1:8081\") } 引入我們 Repository 架構，將 config、model、router 導入，先測試是否可以連線資料庫，使用 AutoMigrate 來新增資料表(如果沒有才新增)，或是使用 Table 來連線已有資料表，註冊網址路由，最後啟動專案，我們將 Port 設定成 8081。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:3","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"sql 我們剛剛有引入 yaml 套件，因為我們設定檔案會使用 yaml 來編輯 connect.yaml host:127.0.0.1username:rootpassword:\"密碼\"dbname:\"資料庫名稱\"port:3306 我們把 mysql 連線的資訊寫在此處。 sql.go (下面為一個檔案，但長度有點長，分開說明) package sql import ( \"io/ioutil\" \"fmt\" \"gopkg.in/yaml.v2\" \"gorm.io/gorm\" \"gorm.io/driver/mysql\" ) import 會使用到的套件。 var Connect *gorm.DB type conf struct { Host string `yaml:\"host\"` UserName string `yaml:\"username\"` Password string `yaml:\"password\"` DbName string `yaml:\"dbname\"` Port string `yaml:\"port\"` } func (c *conf) getConf() *conf { //讀取config/connect.yaml檔案 yamlFile, err := ioutil.ReadFile(\"sql/connect.yaml\") //若出現錯誤，列印錯誤訊息 if err != nil { fmt.Println(err.Error()) } //將讀取的字串轉換成結構體conf err = yaml.Unmarshal(yamlFile, c) if err != nil { fmt.Println(err.Error()) } return c } 設定資料庫連線的 conf 來讀取 yaml 檔案。 //初始化連線資料庫 func InitMySql() (err error) { var c conf //獲取yaml配置引數 conf := c.getConf() //將yaml配置引數拼接成連線資料庫的url dsn := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\", conf.UserName, conf.Password, conf.Host, conf.Port, conf.DbName, ) //連線資料庫 Connect, err = gorm.Open(mysql.New(mysql.Config{DSN: dsn}), \u0026gorm.Config{}) return } 初始化資料庫，會把剛剛讀取 yaml 的 conf 串接成可以連接資料庫的 url ，最後連線資料庫。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:4","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"router.go package router import ( \"message/controller\" \"github.com/gin-gonic/gin\" ) func SetRouter() *gin.Engine { //顯示 debug 模式 gin.SetMode(gin.ReleaseMode) r := gin.Default() v1 := r.Group(\"api/v1\") { //新增留言 v1.POST(\"/message\", controller.Create) //查詢全部留言 v1.GET(\"/message\", controller.GetAll) //查詢 {id} 留言 v1.GET(\"/message/:id\", controller.Get) //修改 {id} 留言 v1.PATCH(\"/message/:id\", controller.Update) //刪除 {id} 留言 v1.DELETE(\"/message/:id\", controller.Delete) } return r } 設定路由，版本 v1 網址是 api/v1 ，分別是新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function 。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:5","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"model.go package model import \"gorm.io/gorm\" func (Message) TableName() string { return \"message\" } type Message struct { Id int `gorm:\"primary_key,type:INT;not null;AUTO_INCREMENT\"` User_Id int `json:\"User_Id\" binding:\"required\"` Content string `json:\"Content\" binding:\"required\"` Version int `gorm:\"default:0\"` // 包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位 gorm.Model } 設定資料表的結構，使用 gorm.Model 預設裡面會包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:6","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"controller.go (下面為一個檔案，但長度有點長，分開說明) package controller import ( \"message/model\" \"message/repository\" \"net/http\" \"unicode/utf8\" \"github.com/gin-gonic/gin\" ) import 會使用到的套件。 查詢留言功能 func GetAll(c *gin.Context) { message, err := repository.GetAllMessage() if err != nil { c.JSON(http.StatusBadRequest, gin.H{\"message\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } func Get(c *gin.Context) { var message model.Message if err := repository.GetMessage(\u0026message, c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } GetAll() 會使用到 repository.GetAllMessage() 查詢並回傳顯示查詢的資料。 c.Param(\"id\") 是網址讀入後的 id，網址是http://127.0.0.1:8081/api/v1/message/{id} ，將輸入的 id 透過 repository.GetMessage() 查詢並回傳顯示查詢的資料。 新增留言功能 func Create(c *gin.Context) { var message model.Message if c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) \u003e= 20 { c.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"}) return } c.Bind(\u0026message) repository.CreateMessage(\u0026message) c.JSON(http.StatusCreated, gin.H{\"message\": message}) } 使用 Gin 框架中的 Bind 函數，可以將 url 的查詢參數 query parameter，http 的 Header、body 中提交的數據給取出，透過 repository.CreateMessage() 將要新增的資料帶入，如果失敗就顯示 http.StatusBadRequest，如果成功就顯示 http.StatusCreated 以及新增的資料。 修改留言功能 func Update(c *gin.Context) { var message model.Message if c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) \u003e= 20 { c.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"}) return } if err := repository.UpdateMessage(\u0026message, c.PostForm(\"Content\"), c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } 先使用 repository.GetMessage() 以及 c.Param(\"id\") 來查詢此 id 是否存在，再帶入要修改的 Content ，透過 repository.UpdateMessage() 將資料修改，，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusOK 以及修改的資料。 刪除留言功能 func Delete(c *gin.Context) { var message model.Message if err := repository.DeleteMessage(\u0026message, c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusNoContent, gin.H{\"message\": \"刪除留言成功\"}) } 透過 repository.DeleteMessage() 將資料刪除，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusNoContent。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:7","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"repository.go (下面為一個檔案，但長度有點長，分開說明) 所有的邏輯判斷都要在 controller 處理，所以 repository.go 就單純對資料庫就 CRUD： package repository import ( \"message/model\" \"message/sql\" ) import 會使用到的套件。 查詢留言資料讀取 //查詢全部留言 func GetAllMessage() (message []*model.Message, err error) { err = sql.Connect.Find(\u0026message).Error return } //查詢 {id} 留言 func GetMessage(message *model.Message, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Error return } 新增留言資料讀取 //新增留言 func CreateMessage(message *model.Message) (err error) { err = sql.Connect.Create(\u0026message).Error return } 修改留言資料讀取 //更新 {id} 留言 func UpdateMessage(message *model.Message, content, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Update(\"content\", content).Error return } 刪除留言資料讀取 //刪除 {id} 留言 func DeleteMessage(message *model.Message, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Delete(\u0026message).Error return } ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:8","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"Postman 測試 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢全部留言 - 成功(無資料) 查詢留言 成功(無資料)\" 查詢留言 成功(無資料) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:1","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢全部留言 - 成功(有資料) 查詢留言 成功(有資料)\" 查詢留言 成功(有資料) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:2","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢{id}留言 - 成功 查詢{id}留言 成功\" 查詢{id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:3","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢{id}留言 - 失敗 查詢{id}留言 失敗\" 查詢{id}留言 失敗 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:4","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"新增留言 - 成功 新增留言 成功\" 新增留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:5","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"修改{id}留言 - 成功 修改 {id}留言 成功\" 修改 {id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:6","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"修改{id}留言 - 失敗 修改 {id}留言 失敗\" 修改 {id}留言 失敗 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:7","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"刪除{id}留言 - 成功 刪除 {id}留言 成功\" 刪除 {id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:8","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"執行結果 執行結果\" 執行結果 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:9","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"參考資料 基於Gin+Gorm框架搭建MVC模式的Go語言後端系統 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:3:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"什麼是 Go ? Go 全名是 go programming language 又被稱為 Golang，是因為 go 這個詞太廣泛，不易搜尋，所以也可以叫 Golang。 Go 是由 Google 開發並維護的編譯程式語言，支援垃圾回收與併發，由於開發人之一也是 C 語言的作者，所以 Go 也繼承了許多 C 的風格 其特點有以下幾點： 靜態型別：因爲靜態型別的特性，可以在編譯期間就進行完整的型別檢查，可以找出大部分的型別錯誤。 編譯速度：因為 Go 語言先天優勢是架構設計非常單純，並不像物件導向語言龐大，在編譯時不用相依其他的 library，因此讓他有更好的執行效率。 語法簡潔：Go 關鍵字不多，不到30幾個，因為其關鍵字不少也與 C 的關鍵字重複，學習更容易上手。 垃圾回收：Go 有自動內存回收機制，不需要由開發人員來管理。垃圾回收是一種記憶體管理機制。當程式所佔用記憶體不再被該程式給存取時，會借助垃圾回收演算法，將記憶體空間歸還給作業系統。 原生支援併發：Go 語言支持併發，只需要透過 go 關鍵字來開啟 goroutine 將可。goroutine 是 Go 語言實現併發的一種方式，在執行的過程需要少量的記憶體，來暫存自己的上下文，就可在不同的時間點來分段執行程式。並且有 channel 可以跟 goroutine 進行資料溝通。 靜態型別/動態型別 靜態型別的意思是指當宣告一個變數時，你必須同時宣告此變數所存放的資料型態為何 var age int // int var name string // string 動態型別指的是程式執行時，系統才可以看見的型別，什麼型別都可以 var i interface {} i = 18 i = \"Golang 程式設計\" 編譯式語言/直譯式語言 編譯式：當我們寫完程式時，我們需要將程式 compile (編譯) 成電腦看得懂的程式，再將程式拿去執行。 直譯式：當我們寫完程式時，直接使用直譯器一行一行翻譯成電腦語言並執行。 比較： 編譯式執行效率較佳 直譯式相對容易 Debug 編譯式語言編譯完後，可以直接在各類 OS 系統中執行，因為編譯完的程式，就是電腦看得懂的。 那我們大致了解 Go 後就來安裝 Go吧！ ","date":"2022-03-21","objectID":"/go/:1:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"安裝 Go 本次作業系統為 macOS，所以後續都以 macOS 為主，如果是使用其他的作業系統，可以直接到官網來下載。 macOS 可以用 brew 等工具來下載，但這次我使用官網直接下載 pkg 來安裝。 Go 官網下載位置\" Go 官網下載位置 下載完後，使用 go version 來檢查是否安裝成功： $ go version go version go1.18 darwin/amd64 接著我們來看一下他的環境變數，使用 go env，來查看： $ go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/ian_zhuang/Library/Caches/go-build\" GOENV=\"/Users/ian_zhuang/Library/Application Support/go/env\" GOEXE=\"\" GOEXPERIMENT=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GOMODCACHE=\"/Users/ian_zhuang/go/pkg/mod\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/ian_zhuang/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/go\" 這邊簡單的列出來，比較重要的是 GOPATH：他是有關管理程式碼和套件執行檔的地方，在 Go 1.8 版本以前，GOPATH 預設為空。從 1.8 以後，Go 安裝完後，都會直接給預設的路徑 說一下這個路徑的內容，我在依照預設的路徑，像我是在 Users/使用者/go，在 go 底下新增三個資料夾： src：主要放置專案的地方 pkg：套件主要儲存的資料夾 bin：存放編譯好的執行檔案 在 Go 1.11 後提供了 go modules 讓我們不一定要把專案程式碼放在 $GOPATH/src 中做開發，因此我們先來設定我在要放專案的資料夾，打開 .bash_profile： export GOPATH=你專案的路徑/goworkspace $ source .bash_profile 接著我們來實作第一隻 Go 程式吧，我們會依照官網的示範，但為了要介紹 modules 是什麼，所以會小修改內容。 ","date":"2022-03-21","objectID":"/go/:2:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"第一隻 Go 程式 我們依照官網的示範教學，先建立一個資料夾(要放在我們剛剛的 GOPATH 目錄下方歐)，來放我們第一個 Go 程式 “印出 Hello world” (程式碼可以從此處下載)： mkdir helloworld cd helloworld 接著下指令來新增 Go module： $ go mod init helloworld go: creating new go.mod: module helloworld 如果成功，會產生一個 go.mod 檔案，我們來看看內容有什麼： $ cat go.mod module helloworld go 1.18 go.mod 是用來定義 module 的文件，用來標示此 module 的名稱、所使用的 go 版本以及相依的 Go module。 我們分別再新增兩個資料夾，以及兩個 .go 檔，來建立我們範例所需要的環境： mkdir greeting cli touch greeting/greeting.go cli/say.go 到目前為止結構如下： . ├── cli │ └── say.go ├── go.mod └── greeting └── greeting.go 我們來修改一下 greeting.go 以及 say.go 程式碼吧。 greeting.go 是一個簡單的 package，用以顯示所傳入的字串 ; 而 say.go 則是以呼叫 greeting.go package 所提供的函式來顯示資料。 greeting.go 內容： package greeting import \"fmt\" func Say(s string) { fmt.Println(s) } say.go 內容： package main import ( \"helloworld/greeting\" ) func main(){ greeting.Say(\"Hello World\") } 順便來介紹一下程式裡面分別是什麼意思吧！ Package：package 主要分成兩種，一個是可執行，另一個則是可重複使用的，而 package main 就是可執行的檔案，像我們上面這個有包含 package main 的檔案，在編譯時，就會產生一個 say 的執行檔，電腦就是依照此檔案執行的。 Import：當我們寫程式時，一定會引入其他人寫的套件。而 Go 語言的標準函式庫為開發團隊先寫好，提供一些常用的功能，當然也可以使用其他第三方套件，還滿足內建以及標準函式庫的不足。我們在 greeting.go 裡面引入的 fmt 就是開發團隊寫好的，然而在 say.go 裡面引入的就是greeting.go ，我們就可以使用其內容的函式來做使用。 Main Function：每個 Go 語言的專案基本上都會有一個主程式，主程式裡的程式通常都為最核心的部分。 最後使用 go run say.go 來將此程式運行起來： $ go run say.go Hello World 就可以看到程式成功將 Hello World 給印出來拉！ ","date":"2022-03-21","objectID":"/go/:3:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"常見指令 接下來要簡單介紹一下常用的另外3個指令，分別是 go build、go install、go clean： go get：來下載套件到當前的模組，並安裝他們 $ go get github.com/fatih/color go: downloading github.com/fatih/color v1.13.0 .... 省略 .... go build：還記得我們前面說 Go 是編譯式程式，所以我們可以將程式用 go build 來編譯成電腦看得懂的執行檔歐，檔案會存放在當前目錄或是指定目錄中 ~ $ ls go.mod $ go build cli/say.go go.mod say $ ./say Hello World 多的這個 say 就是編譯後的執行檔，將他執行會顯示跟我們使用 run 來運行的一樣，顯示 Hello World。 go install：如果編譯沒有錯誤，一樣跟 build 會產生執行檔，不同的是，會將執行檔，產生於 $GOPATH/bin 內。 $ ls /Users/ian_zhuang/go/bin dlv go-outline gomodifytags goplay gopls gotests impl staticcheck $ go install $ ls /Users/ian_zhuang/go/bin dlv go-outline gomodifytags goplay gopls gotests hello impl staticcheck go clean：執行後會將 build 產生的檔案都刪除 (install 的不會) $ ls go.mod hello . $ go clean $ ls go.mod . ","date":"2022-03-21","objectID":"/go/:3:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"套件相依性管理 Go modules 提供的另一個方便的功能則是套件相依性管理，接下來實際透過以下指令來安裝套件： $ go get github.com/fatih/color go: downloading github.com/fatih/color v1.13.0 go: downloading github.com/mattn/go-isatty v0.0.14 go: downloading github.com/mattn/go-colorable v0.1.9 go: downloading golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c go: added github.com/fatih/color v1.13.0 go: added github.com/mattn/go-colorable v0.1.9 go: added github.com/mattn/go-isatty v0.0.14 go: added golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c 安裝成功，可以再查看一下 go.mod： module github.com/880831ian/go/helloworld go 1.18 require github.com/fatih/color v1.13.0 require ( github.com/mattn/go-colorable v0.1.12 // indirect github.com/mattn/go-isatty v0.0.14 // indirect golang.org/x/sys v0.0.0-20220319134239-a9b59b0215f8 // indirect ) 會多了下面這些 require github.com/fatih/color v1.13.0 代表目前專案使用 v1.13.0 版本的 github.com/fatih/color 下面的 indirect 指的是被相依的套件所使用的 package 接著我們將 greeting.go、say.go 兩個檔案修改一下，使用我們剛剛所安裝的 package： greeting.go package greeting import ( \"fmt\" \"github.com/fatih/color\" ) func Say(s string) { fmt.Println(s) } func SayWithRed (s string) { color.Red(s) } func SayWithBlue (s string) { color.Blue(s) } func SayWithYellow (s string) { color.Yellow(s) } 我再多 import 了剛剛的 github.com/fatih.color，並使用該套件的函式 color 來分別顯示 Red、Blud、Yellow 三種顏色。 say.go package main import ( \"github.com/880831ian/go/helloworld/greeting\" ) func main(){ greeting.Say(\"Hello World\") greeting.SayWithRed(\"Hello World\") greeting.SayWithBlue(\"Hello World\") greeting.SayWithYellow(\"Hello World\") } 我們將 greeting 三種顯示顏色的函式帶入。 一樣我們來運行一下程式，來看看結果如何，這次我們直接編譯，使用 go build 來編譯，最後直接執行產生的執行檔： $ go build cli/say.go $ ./say Hello World Hello World //紅色 Hello World //藍色 Hello World //黃色 由於 Makedown 沒辦法於程式碼區域顯示正確顏色，用註解標示一下XD ","date":"2022-03-21","objectID":"/go/:3:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"變數 在使用變數做宣告時，要注意以下幾個 Go 保留字，不能拿來當變數名稱，其 Go 有三種宣告的方式： Go 保留字，不能拿來當變數名稱\" Go 保留字，不能拿來當變數名稱 ","date":"2022-03-21","objectID":"/go/:4:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"使用 := 來宣告 表示之前沒有進行宣告過。這是 Go 中最常見的變數宣告方式，但不能用縮寫方式來定義變數 (foo := bar) ，因為 package scope 的變數都是以 keyword 作為開頭。且只能在 function 中使用。 func main (){ a := \"bar\" b := 4 c := true // 也可以簡寫成這樣 d,e,f := \"bar\",4,true fmt.Println(a,b,c); fmt.Println(d,e,f); } $ go run . bar 4 true bar 4 true ","date":"2022-03-21","objectID":"/go/:4:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"先宣告資料型態 當不知道變數的起始值，或是需要在 package scope 中宣告變數時可以使用。 var a string var b int // 也可以簡寫成這樣 var ( c string d float64 ) func main (){ a = \"Hello\" b = 123 c = \"ian\" d = 3.5 fmt.Println(a,b,c,d) } ⚠️ 不建議把變數寫在全域變數中 ⚠️ $ go run . Hello 123 ian 3.5 ","date":"2022-03-21","objectID":"/go/:4:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"直接宣告並賦值 func main (){ var ( a string = \"Hello\" b int = 9999 ) fmt.Println(a,b) } $ go run . Hello 9999 ","date":"2022-03-21","objectID":"/go/:4:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"常見宣告錯誤 重複宣告變數 func main (){ name := \"ian\" name := \"pinyi\" } $ go run . # github.com/880831ian/go/test ./test.go:4:2: name declared but not used ./test.go:5:7: no new variables on left side of := 在 main 函式外賦值 var a int b := \"Hello\" func main (){ fmt.Println(a,b) } $ go run . # github.com/880831ian/go/test ./test.go:6:1: syntax error: non-declaration statement outside function body 我們可以在 main 函式外宣告變數，但無法在 main 函式外賦值 沒有宣告就使用變數 func main (){ a = 123 b = true fmt.Println(a,b) } $ go run . # github.com/880831ian/go/test ./test.go:6:2: undefined: a ./test.go:7:2: undefined: b ./test.go:8:14: undefined: a ./test.go:8:16: undefined: b ","date":"2022-03-21","objectID":"/go/:4:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 資料型態 我們在學習 Go 語言之前，要先了解一下基本的資料型態，可以簡單分為 字串、字符、整數、浮點數、布林值、映射 ","date":"2022-03-21","objectID":"/go/:5:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"字串 String 在 Go 語言中，字串必須用雙引號給匡起來，也可以使用反引號來宣告。用雙引號刮起來的字串不能包含換行，但可以包含跳脫字元，例如 \\n 、\\t 。由於反引號內包含的是原始字串，可以跨越多行，所以跳脫符號在原始字串中沒有任何含義。 func main() { var name = \"ian\" fmt.Printf(\"資料型態 name : %v(%T)\\n\", name,name) var address = `台中市太平區` fmt.Printf(\"資料型態 address : %v(%T)\\n\", address,address) } $ go run . 資料型態 name : ian(string) 資料型態 address : 台中市太平區(string) ","date":"2022-03-21","objectID":"/go/:5:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"字符 Character 字串中的每一個元素叫做字符，字符會使用單引號匡起來，像是 \"abc\" 這個字串，其中 'a'、'b'、'c' 就是字符，可以從字串元素中來獲得字符。 Go 語言的字符有以下兩種： 一種叫 byte 類型，可以叫做 uint8 類型，代表 ASCll 碼的一個字符。 另一種是 rune 類型，代表一個 UTF-8 字符，當需要處理中文、日文或是其他複合字符時，就會使用到 rune 類型。rune 類型等於 int32 類型。 func main (){ var a byte = 'A' var b rune = '嗨' fmt.Printf(\"%c %c\\n\",a,b) //%c 所表示的字符 fmt.Printf(\"%d(%T) %d(%T)\\n\",a,a,b,b) //%d 十進制表示,%T 輸出型態 fmt.Printf(\"%x %x\\n\",a,b) //%x 十六進制表示 fmt.Printf(\"%U %U\\n\",a,b) //%U 輸出格式為 Unicode 格式:U+hhhh的字串 } $ go run . A 嗨 65(uint8) 21992(int32) 41 55e8 U+0041 U+55E8 ","date":"2022-03-21","objectID":"/go/:5:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"整數 Integer 整數用於儲存整數。 Go 具有多種大小不一的內建整數型別，用來儲存有號數和無號數。 有號數 型別 大小 範圍 int 取決平台 取決平台 int 8 8 bits -128 到 127 int 16 16 bits -2^15 到 2^15-1 int 32 32 bits -2^31 到 2^31-1 int 64 64 bits -2^63 到 -2^63-1 無號數 型別 大小 範圍 uint 取決平台 取決平台 uint 8 8 bits 0 到 255 uint 16 16 bits 0 到 2^16-1 uint 32 32 bits 0 到 2^32-1 uint 64 64 bits 0 到 -2^64-1 int 、 uint 的型別大小取決於平台。在 32 位元系統上，它大小為 32 位元，64 位元系統上，它的大小為 64 位元。 使用整數值時，除非確定會用到的大小跟範圍才使用有號數及無號數，否則應該都使用 int 資料型別。 func main() { var myInt8 int8 = 97 var myInt = 1200 var myUint uint = 500 var myOctalNumber = 034 var myHexNumber = 0xFF fmt.Printf(\"%d, %d, %d, %#o, %#x\\n\", myInt8, myInt, myUint, myOctalNumber, myHexNumber) } $ go run . 97, 1200, 500, 034, 0xff 在 Go 中，也可以使用前綴 0 來宣告八進制數字，或是使用 0x 來宣告十六進制數字。 ","date":"2022-03-21","objectID":"/go/:5:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"浮點數 Float 浮點數型別用於儲存小數部分的數字。Go 有兩種浮點數型別： float32：在記憶體中佔用32位元，並以單精度浮點數格式儲存。 float64：在記憶體中佔用64位元，並以雙精度浮點數格式儲存。 浮點數的預設是 float64，除非初始化有為浮點數變數指定型別，否則編譯器將判定為 float64。 func main() { var a = 245.4664 var b float32 = 1452.34 fmt.Printf(\"%f(%T)\\n%f(%T)\\n\", a,a,b,b) } $ go run . 245.466400(float64) 1452.339966(float32) ","date":"2022-03-21","objectID":"/go/:5:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"布林值 Bool Go 提供了一種稱為 bool 的資料型別來儲存布林值。它有兩個可能的值：true 和 false。 func main() { var a = true var b bool = false fmt.Printf(\"%v(%T)\\n%v(%T)\\n\", a,a,b,b) } $ go run . true(bool) false(bool) 布林型別也可以使用運算子 \u0026\u0026 (與,and)、|| (和,or)、! (否定) func main() { var a = 4 \u003c= 7 var b = 10 != 10 var c = 10 \u003e 20 \u0026\u0026 5 == 5 var d = 2 * 2 == 4 || 10 / 3 == 3 fmt.Printf(\"%v\\n%v\\n%v\\n%v\\n\", a,b,c,d) } $ go run . true false false true ","date":"2022-03-21","objectID":"/go/:5:5","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"映射 Map 映射 (Map) 是 Go 內建的類型，是一種鍵值(key-value)的集合，可以透過 key 快速查詢並找到數據。 func main (){ var map3 = map[int]string{99 : \"Go\", 87 : \"Python\", 79 : \"Java\", 93: \"Html\"} fmt.Println(map3) fmt.Println(\"map3[99] =\",map3[99],\"map3[79] =\",map3[79]) map3[79] = \"PHP\" fmt.Println(\"修改數據後，map3[99] =\",map3[99],\"map3[79] =\",map3[79]) } map[79:Java 87:Python 93:Html 99:Go] map3[99] = Go map3[79] = Java 修改數據後，map3[99] = Go map3[79] = PHP ","date":"2022-03-21","objectID":"/go/:5:6","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"數字型別的運算 Go 提供了多種用於數字、浮點數型別執行運算的運算子 算術運算子：+、-、*、/、% 比較運算子：==、!=、\u003c、\u003e、\u003c=、\u003e= 位元運算子：\u0026、 |、 ^、 \u003c\u003c、\u003e\u003e 遞增和遞減運算子：++、-- 賦值運算子：+=、-=、*=、/=、%=、\u003c\u003c=、\u003e\u003e=、\u0026=、|=、^= import ( \"fmt\" \"math\" ) func main() { var a, b = 4, 5 var res1 = (a + b) * (a + b) / 2 a++ b += 10 var res2 = a ^ b var r = 3.5 var res3 = math.Pi * r * r fmt.Printf(\"res1 : %v, res2 : %v, res3 : %v\\n\", res1, res2, res3) } res1 : 40, res2 : 10, res3 : 38.48451000647496 ","date":"2022-03-21","objectID":"/go/:5:7","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"型別轉換 Go 有一個強型別系統，它不允許混合型別。舉例來說：不能把 int 變數加到 float64 變數中，也不能將 int 變數加到 int64 變數中。 func main() { var a int64 = 4 var b int = int(a) var c int = 500 fmt.Println(a, b,a+c) } $ go run . # command-line-arguments ./.:11:19: invalid operation: a + c (mismatched types int64 and int) 就會跳出錯誤說明別不同，無法直接做運算，那要怎麼辦呢！？ 使用型別轉換，將型別值轉成相同的 func main() { var a int64 = 4 var b int = int(a) var c int = 500 fmt.Println(a, b,int(a)+c) } $ go run . 4 4 504 一般將值 v 轉換為型別 T 的語法是 T(V) 。 ","date":"2022-03-21","objectID":"/go/:5:8","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 資料結構 ","date":"2022-03-21","objectID":"/go/:6:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"指標 Pointer 指標是程式語言中的資料結構及其物件或變數，用來表示或儲存記憶體位址，這個位址的值直接指向存在該位址物件的值。 Go 支持指標，指標的聲明方式為 *T，可以藉由變數名稱前面加 \u0026 來獲得變數的位址，由於 Go 支持 GC ，在 Go 語言中不支持指標的運算。 表示法 使用 \u0026 來獲得指標位址 使用 * 來獲得指標所指向的值 func main (){ var a int = 2 fmt.Println(\"a 位址 = \",\u0026a) fmt.Printf(\"a 的值 = %v\\n\",a) var pInt *int = \u0026a fmt.Printf(\"pInt = %v\\n\", pInt); fmt.Printf(\"pInt 位址 = %v\\n\",\u0026pInt); fmt.Printf(\"pInt 指向的值 = %v\\n\",*pInt); } $ go run . a 位址 = 0xc0000b2008 a 的值 = 2 pInt = 0xc0000b2008 pInt 位址 = 0xc0000ac020 pInt 指向的值 = 2 ","date":"2022-03-21","objectID":"/go/:6:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"陣列 Array 我們已經學會要怎麼宣告變數，以及如何使用變數來儲存值。但當我們今天想要儲存多個數值，使用原本的方式，需要創建許多變數才能儲存，因此有了陣列可以來儲存大量資料。 陣列 (Array) 是由同類型的元素集合所組成的資料結構，分配一塊連續的記憶體來儲存。利用元素的索引可以計算出該元素所對應的儲存位址。 func main (){ var a [2] float32 a [0] = 1.4 a [1] = 3.14 // 也可以寫成這樣 var b = [] int{10,20,99,333} fmt.Println(a,b) fmt.Println(len(a),len(b)) } $ go run . [1.4 3.14] [10 20 99 333] 2 4 上面有提到他會分配連續記憶體來儲存，我們來看看他是怎麼存的！ func main (){ a := [...]int{1, 2, 3} fmt.Printf(\"a 的記憶體分配位置 %p \\n\", \u0026a) fmt.Printf(\"陣列 a 的索引 0 記憶體分配位置 %p \\n\", \u0026a[0]) fmt.Printf(\"陣列 a 的索引 1 記憶體分配位置 %p \\n\", \u0026a[1]) fmt.Printf(\"陣列 a 的索引 2 記憶體分配位置 %p \\n\", \u0026a[2]) } $ go run . a 的記憶體分配位置 0xc0000180f0 陣列 a 的索引 0 記憶體分配位置 0xc0000180f0 陣列 a 的索引 1 記憶體分配位置 0xc0000180f8 陣列 a 的索引 2 記憶體分配位置 0xc000018100 ","date":"2022-03-21","objectID":"/go/:6:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"切片 Slice 前面提到陣列的使用，陣列使用上是實值類型以及陣列長度不可變的情況下，間接限制了使用場景。 切片 (slice) 是 Go 對陣列在進行一層的封裝，是一個擁有相同類型元素的可變長度序列，可以非常靈活運用，自動擴容，可以快速且方便的操作數據集合。 func main (){ a := [5]int{55, 75, 58, 60, 66} b := a[1:4] //基於 a 陣列創建切片，等於 b 包含 a[1],a[2],a[3] fmt.Printf(\"%v(%T)\\n\",b,b) fmt.Printf(\"len = %v\\n\",len(b)) fmt.Printf(\"cap = %v\\n\",cap(b)) } [75 58 60]([]int) len = 3 cap = 4 len(b) 表示可見元素有幾個(直接打印元素看到的元素個數)，而 cap(b) 表示所有元素有幾個。 [1:4] 代表從第二個元素開始 (0為第一個元素，1位第二的元素)，取到第4個元素 (下標為 4-1=3，下標3代表第四個元素) 使用 make 創建切片 func main (){ a := make([]int,5,10) //創建長度 5,容量 10 的切片 fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) } a = [0 0 0 0 0], len(a) = 5, cap(a) = 10 使用 make 創建長度5 ,容量 10 的切片 使用 append 來達成新增元素 func main (){ a := make([]int,2,2) //創建長度 5,容量 10 的切片 fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) fmt.Printf(\"指標為 %p\\n\", a) a = append(a, 10) fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) fmt.Printf(\"擴容後指標 = %p 改變\\n\", a) } a = [0 0], len(a) = 2, cap(a) = 2 指標為 0xc000014080 a = [0 0 10], len(a) = 3, cap(a) = 4 擴容後指標 = 0xc000022080 改變 ","date":"2022-03-21","objectID":"/go/:6:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"結構 Struct 我們介紹的變數都是儲存單一的值或是多個相同型態的值，那如果要用變數表示較複雜的概念，像是紀錄一個人的名字、年齡或是身高時，由於這些是不同的資料型態，所以要記錄下來時，就必須使用不同的容器，這裡會介紹 Go 語言中的結構 Struct： 建立結構 type Student struct { Id int Name string Score float64 } func main() { student := Student{1, \"ian\", 89.4} fmt.Println(student) } $ go run . {1 ian 89.4} 我們先宣告一個名為 Student 的 struct 結構，裡面屬性有 Id 和 Name 以及 Score，再以此結構宣告一個變數 student 並填入屬性，以顯示不同資料型態的值。 ","date":"2022-03-21","objectID":"/go/:6:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 控制流程 ","date":"2022-03-21","objectID":"/go/:7:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"if 結構裡會有一個條件，這個條件是個布林值，如果為 true，則會執行括號裡的程式碼，相反的，如果為 false，則會直接跳過： func main (){ var x = 2 var y = 1 fmt.Println(\"x = \",x,\",y = \",y) if x==y { fmt.Printf(\"%v 等於 %v\\n\",x,y) } fmt.Printf(\"%v 不等於 %v\\n\",x,y) } $ go run . x = 2 ,y = 1 2 不等於 1 ","date":"2022-03-21","objectID":"/go/:7:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"switch switch 其目的是簡化 if 的條件，swtich 會檢查符合的條件，並且執行條件內的程式碼，如果都沒有符合，則會執行 default 內的程式碼： func main (){ x := 12 switch { case x \u003c 10: fmt.Printf(\"%v 小於 10\\n\",x) case x \u003c 20: fmt.Printf(\"%v 大於等於10, 小於 20\\n\",x) default: fmt.Printf(\"%v 大於 20\\n\",x) } } $ go run . 12 大於等於10, 小於 20 ","date":"2022-03-21","objectID":"/go/:7:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 迴圈 迴圈是每個程式語言必備的函式，藉以迴圈來達成反覆或是循環的動作。而 Go 語言的迴圈只有使用 for 迴圈來表達三種不同的迴圈 (for、while、loop)： func main (){ for i := 0 ; i \u003c= 10 ; i++ { fmt.Println(i) } } $ go run . 0 1 2 3 4 5 6 7 8 9 10 break 也可以使用 break，依條件需求讓迴圈提早跳出結束： func main (){ for i := 0 ; i \u003c= 5 ; i++ { if i \u003e 3 { break } fmt.Println(i) } } $ go run . 0 1 2 3 Continue 或是使用 continue 若符合條件，便會跳過到此迴圈，直接進入下個迭代： func main (){ for i := 1; i \u003c= 10; i++ { if i%2 == 0 { continue } fmt.Println(i) } } $ go run . 1 3 5 7 9 GoTo 使用 goto 可以無條件轉移到程式中指定的行 func main (){ fmt.Println(\"1\") fmt.Println(\"2\") goto labele1 fmt.Println(\"3\") labele1: fmt.Println(\"4\") fmt.Println(\"5\") fmt.Println(\"6\") } $ go run . 1 2 4 5 6 ","date":"2022-03-21","objectID":"/go/:8:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 方法 Method Go 語言不像 Python 有 class ，但還是有提供可以在某種型態上定義方法(method)，method 其實是作用在接收器 (receiver) 上的一種函式，接收器要是某一種型別的變數，所以其實 method 也算是一種特殊型別的函式。 type Vertex struct { x,y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.x * v.x + v.y * v.y) } func main() { v := Vertex{5,12} fmt.Println(v.Abs()) } $ go run . 13 一開始先宣告一個名為 Vertex 結構型態，裡面的屬性包含 ｘ、y (float64)，接著就是撰寫一個 method 了，這個 method 是以 Vertex 作為接收器， method 名稱是 Abs，最後回傳浮點數，接著 method 裡頭，即為對接收器的運算並回傳值。 我們來看看如果使用 function 要怎麼來達成 方法 (Method) vs 函式 (Function) type Vertex struct { x, y float64 } func Abs(v Vertex) float64{ return math.Sqrt(v.x * v.x + v.y * v.y) } func main () { v := Vertex{5,12} fmt.Println(Abs(v)) } $ go run . 13 ","date":"2022-03-21","objectID":"/go/:9:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 介面 Interface Interface 的概念有點像是藍圖，先定義某個方法的名稱 (function name)、會接收到的參數以及型別 (list of argument types)、會回傳的值與型別 (list of return types)。定義好藍圖之後，並不用去管實作的細節，實作的細節會由每個型別自行定義實作。 empty interface 沒有定義任何方法的 interface 稱作 empty interface，由於所有的 types 都能夠實作 empty interface，因此它的值會是 any type：(因為目前沒有被賦值，所以都會回傳 nil) type value interface{} func main() { var v value describe(v) // (\u003cnil\u003e, \u003cnil\u003e) v = 42 describe(v) //(42, int) v = \"hello\" describe(v) // (hello, string) } func describe(v value) { fmt.Printf(\"(%v, %T)\\n\", v, v) } $ go run . value is \u003cnil\u003e type is \u003cnil\u003e type Person interface { getFullName() string getSalary() int } type Employee struct { firstName string lastName string salary int } func (e Employee) getFullName() string { return e.firstName + \" \" + e.lastName } func (e Employee) getSalary() int { return e.salary } func main() { var p Person = Employee{\"ian\", \"Zhuang\", 2000} fmt.Printf(\"full name : %v ,Salary : %v\\n\", p.getFullName(),p.getSalary()) } $ go run . full name : ian Zhuang ,Salary : 2000 ","date":"2022-03-21","objectID":"/go/:10:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Goroutine 有人把 Go 比作 21 世紀的 C 語言，第一是因為 Go 語言設計簡單，第二，21 世紀最重要的就是並行程式設計，而 Go 從語言層面就支援了併發。 Goroutine 是 Go 語言實現併發的一種方式。 Goroutine 是一種非常輕量級的執行緒，它是Go語言併發設計的核心。執行 Goroutine 只需極少的記憶體，可同時執行成千上萬個併發的任務。 ","date":"2022-03-21","objectID":"/go/:11:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"單執行緒 我們先來看看一般的單執行緒 func say(s string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { say(\"world\") say(\"hello\") } $ go run . world world hello hello 在單執行緒下，每行程式碼都會依照順序執行。 單執行緒 (Go 的並發：Goroutine 與 Channel 介紹)\" 單執行緒 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"多執行緒 在多執行緒下，最多可以同時執行與 CPU 數相等的 Goroutine。要如何使用多執行緒，使用 goroutine 來執行多併發，只要使用 go 這個關鍵字來執行 func 就可以了 ! func say(s string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\"world\") say(\"hello\") } $ go run . hello world world hello 如此一來, say(\"world\") 會跑在另一個執行緒(Goroutine)上，使其並行執行。 多執行緒 (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"等待 多執行緒下，經常需要處理的是執行緒之間的狀態管理，其中一個經常發生的事情是等待。 例如A執行緒需要等B執行緒計算並取得資料後才能繼續往下執行，在這情況下等待就變得十分重要。我們會介紹三個等待的方式，並說明其缺點。 time.sleep：休眠指定時間 sync.WaitGroup：等待直到指定數量的 Done() 呼叫 Channel 阻塞： Channel 阻塞機制，使用接收時等待的特性避免執行緒繼續執行 time.sleep 使 Goroutine 休眠，讓其他的 Goroutine 在 main 結束前有時間執行完成。 func say(s string) { for i := 0; i \u003c 2; i++ { fmt.Println(s) } } func main() { go say(\"world\") go say(\"hello\") time.Sleep(5 * time.Second) } $ go run . world world hello hello 缺點：休息指定時間可能會比 Goroutine 需要執行的時間長或短，太長會耗費多餘的時間，太短會使其他 Goroutine 無法完成。 time.sleep (Go 的並發：Goroutine 與 Channel 介紹)\" time.sleep (Go 的並發：Goroutine 與 Channel 介紹) sync.WaitGroup func say(s string, wg *sync.WaitGroup) { defer wg.Done() for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { wg := new(sync.WaitGroup) wg.Add(2) go say(\"world\", wg) go say(\"hello\", wg) wg.Wait() } $ go run . hello world world hello 在程式碼尾端加上 wg.Wait()，需要讓他達成一些條件，才可以往後執行，而這個條件，就是收到 wg.Done() 的呼叫次數。而這個次數，即是 wg.Add(2) 裡的數字2。 優點：避免時間預估的錯誤 缺點：需要手動配置對應的數量 sync.WaitGroup (Go 的並發：Goroutine 與 Channel 介紹)\" sync.WaitGroup (Go 的並發：Goroutine 與 Channel 介紹) Channel 阻塞 Channel 原為 Goroutine 溝通時使用的，但因其阻塞的特性，使其可以當作等待 Goroutine 的方法。 func say(s string, c chan string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } c \u003c- \"FINISH\" } func main() { ch := make(chan string) go say(\"world\", ch) go say(\"hello\", ch) \u003c-ch \u003c-ch } $ go run . hello world hello world 兩個 Goroutine ( say(\"world\", ch) 、 say(\"hello\", ch) ) ，因此需要等待兩個 FINISH 推入 Channel 中才能結束 Main Goroutine。 優點：避免時間預估的錯誤、語法簡潔 Channel 阻塞 (Go 的並發：Goroutine 與 Channel 介紹)\" Channel 阻塞 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Channel Channel 有兩個強大的處理能力，等待以及變數共享。Channel 可以想成一條管線，這條管線可以推入數值，並且也可以將數值拉取出來。 因為 Channel 會等待至另一端完成推入/拉出的動作後才會繼續往下處理，這樣的特性使其可以在 Goroutines 間可以同步的處理資料或是剛剛提到的等待 Channel 基本操作 ch := make(chan int) //創建一個Channel ch ch \u003c- u //將值u傳送到 Channel ch裡 v := \u003c- ch //從Channel ch中接收數據 ，並且將其賦值給變數v close(ch) //關閉channel 多執行緒下的共享變數 在執行緒間使用同樣的變數時，最重要的是確保變數在當前的正確性，在沒有控制的情況下極有可能發生問題。 func main() { total := 0 for i := 0; i \u003c 1000; i++ { go func() { total++ }() } time.Sleep(time.Second) fmt.Println(total) } $ go run . 986 為什麼會明明是用for 跑 1000 累加，但最後只有 900 多呢？我們來看一下下面的例子 多執行緒下的共享變數 - 錯誤 (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒下的共享變數 - 錯誤 (Go 的並發：Goroutine 與 Channel 介紹) 假設目前加到28，在多執行緒的情況下： goroutine1 取值 28 做運算 goroutine2 有可能在 goroutine1 做 total++ 前就取 total 的值，因此有可能取到 28 這樣的情況下做兩次加法的結果會是 29 而非 30 在多個 goroutine 裡對同一個變數total做加法運算，在賦值時無法確保其為安全的而導致運算錯誤，此問題稱為 競爭危害 (Race condition)。 使用 Channel 來保證變數的安全性 func main() { total := 0 ch := make(chan int, 1) ch \u003c- total for i := 0; i \u003c 1000; i++ { go func() { ch \u003c- \u003c-ch + 1 }() } time.Sleep(time.Second) fmt.Println(\u003c-ch) } $ go run . 1000 goroutine1 拉出 total 後，Channel 中沒有資料了 因為 Channel 中沒有資料，因此造成 goroutine2 等待 goroutine1 計算完成後，將 total 推入 Channel goroutine2 等到 Channel 中有資料，拉出後結束等待，繼續做運算 多執行緒下的共享變數 - Channel (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒下的共享變數 - Channel (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:12:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"參考資料 Go 官網 golang後端入門分享 從一知半解到略懂 Go modules 30天就Go(3)：操作指令及Hello World! Golang 基本型別、運算子和型別轉換 Go語言字符類型（byte和rune） golang初探 Go 的並發：Goroutine 與 Channel 介紹 ","date":"2022-03-21","objectID":"/go/:13:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"什麼是 Docker ? Docker 是一種軟體平台，它可以快速建立、測試和部署應用程式。為什麼可以快速建立呢？因為 Docker 會將軟體封裝到名為『容器』的標準單位。其中會包含程式庫、系統工具、程式碼、執行軟體所需的所有項目。 剛剛有提到容器 (Container)，是一種虛擬化技術，它高效率虛擬化及易於遷移和擴展的特性，非常適合現代雲端的開發及佈署。那 Container 與傳統的虛擬機有什麼差別呢？我們來看看下面這張圖 Container 與 VM 的差異\" Container 與 VM 的差異 可以看到 Container 是以應用程式為單位，而 VM 則是以作業系統為單位。Container 是一個封裝了相依性資源與應用程式的執行環境 ; VM 則是一個配置好 CPU、RAM 與 Storage 的作業系統，為了更好的做區別，我把 Container、VM 兩個差別用表格來說明～ 區別比較 Container VM 單位 應用程式 作業系統 適用服務 多使用於微服務 使用較大型的服務 硬體資源 是以程式為單位，需要的硬體資源很少 VM 會先佔用 CPU、RAM 等等硬體資源，不管有沒有使用都會先佔用 造成衝突 Container 間是彼此隔離的，因此在同一台機器可以執行不同版本的服務 會因為版本不同造成環境衝突 系統支援數量 單機支援上千個容器 一般最多幾十個 優點 1 . Image 較小，通常都幾MB 2 . 啟動速度快，通常幾秒就可以生成一個 Container 3 . 更新較為容易，只需要利用新的 Image 重新啟動就會更新了 1 . 因為硬體層以上都虛擬化，因此安全性相對較高 2 . 系統選擇較多，在 VM 可以選擇不同的OS 3 . 不需要降低應用程式內服務的耦合性，不需要將程式內的服務個別拆開來部署 缺點 1 . 安全性較 VM 差，因為環境與硬體都與本機共用 2 . 在同一台機器中，每一個 Container 的 OS 都是相同的，無法一個為 Windows、一個為 Linux，還是依賴 Host OS 3 . Container 通常會切成微服務的方式作部署，在各元件中的網路連結會比較複雜 1 . Image 的大小通常 GB 以上，比 Container 大很多 2 . 啟動速度通常要花幾分鐘，因此服務重啟速度較慢 3 . 資源使用較多，因為不只程式本身，還要將一部分資源分給 VM 的作業系統 總結 更快速的交付和部署：對於開發和維運人員來說，最希望就是一次建立或設定，可以再任意地方正常運行。開發者可以使用一個標準的映像檔來建立一套開發容器，開發完成之後，維運人員可以直接使用這個容器來部署程式。Docker 容器很輕很快！容器的啟動時間都是幾秒中的事情，大量地節約開發、測試、部署的時間。 更有效率的虛擬化：Docker 容器的執行不需要額外的虛擬化支援，它是核心層級的虛擬化，因此可以實作更高的效能和效率。 更輕鬆的遷移和擴展：Docker 容器幾乎可以在任意的平台上執行，包括實體機器、虛擬機、公有雲、私有雲、個人電腦、伺服器等。 這種兼容性可以讓使用者把一個服務從一個平台直接遷移到另外一個。 更簡單的管理：使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分發和更新，從而實作自動化並且有效率的管理。 ","date":"2022-03-14","objectID":"/docker/:1:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 基本概念 映像檔 (Image) 容器 (Container) 倉庫 (Repository) 這三個是 Docker 最基本的組成，了解後就可以知道整個 Docker 的生命週期。 ","date":"2022-03-14","objectID":"/docker/:2:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"映像檔 (Image) Docker 映像檔是一個唯獨的模板。 例如：一個映像檔可在包含一個完整的 Linux 作業系統環境，裡面可以只安裝 Nginx 或使用者會使用到的其他應用程式。 我們會使用映像檔來建立 Docker 的容器 (Container) ，Docker 也提供很簡單的機制來建立映像檔或是更新現有的映像檔，也可以去下載別人已經做好的映像檔。 ","date":"2022-03-14","objectID":"/docker/:2:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"容器 (Container) Docker 是利用容器來執行應用程式。 每一個容器都是由映像檔所建立的的執行程式。它可以被啟動、開始、停止、刪除。且每一個容器都是相互隔離的，不會相互影響。 ","date":"2022-03-14","objectID":"/docker/:2:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"倉庫 (Repository) 倉庫是集中放置映像檔的所在地，倉庫分為公開倉庫 (Public) 和 私有倉庫 (Private) 兩種形式。最大的倉庫註冊伺服器當然是 Docker hub，存放數量龐大的映像檔供使用者下載，使用者也可以在本地網路內建立一個私有倉庫。可以將倉庫的概念理解成跟 Git 相似。 倉庫與倉庫註冊伺服器 (Registry) 的不同 倉庫註冊伺服器 (Registry) 裡面可以存放很多的倉庫，每一個倉庫又包含了很多的映像檔，每一個映像檔有不同的標籤 (tag) 。 舉個例子：Docker hub 是最大的倉庫註冊伺服器 (Registry) ，裡面又有很多不同的倉庫，像是 mariadb ，裡面又會包含很多的映像檔，以及不同的標籤 (tag)。 我們可以看到 Docker 的 Logo 是一隻鯨魚，背上揹了一堆貨櫃。鯨魚就代表倉庫註冊伺服器 (Registry)，背上的貨櫃就是每一個倉庫 (Repository)。 Docker Logo 介紹\" Docker Logo 介紹 ","date":"2022-03-14","objectID":"/docker/:2:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 實作 本章節會介紹 Docker 三大組件映像檔 (image)、容器 (Container)、倉庫 (Repository) 要如何實際操作，以及他們的關聯性是什麼～ ","date":"2022-03-14","objectID":"/docker/:3:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"映像檔 (Image) 本小節會介紹有關映像檔的內容，包括： 如何從倉庫取得映像檔 如何管理本地主機上的映像檔 映像檔實作 (Dockerfile) 如何從倉庫取得映像檔 我們可以先到 Docker hub 上面看看有什麼服務或程式想要下載來做使用 [ 詳細介紹會放到倉庫 (Repository) 章節]，找到想要的服務，我們可以下 docker pull {要下載的服務、程式名稱} ，我們這邊就先下載 Mysql 這個映像檔。 mysql $ docker pull mysql Using default tag: latest latest: Pulling from library/mysql 15115158dd02: Pull complete .... 省略 .... Digest: sha256:b17a66b49277a68066559416cf44a185cfee538d0e16b5624781019bc716c122 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest 由於我們下載的沒有加任何的 tag ，也就是版本，所以我們都是下載最新版 latest ，如果想要下載特定版本，可以在服務名稱後面加上 :{版本} ，就可以下載對應的版本囉！ 如果有標記 Official Image 就代表是官方釋出的映像檔 ~ 在穩定性以及安全上更有保障，所以大家可以優先下載歐！ Docker hub 下載 Image\" Docker hub 下載 Image 管理本地主機上的映像檔 查看映像檔 (images) 當我們下載好映像檔後，可以使用 docker images 來列出本機已下載的映像檔。 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE php latest d6229b88aa29 3 days ago 484MB mysql latest 826efd84393b 6 days ago 521MB nginx latest c919045c4c2b 13 days ago 142MB 我們來看看都列出哪些訊息吧！ REPOSITORY：來自於哪一個倉庫，像是 php、mysql、nginx。 TAG：映像檔的標籤，因為我們都下載最新版本所以是 latest。 IMAGE ID：它的唯一 ID 號碼。 CREATED：建立時間。 VIRTUAL SIZE：映像檔大小。 儲存映像檔 (save) 想要儲存映像檔，可以使用 docker save {映像檔名稱} \u003e {檔案名稱}.tar，來做儲存。 $ docker save mysql \u003e mysql.tar $ ls | grep 'mysql' mysql.tar 刪除映像檔 (rmi) 想要刪除映像檔，可以使用 docker rmi {映像檔名稱} 來做刪除。 $ docker rmi demo-image Untagged:demo-image:latest Deleted: sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37 想要同時刪除映像檔時，可以先用 docker images -aq 列出全部映像檔的 IMAGE ID，再一起刪除。 docker rmi -f $(docker images -aq) 注意！刪除映像檔(Image)時，要先用 docker rm {容器} 去刪除所有依賴這個映像檔的容器。 接著要怎麼建立自己的映像檔呢？我們要使用 Dockerfile 來建立映像檔。 映像檔實作 撰寫 Dockerfile 映像檔 Dockerfile 是一種文字格式的設定檔，可以透過 Dockerfile 快速建立自訂的映像檔，換句話說，Dockerfile 就像是建置 Docker Image 的腳本。 舉個例子：可以把自己想像成一位設計師，設計好房子的格局、擺飾等，畫好設計圖 (Dockerfile) 後，最後請師傅 (Docker) 依你的構思完成就可以了。 我們就來開始實作一個 Dockerfile 吧 ~ 我們先創建一個來放 Dockerfile 的資料夾，可以直接在路徑下建立出映像檔 mkdir demo-dockerfile cd demo-dockerfile/ Dockerfile 結構，大致可以分為四個部分 基礎映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時需執行的指令 我們有說過 Dockerfile 是一個文字格式的設定檔，所以我們用 vim 來編寫 Dockerfile。 vim Dockerfile # 基礎映像檔資訊 FROM nginx:latest # 維護者資訊 LABEL maintainer=\"880831ian@gmail.com\" # 映像檔操作指令 RUN apt-get update -y\\ \u0026\u0026 apt-get install nginx -y # 運行時容器提供服務的通道 EXPOSE 80 # 容器啟動時需執行的指令 CMD [\"nginx\",\"-g\",\"daemon off;\"] FROM nginx:latest 第一行為必要的指定基礎映像檔，這邊使用 nginx 作為基礎映像檔，我們用最新版本，所以是 latest。 LABEL maintainer=\"880831ian@gmail.com\" 維護者資訊想不也是不可以少的，這邊也可以輸入 Email 資訊，只是要注意的是此資訊會寫入產出映像檔的Author名稱屬性中。 RUN apt-get update -y\\ \u0026\u0026 apt-get install nginx -y 這邊是最重要的部分，想要在映像檔案上設定或安裝都需要將命令寫在這，格式必須依 RUN ，RUN 指令後面放 Linux 指令，如果指令太長可以使用\\來換行。 -y 是在安裝 Nginx，會同意所有進行中所出現的問題。 EXPOSE 80 設定運行時容器提供服務的通道。 CMD [\"nginx\",\"-g\",\"daemon off;\"] 最後就是啟動指定容器時預設執行的指令，格式是 CMD [“executable”,“param1”,“param2”]。 Docker 運行 Nginx 時為什麼要使用 daemon off; 因為 Docker 容器啟動時，默認會把容器內部第一個進程，作爲 docker 容器是否正常運行的依據，如果 docker 容器 pid = 1 到進程就掛了，docker 就會退出！ Docker 未執行自定義的 CMD 之前， Nginx 的 pid 是 1，執行到 CMD 之後，Nginx 就在後台運行，bash 或是 sh 的腳本就會變成 pid =1 。 所以一但執行完 CMD，Nginx 容器就會退出了，所以才需要加上 -g daemon off;。 在 Nginx 官方的 Docker Repository 也有說明，在 Complex configuration 內。 順便說一下使用 Dockerfile 的優點：1 . 可以進行 Git 版控，讓你管理或分享更方便 2 . 佔用容量小，因為只是純文字檔而已。 使用 Dockerfile 建立映像檔 我們已經撰寫完 Dockerfile 檔案了，接下來要執行來產生映像檔，我們要使用 docker build 來建立，我們一起來看看吧 docker build -t demo-image . 因為我們在 dockerfile 的目錄下，所以直接使用 “.” 來做建立動作，也可以使用 -f 來指定 dockerfile 的路徑位置。使用 -t 來設定映像檔的名稱，我們這邊取名叫 demo-image。 [+] Building 2.7s (7/7) FINISHED =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 44B 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [internal] load metadata for docker.io/library/nginx:latest 2.6s =\u003e [auth] library/ubuntu:pull token for registry-1.docker.io 0.0s =\u003e [1/2] FROM docker.io/library/nginx:latest@sha256:8ae9bafbb64f63a50caab98fd3a5e37b3eb837a3e0780b78e5218e63193961f 0.0s =\u003e CACHED [2/2] RUN apt-get update -y \u0026\u0026 apt-get install nginx -y 0.0s =\u003e exporting to image 0.0s =\u003e =\u003e exporting layers 0.0s =\u003e =\u003e writing image sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37 0.0s =\u003e =\u003e n","date":"2022-03-14","objectID":"/docker/:3:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"容器 (Container) 我們在介紹指令前，先來了解一下 Dockerfile、Docker Image、Docker Container 這三個的關係，可以先參考以下圖片 容器 Container 組成\" 容器 Container 組成 我們在啟動 Container 時，會有這三個部分組成，最底層是映像檔 (Image)，這一層主要是透過撰寫 Dockerfile 之後 build 出來的 Docker Image，就像我們前面說的它是一個唯獨的檔案。執行啟動了 Docker Container，就會加上第二層，就是需要先 Init Container 的設定，例如是 hostname、環境變數、網路連接等系統設定，最後最上層再加上一層讓使用者可以在此層去讀寫資料。 有關於容器 (Container) 的指令非常多，光是簡單的 run 就有很多參數，我們先列出比較常用且基本的 Container 指令～ Container 執行時的操作 執行容器 (run) 我們想要創建一個新的容器並運行，就可以使用 docker run，我們來看看他可以使用哪些參數吧！ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS 說明： 參數 描述 -d 後台運行容器 -i 命令互動模式，通常與 -t 同時使用 -t 為容器重新分配一個假裝的輸入終端，通常與 -i 同時使用 -p 指定容器與本機的Port ，格式是 主機 Port : 容器 Port –name=\"{名稱}\" 為容器設定名稱 –net=\"{網路類型}\" 指定容器的網路連接類型，支援 bridge/host/none/container 四種模式 –link=\"{其他容器}\" 添加連接到另一個容器 –volume,-v 將容器檔案路徑映射到本地端，格式是 本機路徑：容器路徑 我們啟動我們下載好的 Nginx 來試試看吧！ $ docker run -d -p 7777:80 --name=\"demo-nginx\" -v /Users/ian_zhuang/Desktop/data:/var/www/html nginx 31a4a4a56e3ef2fb75d538c4c9eea4914ac506a84a6ff97e1fbbb6c3213cc6b7 我們將 Nginx 容器在背景執行，且將預設的80 Port 與本機的7777 Port 綁在一起，讓我們在本機瀏覽7777 Port 會直接導向容器的80Port，設定容器的名字叫做 “demo-nginx\" ，我們 Nginx 容器的檔案路徑映射到本地端的桌面 data 資料夾，我們就可以在本機新增檔案同步到容器中。 顯示容器 (ps) 使用 docker ps 來檢查一下是否啟動成功 (ps 可以顯示映像檔的基本資訊，如果沒有加 -a 只會顯示執行中的容器) $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 31a4a4a56e3e demo-image \"nginx -g 'daemon of…\" About a minute ago Up About a minute 0.0.0.0:7777-\u003e80/tcp demo-nginx 接著我們測試是否有把桌面 data 資料夾掛到容器的路徑，我們先在 data 新增一個 hello.html ，裡面隨意輸入，瀏覽一下 http://127.0.0.1:7777/hello.html ，看看是否成功。 容器 Container -volume 測試\" 容器 Container -volume 測試 顯示容器紀錄 (logs) 想要看到我們執行 Container 的紀錄，可以使用 logs 指令來顯示。 $ docker logs demo-nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh ... 省略 ... 2022/03/15 09:27:51 [notice] 1#1: start worker process 33 2022/03/15 09:27:51 [notice] 1#1: start worker process 34 2022/03/15 09:27:51 [notice] 1#1: start worker process 35 刪除容器 (rm -f) 想要刪除不需要的 Container，可以使用 rm 指令來做刪除，-f 是強制刪除容器。 $ docker rm -f demo-nginx demo-nginx 進入容器 (exec) 想要進入 container 來查看資料或是修改檔案，可以使用 exec 來進入容器中。 $ docker exec -it demo-nginx /bin/bash root@31a4a4a56e3e:/# ls bin boot dev docker-entrypoint.d docker-entrypoint.sh etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@31a4a4a56e3e:/# cd usr/bin/ root@31a4a4a56e3e:/usr/bin# pwd /usr/bin 匯出檔案 (export) 我們前面有提到說，如果刪除了容器，以前寫入的資料也會不見，如果想要輸出資料，可以使用 export 將可讀可寫的那一層匯成檔案。 $ docker export demo-nginx \u003e demo-nginx.tar $ ls | grep 'demo' demo-nginx.tar save 跟 export 的區別 還記得我們在儲存映像檔的時候有介紹到 save 嗎，那他跟 export 的區別是什麼呢？我們可以理解成 save 是把 Docker Image 原始檔做儲存，export 是把修改 Docker Image 的內容都一併儲存。 匯入檔案 (import) 有匯出檔案，當然也有匯入檔案拉，可以使用 import 將我們匯出的檔案匯入 Docker Image 裡面。 $ cat ~/Desktop/demo-nginx.tar| docker import - import-nginx sha256:7106935f0bfbdbb84f9eb20edb8cdb2c53207f5e0963f6a4e89d8267e9d98c56 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE import-nginx latest 7106935f0bfb 19 seconds ago 140MB Container 的狀態 檢查容器狀態 (inspect) 想要查看容器的狀態數據，可以使用 inspect 來顯示。 [ { \"Id\": \"sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37\", \"RepoTags\": [ \"demo-image:latest\" ], \"RepoDigests\": [], \"Parent\": \"\", \"Comment\": \"buildkit.dockerfile.v0\", \"Created\": \"2022-03-15T03:02:26.8321887Z\", \"Container\": \"\", \"ContainerConfig\": { \"Hostname\": \"\", \"Domainname\": \"\", \"User\": \"\", .... 省略 .... 查看容器的CPU、記憶體及網路使用 (stats) 想要查看容器的CPU、記憶體及網路使用，可以使用 stats 來顯示。 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 31a4a4a56e3e demo-nginx 0.00% 5.797MiB / 1.939GiB 0.29% 6.29kB / 2.83kB 1.46MB / 20.5kB 5 ","date":"2022-03-14","objectID":"/docker/:3:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"倉庫 (Repository) 我們在映像檔的章節有使用 docker pull 來下載別人的映像檔來使用，那我們要如何把我們做好的上傳上去 Docker hub 呢！(由於 Docker hub 是公開平台，所以大家都可以自由的下載映像檔，所以是公司機密的映像檔，就要避免上傳歐！) $ docker login Authenticating with existing credentials... Login Succeeded 由於我有下載桌面版的 Docker ，所以登入時不需要再另外設定！ 我們在上傳到 Docker hub 之前，需要先修改 Image 的 tag ，格式 docker tag {Image Name} {DockerHub帳號}/{想要取的 Image Name} $ docker images | grep 'demo-image' demo-image latest 1f56acbcbe9e 24 hours ago 166MB $ docker tag demo-image 880831ian/demo-image $ docker images | grep 'demo-image' 880831ian/demo-image latest 1f56acbcbe9e 24 hours ago 166MB demo-image latest 1f56acbcbe9e 24 hours ago 166MB 接下來就使用 docker push，將映像檔上傳到 Docker hub 上！ $ docker push 880831ian/demo-image Using default tag: latest The push refers to repository [docker.io/880831ian/demo-image] 7722c88c8d69: Pushed 68a85fa9d77e: Mounted from library/ubuntu latest: digest: sha256:814caacaf3dad3eccb43dc9bcad635d0473bd5946295d40ca1ec23d13a5f6d0f size: 741 我們也登入 Docker hub 看一下，是不是真的上傳成功了～ 容器 Container -volume 測試\" 容器 Container -volume 測試 ","date":"2022-03-14","objectID":"/docker/:3:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 進階 本章節會分成三個常用功能來說明 Volumes 介紹 Network 模式介紹和比較 Docker-compose 介紹與實作 ","date":"2022-03-14","objectID":"/docker/:4:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Volumes 介紹 我們在先前介紹 Container 時，也有說到，Container 會分成 Image 層、Init 層以及使用者可讀可寫層的這三層。當我們將 Container 刪除後，存放在 Docker Container 上的資料也會不見，雖然可以用 export 來儲存，但我們應該在根本上解決問題。 所以我們可以使用兩種方式來解決！ 在執行 docker run 指令時加入 -v 參數，將 Container 的檔案路徑映射到本地端的檔案路徑。 在撰寫 Dockerfile 時，加入 VOLUME 指令，可以將資料存放在實體主機上。使用這個方法還要搭配我們介紹 Container 的狀態 \u003e 檢查容器狀態 (inspect) ，來查詢本地端檔案的存放路徑在哪。 使用 -v 指令將容器映射到本地端 在使用 docker run 指令時，使用 -v 將容器檔案路徑映射到本地的檔案路徑。 $ docker run -it -v /Users/ian_zhuang/Desktop/data:/storage centos /bin/bash latest: Pulling from library/centos Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177 Status: Downloaded newer image for centos:latest [root@a99b41fba3ca /]# 我們在著面的 data 資料夾隨意新增檔案或是資料，再進入 Docker Container 內的 /storage (該檔案是因為使用 -v 而新增的資料夾) ，看看有沒有同步新增。 [root@a99b41fba3ca /]# cd storage [root@a99b41fba3ca storage]# pwd /storage [root@a99b41fba3ca storage]# ls 1.html 2.html 3.html Dockerfile VOLUME 使用 我們先打開上次的 Dockerfile 檔案，在基礎映像檔資訊的底下使用 VOLUME 指令，加入 storage 資料夾，再將 Image Build 起來，啟動 Container，在 /storage 裡面隨便新增資料，最後我們在用 docker inspect 指令來找映射在本地端的路徑。 在基礎映像檔資訊的底下使用 VOLUME 指令，加入 storage 資料夾 # 基礎映像檔資訊 FROM ubuntu:latest VOLUME [\"/storage\"] .... 省略 .... 建立映像檔 $ docker build -t demo-image:v2 . [+] Building 1.3s (6/6) FINISHED =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 44B 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [internal] load metadata for docker.io/library/ubuntu:latest 1.2s =\u003e [1/2] FROM docker.io/library/ubuntu:latest@sha256:8ae9bafbb64f63a50caab98fd3a5e37b3eb837a3e0780b78e5218e63193961f9 0.0s =\u003e CACHED [2/2] RUN apt-get update -y \u0026\u0026 apt-get install nginx -y 0.0s =\u003e exporting to image 0.0s =\u003e =\u003e exporting layers 0.0s =\u003e =\u003e writing image sha256:0618bb2685ecfe200d9df4a91380d482031352d0e00cbfdf70fcd063aa8654fa 0.0s =\u003e =\u003e naming to docker.io/library/demo-image:v2 啟動 Container，並在 /storage 內新增隨意資料 $ docker run -it demo-image:v2 /bin/bash root@4f8712562dfe:/# echo \"Hello ian\" \u003e /storage/helloworld.txt root@4f8712562dfe:/# ll /storage total 12 drwxr-xr-x 2 root root 4096 Mar 16 05:39 ./ drwxr-xr-x 1 root root 4096 Mar 16 05:38 ../ -rw-r--r-- 1 root root 10 Mar 16 05:39 helloworld.txt 使用 inspect 指令，來找到 Volume 在本地端映射的資料夾路徑，看看裡面有沒有我們在 Container 裡面新增的資料吧 $ docker inspect -f '{{.Mounts}}' 4f8712562dfe [{volume 4fe10ca3f...省略 /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data /storage local true }] $ docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh / # cd /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data # ls helloworld.txt mac OS 找不到 /var/lib/docker/volumes 由於 macOS 下的 docker 實際是在 vm 裡又多加一層，所以沒辦法直接訪問 /var/lib/docker/volumes，必須先透過以下指令進入 VM 中。 docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh 詳細內容可以參考 Where is /var/lib/docker on Mac/OS X。 容器與容器之間資料共享 如何啟用容器與容器之間的資料共享，可以用以下方式 先啟動第一個容器指令如下 docker run -it -v /data --name=container1 centos /bin/bash [root@ a0307ce757ca /]# 另二個容器指令如下 docker run -it --volumes-from container1 --name=container2 centos /bin/bash [root@720d57983cd4 /]# --volumes-from 參數指定 container1 的資料會與 container2 做共享。 我們在第一個容器，進入 /data 資料夾，隨機輸入資料 [root@a0307ce757ca /]# cd /data/ [root@a0307ce757ca data]# echo \"ian~\" \u003e hello.txt 再來看一下第二個容器 /data 資料夾，是否有我們在容器(a0307ce757ca)產生的資料 [root@720d57983cd4 /]# cat /data/hello.txt ian~ ","date":"2022-03-14","objectID":"/docker/:4:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Network 模式和比較 在執行 docker run 其中一個參數是 --net ，他可以設定 Container 要使用哪一種的網路模式，以下分別說明這些網路模式 none：在執行 Container 時，網路功能是關閉的，所以無法與此 Container 連線。 container：使用相同的 Network Namespace ，假設 Container 1 的 IP 是 172.17.0.2，那 Container 2 的 IP 也是 172.17.0.2。 host：Container 的網路設定和實體主機使用相同的網路設定，所以 Container 裡面也可以修改實體機器的網路設定，因此使用此模式需要考慮網路安全性上的問題。 bridge：Docker 預設就是此網路模式，這個網路模式就像是 NAT 的網路模式，例如實體主機的 IP 是 192.168.1.10 它會對應到 Container 裡面的 172.17.0.2，在啟動 Docker 的服務時會有一個 docker0 的網路卡來做此網路的橋接。 overlay：Container 之間可以在不同的實體機器上做連線，例如 Ｈost 1 有一個 Container 1 ，然後 Host 2 有一個 Container 2，Container 1 可以直接使用 overlay 的網路模式和 Container 2 做網路連線。 macvlan：可以直接分配實體網卡的 MAC address 給特定的 Container，讓 Container 透過實體的網卡使用網路。 那我們就來實作每一個網路模式吧！ none 我們使用 docker run指令，在後面加入參數 --net=none ，我們建立 jonlabelle/network-tools (裡面有很多網路測試工具)。 $ docker run -it --net=none jonlabelle/network-tools [docker@network-tools]$ ifconfig lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 .... 省略 .... 可以看到我們使用 ifconfig 查詢，只有本地端的 127.0.0.1 IP，我們在使用 ping 來測試 google 網站吧 [docker@network-tools]$ ping www.google.com ping: www.google.com: Try again container 我們先啟動一個名為 container1 的容器 docker run --name container1 -it jonlabelle/network-tools 再開啟另一個 Terminal 來啟動 container2 的容器，並設定相同的 Network Namespace docker run --name container2 --net=container:container1 -it jonlabelle/network-tools 一樣使用 ifconfig 查詢，可以發現兩個容器的 IP 都是相同的 eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 .... 省略 .... host 在執行 docker run 指令時，在後面加入參數 --net=host ，來測試 host 模式 docker run --net=host -it jonlabelle/network-tools 可以看到 Container 的網路資訊和實體主機的網路資訊是相同的結果 [docker@network-tools]$ ifconfig br-36a27cab1817 Link encap:Ethernet HWaddr 02:42:20:DF:DB:FD inet addr:172.20.0.1 Bcast:172.20.255.255 Mask:255.255.0.0 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 .... 省略 .... host 網路模式\" host 網路模式 bridge 在執行 docker run 指令時，在後面加入參數 --net=bridge ，來測試 bridge 模式 docker run --net=bridge -it jonlabelle/network-tools docker 會新增一個虛擬網卡作為容器網路對外的出口，預設名稱為 docker0，docker0 會跟本機的對外網卡(圖中的 eth0 )相連，藉此取得對外連線的能力，也因為每一個容器都會使用一個 veth device 與 docker0 相連，所以也具備對外連線的能力。 bridge 網路模式\" bridge 網路模式 overlay 下圖是說明 Host1 實體主機裡面有 Container1，然後 Host2 實體主機裡面有 Container2，可以透過 Docker overlay 模式將 Container1 和 Container2 連接做溝通。另外還需要一個 Consol 來存連線的資料庫，在使用 overlay 時要先在 Docker 做設定，這樣才能存放 overlay 網路模式的連線資訊。 overlay 網路模式\" overlay 網路模式 macvlan macvlan 的原理就是在本機的網卡上虛擬出很多個子網卡，通過不同的 MAC 位置在數據鏈路層進行網路資料的轉發。 macvlan 網路模式\" macvlan 網路模式 ","date":"2022-03-14","objectID":"/docker/:4:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker-compose 我們在執行多個容器時，需要重複的下 run 指令來執行，以及容器與容器之間要做關聯也要記得每一個之間要怎麼連結，會變得很麻煩且不易管理，所以有了 docker-compose 可以將多個容器組合起來，變成一個強大的功能。 只要寫一個 docker-compose.yml 把所有會使用到的 Docker image 以及每一個容器之間的關聯或是網路的設定都寫上去，最後再使用 docker-compose up 指令，就可以把所有的容器都執行起來囉！ 我們就直接來實作我們這次的標題，要使用 docker-compose 來整合 PHP MySQL Nginx 環境。 我們先開啟一個資料夾，取名叫 docker-compose ，來放置我們的 docker-compose 檔案 接著新增 docker-compose.yml 檔案，要準備來撰寫我們的設定檔囉！ 由於內容有點長，所以我分段說明，(這邊有放已經寫好的檔案歐) 檔案目錄 . ├── Docker-compose.yml ├── docker-volume │ └── html │ ├── index.php │ └── info.php ├── nginx │ ├── Dockerfile │ └── default.conf └── php └── Dockerfile version:\"3.8\"services:...省略 .... 可以看到一開頭，會先寫版本，這邊代表的是會使用 3.8 版本的設定檔，詳細版本對照可以參考 Compose file versions and upgrading services 可以設定用來啟動多的容器，裡面我們總共放了三個容器，分別是 nginx、php、mysql 。 那我們來看看 nginx 裡面放了什麼吧！我會依照程式碼往下說明，有不清楚的可以底下留言！ nginx nginx:build:./nginx/container_name:nginxports:- 7777:80volumes:- ./docker-volume/log/:/var/log/nginx/ nginx 的 build 就是要執行這個 nginx 容器的映像檔，還記得我們也可以使用 Dockerfile 來撰寫映像檔案嗎！? 由於我們還要設定其他內容，所以特別另外拉一個 nginx 資料夾來放置，裡面放了兩個檔案，分別是 Dockerfile、default.conf。 Dockerfile 檔案裡面會使用 nginx 版本 1.20 ，並將 default.conf 複製到容器的 /etc/nginx/conf.d/default.conf 來取代設定。 以及我們使用 ports 將容器80 Port 指向本機 7777 Port ，格式是 本機 Port : 容器 Port， 再使用 volumes 來設定我們 nginx 容器 log 資料夾映射到本機的 ./docker-volume/log/ 資料夾。 php php:build:./php/container_name:phpexpose:- 9000volumes:- ./docker-volume/html/:/var/www/html/ php 的 build 是要執行這個 php 容器的映像檔，由於我們還要設定其他內容，所以特別另外拉一個 php 資料夾來放置 Dokcerfile。 Dockerfile 檔案裡面會使用 php 版本 7.4-fpm，並且在容器執行 docker-php-ext-install、mysqli。 並將 Port 9000 發佈於本機，再使用 volumes 來設定 /var/www/html 網站根目錄映射到本機的 ./docker-volume/html/ 資料夾。 mysql mysql:image:mysql:8.0.28container_name:mysqlvolumes:- ./docker-volume/mysql/:/var/lib/mysqlenvironment:MYSQL_ROOT_PASSWORD:secretMYSQL_DATABASE:mydbMYSQL_USER:myuserMYSQL_PASSWORD:password mysql 使用的映像檔是 mysql 版本是 8.0.28，我們為了要保留資料庫的資料，所以將容器的 /var/lib/mysql 映射到本地端 ./docker-volume/mysql 資料夾。 最後的環境變數，設定 root 帳號的登入密碼，以及要使用的資料庫、使用者的帳號、使用者的密碼。 最後在上面的 (這邊有放已經寫好的檔案歐) 裡面還有多一個 docker-volume/html 的資料夾，就是我們剛剛映射到本地端的資料夾，資料夾內已經放有連線測試的檔案，輸入網址 http://127.0.0.1:7777/index.php，如果開啟後有顯示下方畫面，就代表我們成功用 docker-compose 將 PHP MySQL Nginx 整合再一起囉！ 測試是否成功用 docker-compose 整合 PHP MySQL Nginx\" 測試是否成功用 docker-compose 整合 PHP MySQL Nginx ","date":"2022-03-14","objectID":"/docker/:4:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"參考資料 Docker 官網 什麼是 Docker？ Docker－－從入門到實踐 Dockerfile 建立自訂映像檔 — 架起網站快速又簡單（一） 用30天來介紹和使用 Docker Docker 網路簡介 Docker-compose Giving static IP in network mode : bridge ","date":"2022-03-14","objectID":"/docker/:5:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"本篇是 Laravel 介紹 的進階篇，由於有些說明介紹會沿用上一篇的內容，建議要先瀏覽過上一篇呦～ (可以從這裡下載最後程式碼！) ","date":"2022-03-08","objectID":"/laravel-advanced/:0:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"Laravel 內建會員系統 Laravel 這個框架，很方便的地方就是，他可以將我們常用的帳號登入註冊等功能內建在 Laravel 框架內，那我們來看一下要怎麼使用吧。(本篇 Laravel Framework：5.4.36) 它的配置文件在 config/auth.php ，其中包含了用於調整認證服務行為或是標注選項配置等。 要怎麼開始呢!? 先使用 artisan 指令產生我們要的檔案以及路由吧！ $ php artisan make:auth 主要會產生 new file: app/Http/Controllers/HomeController.php new file: resources/views/auth/login.blade.php new file: resources/views/auth/passwords/email.blade.php new file: resources/views/auth/passwords/reset.blade.php new file: resources/views/auth/register.blade.php new file: resources/views/home.blade.php new file: resources/views/layouts/app.blade.php modified: routes/web.php 其中 routes/web.php 多了： Auth::routes(); Route::get('/home', 'HomeController@index')-\u003ename('home'); views 底下放的就是顯示的畫面，所以現在可以瀏覽 登入頁面：http://127.0.0.1:8000/login 註冊頁面：http://127.0.0.1:8000/register 其他像是 controller 或是 migration 都已經內建在裡面了，稍後實作會講到！ ","date":"2022-03-08","objectID":"/laravel-advanced/:1:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"實作 Migration 我們照上一篇的流程，由於 route 已經設定好，所以我們先來設定 migration ， 檔案就放在 database/migrations 底下的 {日期時間}_create_users_table.php ，我們來看一下預設的資料表有哪些欄位吧! public function up() { Schema::create('users', function (Blueprint $table) { $table-\u003eincrements('id'); $table-\u003estring('name'); $table-\u003estring('email')-\u003eunique(); $table-\u003estring('password'); $table-\u003erememberToken(); $table-\u003etimestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('users'); } 簡單看一下，他會建立一個名叫 users 的資料表，欄位分別有自動累加(id)、字串(name)、唯一字串(email)、字串(密碼)、rememberToken()、timestamps()。 那我們這次想要做的事，不使用 email 做登入，改成使用 username來當作登入驗證，所以我們把 name、email的欄位改成 public function up() { Schema::create('users', function (Blueprint $table) { $table-\u003eincrements('id'); $table-\u003estring('username')-\u003eunique(); $table-\u003estring('password'); $table-\u003erememberToken(); $table-\u003etimestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('users'); } 設定 username 欄位為唯一值，移除掉 email ，再加入一個 api_token 用於後續的 RESTful API 驗證。 使用 php artisan migrate 將 users 這個 table 給建起來。 因為我們修改 name、email 改成 username 這個欄位，所以我們也要修改一下 views 顯示的畫面，由於是簡單的 HTML 這邊就不再多描述，直接放上修改後的程式碼。 View Login.blade \u003cdiv class=\"form-group{{ $errors-\u003ehas('username') ? ' has-error' : '' }}\"\u003e \u003clabel for=\"username\" class=\"col-md-4 control-label\"\u003eUsername\u003c/label\u003e \u003cdiv class=\"col-md-6\"\u003e \u003cinput id=\"username\" type=\"text\" class=\"form-control\" name=\"username\" value=\"{{ old('username') }}\" required autofocus\u003e @if ($errors-\u003ehas('username')) \u003cspan class=\"help-block\"\u003e \u003cstrong\u003e{{ $errors-\u003efirst('username') }}\u003c/strong\u003e \u003c/span\u003e @endif \u003c/div\u003e \u003c/div\u003e Register.blade \u003cdiv class=\"form-group{{ $errors-\u003ehas('username') ? ' has-error' : '' }}\"\u003e \u003clabel for=\"username\" class=\"col-md-4 control-label\"\u003eUsername\u003c/label\u003e \u003cdiv class=\"col-md-6\"\u003e \u003cinput id=\"username\" type=\"text\" class=\"form-control\" name=\"username\" value=\"{{ old('username') }}\" required\u003e @if ($errors-\u003ehas('username')) \u003cspan class=\"help-block\"\u003e \u003cstrong\u003e{{ $errors-\u003efirst('username') }}\u003c/strong\u003e \u003c/span\u003e @endif \u003c/div\u003e \u003c/div\u003e Model 接下來到 app 底下找到 User.php 檔案，由於筆者習慣將 model 放到專屬的資料夾，不要讓他在 app 裡面流浪，所以會建立一個 Models 的資料夾，來存放所有的 models ，那移動原本的 model 有些有使用到它的路徑都要做修改，這邊以 User 檔案為示範。(因為後續會說到怎麼驗證登入 API ，所以上一篇的 Message model 也要記得修改歐！) 因為我們移動後，原本的路徑是 App 要改成 App\\Models，會影響到的程式有以下幾個 (附上片段程式碼) config/auth.php 約在70行左右 'providers' =\u003e [ 'users' =\u003e [ 'driver' =\u003e 'eloquent', 'model' =\u003e App\\Models\\User::class, //修改片段 ], config/services.php 約在33行左右 'stripe' =\u003e [ 'model' =\u003e App\\Models\\User::class, //修改片段 'key' =\u003e env('STRIPE_KEY'), 'secret' =\u003e env('STRIPE_SECRET'), ], database/factories/UserFactory.php 約在15行左右 $factory-\u003edefine(App\\Models\\User::class, function (Faker\\Generator $faker) { //修改片段 static $password; return [ 'name' =\u003e $faker-\u003ename, 'email' =\u003e $faker-\u003eunique()-\u003esafeEmail, 'password' =\u003e $password ?: $password = bcrypt('secret'), 'remember_token' =\u003e str_random(10), ]; }); app/Http/Controllers/Auth/RegisterController.php 約在5行左右 use App\\Models\\User; 都修改好了，我們就繼續來修改 User 這個 model ，將原本的 name、email ，修改成以下 \u003c?php namespace App\\Models; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ 'username', 'password', ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ 'password', 'remember_token', ]; } 裡面有一個是 fillable 跟 hiddem ，順便解釋一下這兩個是在做什麼 fillable：當使用者輸入這些 attribute 以外的參數(資料表的欄位)，就會發生錯誤。 hidden：想要限制能出現在陣列或是JSON 格式的屬性資料，比如密碼欄位等等，不想要顯示，只需要把該欄位加入 hidden。 再加碼一個 guarded：這個屬性與 fillable 相反，當使用者輸入該參數的值，就會被擋掉。以下這個例子是允許任何的 input 資料，但十分建議不要這樣。 protected $guarded = []; Controller 接下來是要修改我們的 controller，主要需要修改的有兩個，檔案在 app\\Http\\Auth 底下的 registerController 、 loginController 兩個檔案，我們先來修改 registerController 註冊功能，看一下原本的程式碼在做什麼事情。 RegisterController 原本程式碼 protected function validator(array $data) { return Validator::make($data, [ 'name' =\u003e 'requ","date":"2022-03-08","objectID":"/laravel-advanced/:1:1","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"驗證 RESTful API 是否登入 本篇會使用到上一篇的 RESTful API 留言板來進行修改，所以有興趣的朋友，可以先去看玩上一篇 Laravel 介紹 歐～ 接下來也會同時使用 Repository 設計模式來修改程式碼，那 Repository 設計模式是什麼呢，讓我先來介紹。 Repository 設計模式 還記得我們上一次，把所有的邏輯以及資料庫的處理的都放在 Controller 裡面嗎！如果只是單一個小專案，還可以這樣做沒關係，但專案越來越大，會使用的功能也越來越多，會造成 Controller 檔案肥大且難以維護，基於 SOLID 原則，我們應該要使用 Repository 設計模式來補助 Controller，將相關的資料庫邏輯放在不同的 Repository，方便中大型的專案做維護。 小知識 SOLID：簡單來說就是物件導向設定上為了讓軟體維護、開發變得更容易的五個準則的縮寫。 Single Responsibility Principle (SRP) 單一職責原則 Open-Closed Principle (OCP) 開放封閉原則 Liskov Substitution Principle (LSP) 里氏替換原則 Interface Segregation Principle (ISP) 介面隔離原則 Dependency Inversion Principle(DIP) 依賴反轉原則 SOLID目的也就是讓你程式碼達成低耦合、高內聚、降低程式碼壞味道，透過分離與clean code來提高可讀性會讓你的程式碼等同於設計文件，所以在修改或新增過程中降低產生Bug的機率，也可以較快的找到與解決出問題的地方，可以有效的減少技術債。 (資料來源：我該學會SOLID嗎?) 不太清楚沒關係，我們會慢慢介紹到！那我們先來看看這次要修改什麼呢！？ 我想要在使用 API 時，去檢查有沒有登入，才會進行動作，舉個例子，我們希望在新增留言、修改留言以及刪除留言都需要登入，且是由本人操作才算成功。 Migration 在此之前，我們先來修改一下上次的 migration {日期時間}_create_message_table.php 檔案吧 public function up() { Schema::create('message', function (Blueprint $table) { $table-\u003eincrements('id'); //留言板編號 $table-\u003einteger('user_id')-\u003eunsigned(); //留言者ID $table-\u003eforeign('user_id')-\u003ereferences('id')-\u003eon('users'); $table-\u003estring('content', 20); //留言板內容 $table-\u003einteger('version')-\u003edefault(0); $table-\u003etimestamps(); //留言板建立以及編輯的時間 $table-\u003esoftDeletes(); //軟刪除時間 }); } 可以看到我們將資料庫的名稱從 messsages 改為 message ，後續程式部分也都會修改，大家要在注意一下 ～ 我們這次加入了留言者 ID (使用外鍵連接 users 的 id)、按讚者 ID (使用外鍵連接 users 的 id)、留言板樂觀鎖、softDeletes軟刪除的欄位(軟刪除後續會提到)，並且因為我們同樣的資料不要重複儲存，所以刪除 name 要查詢就使用 join 來做查詢。 我們還希望可以多一個來存放是誰按讚的的資料表。所以一樣使用 migration 新增一個 {日期時間}_create_like_table.php 檔案 public function up() { Schema::create('like', function (Blueprint $table) { $table-\u003ebigIncrements('id'); //按讚紀錄編號 $table-\u003einteger('message_id')-\u003eunsigned()-\u003enullable(); //文章編號 $table-\u003eforeign('message_id')-\u003ereferences('id')-\u003eon('message'); $table-\u003einteger('user_id')-\u003eunsigned()-\u003enullable(); //帳號編號 $table-\u003eforeign('user_id')-\u003ereferences('id')-\u003eon('users'); $table-\u003edateTime('created_at'); //按讚紀錄建立時間 $table-\u003esoftDeletes(); //軟刪除時間 }); } 會存放文章的編號並且使用外鍵連接 message 的 id，以及按讚者的 ID 也使用外鍵連接 users 的 id。 列出本次會使用的功能以及對應的方法、是否需要登入、登入後其他人是否可以操作 功能 方法 是否需要登入 登入後其他人是否可以操作 查詢全部留言 getAllMessage 否 不需登入 查詢{id}留言 getMessage 否 不需登入 新增留言 createMessage 是 否 修改{id}留言 updateMessage 是 否 按讚{id}留言 likeMessage 是 可以 刪除{id}留言 deleteMessage 是 否 登入 API 我們上面介紹有使用到 Laravel 內建的登入 LoginController 來進行登入，但通常我們在使用時，都會另外再多一個登入用的 API ，那我們來看一下要怎麼設計吧！ 我們先使用 php artisan make:controller LoginController 新增一個登入的 API，他會產生在 app/Http/Controllers/ 目錄下 namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Validator; use Illuminate\\Support\\Facades\\Auth; class LoginController extends Controller { public function login(Request $request) { $rules = [ 'username' =\u003e 'required', 'password' =\u003e 'required' ]; $validator = Validator::make($request-\u003eall(), $rules); if ($validator-\u003efails()) { return response()-\u003ejson([\"message\" =\u003e \"格式錯誤\"], 400); } if (!Auth::attempt([ 'username' =\u003e $request-\u003eusername, 'password' =\u003e $request-\u003epassword ])) { return response()-\u003ejson([\"message\" =\u003e \"登入失敗\"], 401); } return response()-\u003ejson([\"message\" =\u003e \"登入成功\"], 200); } public function logout() { Auth::logout(); return response()-\u003ejson([\"message\" =\u003e \"登出成功\"], 200); } } 這邊的 Login 會先驗證格式是否正確，在使用 Auth:attempt 來檢查是否有註冊過，並且回傳相對應的訊息， Logout 就使用 Auth::logout 即可。 好了後我們先到 routes/api.php 新增登入跟登出 API 的路徑 Route::post('login', 'LoginController@login'); Route::post('logout', 'LoginController@logout'); 我們接下來設定 Middleware ，什麼是 Middleware 呢！？ Middleware Middleware 中文翻譯是中介軟體，是指從發出請求 (Request)之後，到接收回應(Response)這段來回的途徑上， 用來處理特定用途的程式，比較常用的 Middleware 有身份認證 (Identity) 、路由(Routing) 等，再舉個例子 某天早上你去圖書館看書， 下午去公園畫畫， 晚上去KTV 唱歌， 等到要準備回家的時候發現學生證不見了， 你會去哪裡找? (假設學生證就掉在這3個地方) 對於記憶不好的人來說，會按照 KTV \u003e 公園 \u003e 圖書館的路線去尋找。 假設在公園找到學生證，就不會再去圖書館了，由於這條路是死巷，所以只能返回走去KTV的路，這個就是 Middleware 的運作原理。 所以我們需要再請求時，先檢查是否有登入，才可以去執行需要權限的功能。 我們可以使用內建的 Auth::check 來檢查是否有登入，我們接著看要怎麼做吧！ 先下指令生成一個放置登入驗證權限的 Middleware ，我把它取名為 ApiAuth $ php artisan make:middleware ApiAuth Middleware creat","date":"2022-03-08","objectID":"/laravel-advanced/:1:2","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"Postman 測試 那我們一樣來看一下 Postman 的測試，這邊只顯示需要登入才能使用的 API。 登入 新增留言 成功\" 新增留言 成功 我們把帳號密碼放到 Body 來傳送，如果帳號密碼正確，就會顯示登入成功，並且在 Cookie 裡面的 laravel_session，可以用來判斷是否登入，以及登入的人是誰。 新增留言 - 成功 新增留言 成功\" 新增留言 成功 新增留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 會顯示新增紀錄成功以及回應 201 Created 新增留言 - 失敗 新增留言 失敗\" 新增留言 失敗 新增留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，所以會顯示用戶需要認證以及回應 401 Unauthorized 修改留言 - 成功 修改留言 成功\" 修改留言 成功 修改留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示修改成功以及回應 200 OK 修改留言 - 失敗 - 沒有登入 修改留言 失敗\" 修改留言 失敗 修改留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 修改留言 - 失敗 - 權限不足 修改留言 失敗\" 修改留言 失敗 修改留言失敗，雖然 有登入，但存在 Cookie 裡面的 laravel_session 不是當初的留言者 ，會顯示權限不正確以及回應 403 Forbidden 按讚留言 - 成功 修改留言 成功\" 修改留言 成功 按讚留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示按讚成功以及回應 200 OK 按讚留言 - 失敗 - 沒有登入 修改留言 失敗\" 修改留言 失敗 按讚留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 刪除留言 - 成功 刪除留言 成功\" 刪除留言 成功 刪除留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，不會顯示訊息但會回應 204 No Content 刪除留言 - 失敗 - 沒有登入 刪除留言 失敗\" 刪除留言 失敗 刪除留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 刪除留言 - 失敗 - 權限不足 刪除留言 失敗\" 刪除留言 失敗 刪除留言失敗，雖然 有輸入正確的 token ，但不是當初的留言者 ，會顯示權限不正確以及回應 403 Forbidden ","date":"2022-03-08","objectID":"/laravel-advanced/:1:3","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"參考資料 Laravel Auth 自定義user 模型目錄結構 user ( Model ) Laravel Form Request Validation laravel Validation 驗證格式 ","date":"2022-03-08","objectID":"/laravel-advanced/:2:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"什麼是 Redis ? Redis 全名是 Remote Dictionary Server ，是快速的開源記憶體鍵值資料庫 (keys-value database)。 由於 Redis 的回應時間極短，低於一毫秒，可以讓遊戲、金融服務、醫療保健等即時應用服務每秒處理幾百萬個請求。 ","date":"2022-03-08","objectID":"/redis/:1:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"Redis 的優勢 效能 所有的 Redis 資料都是存放在記憶體中，進而實現低延遲和高傳輸量的資料存取。 彈性的資料結構 一般的鍵值資料庫提供的資料結構有限，而 Redis 提供多樣化的資料結構來滿足服務的需求，包含字串(Strings)、哈希(Hashes)、列表(Lists)、集合(Sets)、有序集合(Zset)。(後續會有詳細介紹) 簡單易用 Redis 可以用更少、更精簡的指令來取代傳統複雜的程式碼，可以存取應用程式的資料。並支援 Java、Python、PHP、C/C++、C#、JavaScript、Node.js、Ruby、R、GO。 複寫和持久性 Redis 採主要-複本架構，支援非同步複寫，可以將資料複寫到多個複本伺服器。不但可以提升讀取效能(因為請求可分割到多部伺服器)，還可以再主服務器發生故障時快速恢復。至於持久性，Redis 支援時間點備份，會將資料複製到磁碟中。 ","date":"2022-03-08","objectID":"/redis/:1:1","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"實際操作 ","date":"2022-03-08","objectID":"/redis/:2:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"安裝 Redis 使用 Homebrew 來安裝 Redis (Mac OS：11.6) $ brew install redis 安裝好用 -v 檢查版本 $ redis-server -v Redis server v=6.2.6 sha=00000000:0 malloc=libc bits=64 build=c6f3693d1aced7d9 $ redis-cli -v redis-cli 6.2.6 一個是 Server、另一個是 Cli，所以在稍後測試時，需要開啟兩個 Terminal 來執行歐！ ","date":"2022-03-08","objectID":"/redis/:2:1","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"執行 Redis Server $ redis-server 39403:C 08 Mar 2022 11:13:17.500 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 39403:C 08 Mar 2022 11:13:17.500 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=39403, just started 39403:C 08 Mar 2022 11:13:17.500 39403:M 08 Mar 2022 11:13:17.501 * Increased maximum number of open files to 10032 (it was originally set to 256). 39403:M 08 Mar 2022 11:13:17.501 * monotonic clock: POSIX clock_gettime _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 6.2.6 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 39403 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | https://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 39403:M 08 Mar 2022 11:13:17.503 # Server initialized 39403:M 08 Mar 2022 11:13:17.503 * Ready to accept connections 如果出現上面符號，就代表 Server 已經啟動，接下來再開另一個 Terminal 來執行 Cli。 Cli 開啟後，在下一個 ping 指令，該指令用於檢測 redis 服務是否啟動，正常會顯示 pong。 $ redis-cli 127.0.0.1:6379\u003e ping PONG 接下來，我們都會在 Cli 視窗做測試，會詳細介紹每一個資料型態以及其適合情境。 redis 圖形化工具 後續會使用 Cli 畫面來做示範，但也有不錯的圖形化工具可以用於 redis 上 AnotherRedisDesktopManager 大家可以去試用看看~ ","date":"2022-03-08","objectID":"/redis/:2:2","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"資料型態 字串 (Strings) set、get 這是最基本的型態，可以存放 binary, string, integer, float資料，一個 Strings 的欄位，最高可儲存 512 Megabytes，這裡會用到的指令是 set、get ，分別用來儲存以及讀取字串，我們來看一下範例吧。 127.0.0.1:6379\u003e set string hello-world OK 127.0.0.1:6379\u003e get string \"hello-world\" 我們先用 set 將 hello-world 字串存到 string 這個 key，再用 get 顯示 string 裡面的 value。 incr、decr Redis 還有一些方便的指令，如果存入的 value 是 integer 型態，就可以使用 incr 、decr ，來累加與累減。分別代表累加，像是我們的 ++ ，以及累減，像是我們的 - -。 127.0.0.1:6379\u003e set num 10 OK 127.0.0.1:6379\u003e incr num (integer) 11 127.0.0.1:6379\u003e incr num (integer) 12 127.0.0.1:6379\u003e decr num (integer) 11 127.0.0.1:6379\u003e decr num (integer) 10 append 如果 key 已經存在並且它是字串，可以使用 append 指令，會從字串最後面附加進去，如果不存在，則會直接建立一個，並把值存進去。 127.0.0.1:6379\u003e exists str (integer) 0 127.0.0.1:6379\u003e append str \"Hello\" (integer) 5 127.0.0.1:6379\u003e append str \" World~\" (integer) 12 127.0.0.1:6379\u003e get str \"Hello World~\" getrange 可以輸入字串的開始位元與結束位元，會依照你輸入的去顯示字串。我把它理解成是陣列的 key 與 value 的關係。 127.0.0.1:6379\u003e set a \"This is a string\" OK 127.0.0.1:6379\u003e getrange a 0 3 \"This\" 127.0.0.1:6379\u003e getrange a -3 -1 \"ing\" 127.0.0.1:6379\u003e getrange a 0 -1 \"This is a string\" 127.0.0.1:6379\u003e getrange a 10 100 \"string\" mset 我們也可以設定的時候，把要設定的值都一起設定，只需要使用 mset 就可以達成。 127.0.0.1:6379\u003e mset 1 1 2 2 OK 127.0.0.1:6379\u003e get 1 \"1\" 127.0.0.1:6379\u003e get 2 \"2\" 127.0.0.1:6379\u003e get 3 (nil) 如果用 get 顯示資料，若沒有對應的 key ，會顯示 (nil)。 字串型態適合場景 字串(strings) 型態適合用於圖片快取 （使用binary）、累計次數、觀看累計次數 String 適用場景圖\" String 適用場景圖 哈希 (Hashes) 可以把他想像成二維陣列，應該會比較好理解，我網路上找了一張圖，應該會比較清楚！ Hashes 示意圖 (Redis 基本資料形態)\" Hashes 示意圖 (Redis 基本資料形態) Hashes 是用來存放一組相同性質的資料，這些資料 Hashes 或是物件的某一屬性，與 String 較為不同的是他可以取回單一個欄位資料，但 String 必須取回所有資料，單一個 Key 可以存放2^32 - 1的資料欄位， 他的資料型態有像是，一個 user001 裡面是一個 Hashes，Hashes 裡面又會存放 name、phone、gender ，我們來實際操作看看。 hset、hget 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hget student name \"ian\" 127.0.0.1:6379\u003e hget student phone \"0980123456\" 127.0.0.1:6379\u003e hget student gender \"M\" Hashes 的話要使用 hset、hget 來對 Hashes 做儲存以及讀取。 hgetall 想要一次顯示 Hashes 裡面的 key 跟 value ，可以使用 hgetall 來顯示全部資料。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"phone\" 4) \"0980123456\" 5) \"gender\" 6) \"M\" hkeys 想要單獨顯示 Hashes 裡面的 key ，可以使用 hkeys 來顯示。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hkeys student 1) \"name\" 2) \"phone\" 3) \"gender\" hvals 想要單獨顯示 Hashes 裡面的 value ，可以使用 hvals 來顯示。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hvals student 1) \"ian\" 2) \"0980123456\" 3) \"M\" hlen 想要顯示 Hashes 裡面的 key 長度，可以使用 hlen 來顯示。 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"gender\" 4) \"M\" 127.0.0.1:6379\u003e hlen student (integer) 2 hincrby 想要增加 Hashes 裡面的 value 整數，可以使用 hincrby 來新增。 127.0.0.1:6379\u003e hset test a 10 b 20 (integer) 2 127.0.0.1:6379\u003e hincrby test a 2 (integer) 12 hdel 想要刪除 Hashes 裡面的 key，可以使用 hdel 來刪除。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hdel student phone (integer) 1 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"gender\" 4) \"M\" 哈希型態適合場景 哈希(Hashes) 型態適合用於每次只需要取用一部分的資料 Hashes 適用場景圖\" Hashes 適用場景圖 列表 (Lists) lpush、lrange Lists 資料型態可以想像成程式語言中的Array物件。Lists 單一個Key可以存放2^32 - 1，這邊會使用到 lpush、lrange 來對 Lists 做儲存以及讀取。 127.0.0.1:6379\u003e lpush list2 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lrange list2 0 10 1) \"e\" 2) \"d\" 3) \"c\" 4) \"b\" 5) \"b\" 6) \"a\" 7) \"a\" rpush 除了從隊伍頭放入資料，也可以用 rpush 從隊伍尾放入資料，如果使用 lrange 來顯示方向也會相反歐。 127.0.0.1:6379\u003e rpush list3 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lrange list3 0 10 1) \"a\" 2) \"a\" 3) \"b\" 4) \"b\" 5) \"c\" 6) \"d\" 7) \"e\" lpop、rpop 也可以使用 lpop、rpop 分別從隊伍頭或尾彈出一筆資料。 127.0.0.1:6379\u003e rpush list3 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lpop list3 \"a\" 127.0.0.1:6379\u003e rpop list3 \"e\" lset 可以使用 lset 來設定指定位置的資料。 127.0.0.1:6379\u003e lrange list3 0 2 1) \"a\" 2) \"b\" 3) \"c\" 127.0.0.1:6379\u003e lset list3 1 w OK 127.0.0.1:6379\u003e lrange list3 0 2 1) \"a\" 2) \"w\" 3) \"c\" 列表型態適合場景 列表(Lists) 型態適合用於文章列表或者資料分頁展示的應用 Lists 適用場景圖\" Lists 適","date":"2022-03-08","objectID":"/redis/:2:3","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"發布訂閱 (PUB/SUB) Redis 發布訂閱 (pub/sub) 是一種消息通信模式，發送者 (pub) 發送消息，訂閱者 (sub) 接收消息。 Redis 客戶端可以使用 subscribe 來訂閱任意數量的頻道。 下面這張圖是頻道1，以及訂閱這個頻道的三個用戶端分別是客戶端2、客戶端7、客戶端5 Subscribe 示意圖\" Subscribe 示意圖 當我們有新消息通過 publish 指令發送給頻道1 ，這個消息就會被發送給有訂閱頻道1的三個客戶端。 Publish 示意圖\" Publish 示意圖 我們來模擬一下吧 ! 先開兩個 Terminal 來執行 redis-cli 一個當作發送(pub)，另一個當作接收(sub)。 我們先用第一個 Terminal 訂閱一個頻道 channel_1 127.0.0.1:6379\u003e subscribe channel_1 Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"channel_1\" 3) (integer) 1 開啟另一個 Terminal 發送訊息到 channel_1 127.0.0.1:6379\u003e publish channel_1 \"Hello World~\" (integer) 1 127.0.0.1:6379\u003e publish channel_1 \"ian~\" (integer) 1 127.0.0.1:6379\u003e publish channel_1 \"test~\" (integer) 1 這時候再切換回來第一個 Terminal ，就可以看到他接收到我們傳送的訊息 127.0.0.1:6379\u003e subscribe channel_1 Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"channel_1\" 3) (integer) 1 1) \"message\" 2) \"channel_1\" 3) \"Hello World~\" 1) \"message\" 2) \"channel_1\" 3) \"ian~\" 1) \"message\" 2) \"channel_1\" 3) \"test~\" ","date":"2022-03-08","objectID":"/redis/:2:4","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"參考資料 Redis 官網 Redis Redis 基本資料形態 Redis 發布訂閱 ","date":"2022-03-08","objectID":"/redis/:3:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"每當我們在建立資料表時，都必須先決定我們要用的資料型態，然而在輸入文字存入資料時，你都用哪一種資料型態呢？ ","date":"2022-03-04","objectID":"/char-varchar/:0:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"文字資料型態 主要有這三點，那我會分別來介紹，最後附上一個表格來整理一下今天所講的。 char varchar text ","date":"2022-03-04","objectID":"/char-varchar/:1:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"char char 的長度是不可變動的，每一條資料佔用等長的字節空間，適合用在身分證號碼、手機號碼等。 ","date":"2022-03-04","objectID":"/char-varchar/:1:1","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"varchar varchar 的長度是可以變動的，可以設定最大長度，就適合用於在長度可變的屬性。 ","date":"2022-03-04","objectID":"/char-varchar/:1:2","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"text text 的長度不需要設定，當我們不知道屬性的長度時，就適合用 text。 ","date":"2022-03-04","objectID":"/char-varchar/:1:3","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"可變跟不可變的差異 疑~ 什麼是可變，什麼是不可變長度呀 ? 簡單來說，我們現在定義一個 char[10] 以及 varchar[10]，現在我們存入的資料是 “pinyi” 5字元的字串， 由於 char 是不可變長度，所佔的長度依舊是 10 ，那如果是 varchar 可變長度，除了字元所佔的5格，後面的 5 個空格會自動消失，varchar 會自動把長度變成 5 。 取資料時，char 型別要用 trim() 來去除多餘的空白，而 varchar 不需要。 ","date":"2022-03-04","objectID":"/char-varchar/:1:4","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"查詢速度比較 如果我們來依照查詢速度來比較，想也不用想，一定是 char 第一名，因為他有固定的數量，比起 varchar 第二名可變長度還可以更快進行查詢，當然沒有長度限制的 text 一定是最慢。 ","date":"2022-03-04","objectID":"/char-varchar/:1:5","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"儲存方式 char 的儲存方式是，對於英文字元 (ASCII) 佔用 1 位元組，對於中文佔用 2 位元組 ; varchar 的儲存方式是，對每個英文字元 (ASCII) 佔用 2 位元組，中文也佔用 2 位元組 ; ","date":"2022-03-04","objectID":"/char-varchar/:1:6","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"比較差異表格 字串資料型態 char varchar text 長度狀態 不可變 可變 不需要設定 查詢速度 第一 第二 第三 英文所佔用位元組 1 Byte 2 Byte Ｘ 中文所佔用位元組 2 Byte 2 Byte Ｘ 最大長度 1 \u003c= M \u003c= 255 L \u003c= M or 1 \u003c= M \u003c= 255 L \u003c2^16 ","date":"2022-03-04","objectID":"/char-varchar/:1:7","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"參考資料 面試官：你們資料庫選擇varchar和char的原則到底什麼？ SQL Server 資料型態 char varchar nchar nvarchar MySQL性能優化之char、varchar、text的區別 ","date":"2022-03-04","objectID":"/char-varchar/:2:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"本文章會介紹什麼是 Laravel ，以及它有什麼特別之處，可以讓它在2015年被評為最受歡迎的 PHP 框架第一名，並說明為什麼要使用框架，最後實作一個留言板功能搭配 RESTful API 來實現 CRUD。 就像是 Laravel 官網的大標題，『 The PHP Framework for Web Artisans 為網頁藝術家創造的 PHP 框架 』，那再了解 Laravel 之前，先來介紹一下框架是什麼： ","date":"2022-03-02","objectID":"/laravel/:0:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"框架是什麼 框架 (Framework) 是一個被設計用來完成特定任務的規範，程式開發人員必須遵從這個規則來開發。 目前大多數的框架都是參考 MVC 架構的概念來做設計，原因是在早期開發網頁時，都是直接將 HTML 以及 PHP 混合再一起的方式來編寫，雖然開發上很方便，但在後面維護或是新增功能上，會十分不便利，例如：單純要修改網站畫面的元件時，還需要從混雜的程式碼中找到要修改的元件，也很容易不小心修改到其他的功能。 ","date":"2022-03-02","objectID":"/laravel/:1:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"MVC 於是有人想到把這些各自的任務區分開來，MVC 架構分別代表的是 M (Model) : 屬於資料的部分，可能是商用邏輯或是資料庫的存取。 V (View)：屬於顯示的部分，像是 HTML、CSS 等 C (Controllor)：會針對請求做出回應或是處理，例如從 Model 取出資料，並顯示在 View 上面 MVC 架構 一起走向MVC(上)\" MVC 架構 一起走向MVC(上) ","date":"2022-03-02","objectID":"/laravel/:1:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 框架 Laravel 是基於上面所說的 MVC 架構打造的框架，並且設計出許多可以讓開發者更有效率的工具。 Artisan：提供許多指令，讓你可以使用這些指令，來快速完成許多的任務 (有列出部分指令於 Artisan 相關指令)。 Routing 路由：管理網址與頁面的路徑指定，辨識傳入的 request 傳送至對應的 Controller，回傳指定的 View。 Blade 模板引擎 (View)：模板解析工具， 是 Laravel 所使用的模板引擎，Blade 會將 PHP 及 HTML 完整分離的工具。 Auth 認證：透過 Laravel 預設提供的認證讓 Controller 快速解決經常會用到的驗證需求，像是：使用者註冊、使用者認證、重置密碼的 e-mail 連結、重置密碼邏輯等。 Eloquent ORM 物件關聯對映 (Model)：Laravel 預設的 ORM，將資料庫的欄位映射成物件 (Ｍodel 模型)，只需要用 PHP 的語法，不需要撰寫 SQL 指令就可以用物件的方式讀取欄位資訊以及與資料庫的互動。 Migration 資料庫遷移：聽起來很像是更換資料庫，但他其實算是一種資料庫的版本控制，可以讓團隊在修改資料庫結構的同時，保持彼此的進度ㄧ致，通常會結合Schema 結構生成器一起使用，可以簡單管理資料庫結構。 小知識 ORM：英文叫 Object Relational Mapping，翻譯成中文為物件關聯對映。在網站開發結構中，是在資料庫和Model 資料容器兩者之間，簡單來說，它是可以讓開發者更簡單、安全的方式從資料庫讀取資料，因為 ORM 的特性是可以透過物件導向程式語言去操作資料庫。 優點 安全性：可以避免 SQL injection，遇到奇怪的值，會自動擋掉。 簡化性：可以將原本 SQL Select * From users 等指令透過物件導向程式語言去操作資料庫。 通用性：因為 ORM 是程式語言和資料庫之間的關係，就算有要轉換資料庫，也比較不會遇到要修改程式的狀況。 缺點 效能：為了要達成方便性，通常都會犧牲到效能的問題，因為等於多了『把程式語言轉譯成SQL語言』這項工作。 學習曲線高：對於初學者來說，ORM 需要融合 SQL 語言以及程式語言兩種不同的概念以及語法，會比單純學 SQL 語法還較複雜。 複雜查詢維護性低：有些 SQL 語法 ORM 沒有支援，所以導致有些情況還是需要導入原生 SQL 寫法。 (資料來源：資料庫設計概念 - ORM) ","date":"2022-03-02","objectID":"/laravel/:2:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"PHP 常見框架對比 雖然本次介紹的主題是 Laravel 但我們也簡單介紹一下其他的框架優點，以及附上表格讓大家可以更清楚。 差別 Laravel Symfony CodeIgniter CakePHP Zend 2 許可 License MIT MIT BSD BSD MIT 人氣排名 Popularity (2022-03 Google 搜尋熱門程度) 第一名 第二名 第三名 第四名 第五名 表現 慢 慢 快 慢 慢 模板 Blade Twig PHP 內建 PHP 資料庫 MySQL PostgreSQL SQLite SQL Server MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle 物件關係對映 有 Doctrine 沒有內建 有 Doctrine 測試 PHPUnit PHPUnit 內建 PHPUnit PHPUnit ","date":"2022-03-02","objectID":"/laravel/:3:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 該框架可能是Web 開發人員中最受歡迎的框架。Laravel 是一個免費的開源PHP 框架，適用於Web 應用程序開發，且適用於移動應用程序場。(上面有介紹過，這邊就簡化) Laravel 框架優點 易於學習 無縫數據遷移 在 PHP 社群中很受歡迎 支持 MVC 架構 大量學習素材 (文件、圖檔、影片教程) 模板引擎 簡單的單元測試 ","date":"2022-03-02","objectID":"/laravel/:3:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Symfony 該框架是一個廣泛的PHP MVC 框架，目前Symfony 已經成為一個可靠和成熟的平台框架。 Symfony 非常穩定、文檔齊全、性能卓越。這些特點使Symfony 成為開發大型企業項目的完美選擇。 使 Symfony 成為 PHP 框架中獨一無二的特性之一是它的可重用 PHP 組件。使用可重用組件，開發時間減少了許多模塊，如表單創建、對象配置、模板等。 可以直接從舊組件構建，節約了大量成本。Symfony 易於在大多數平台上安裝和配置，並且可以獨立於數據庫引擎。它具有高度的靈活性，可以與 Drupal 等大型項目集成 Symfony 框架優點 官方長期技術支持 內置測試功能 豐富的框架內置功能 官方培訓課程和認證 ","date":"2022-03-02","objectID":"/laravel/:3:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"CodeIgniter 該框架可能是最適合開發動態網站的PHP 框架。它是一個非常簡單的輕量級PHP 框架。 它的大小只有2 MB 左右（包括文檔）。因此，CodeIgniter 本身俱有最小的佔用空間，它允許Web 開發人員添加第三方插件來開發更複雜的功能。 CodeIgniter 還提供了幾個預構建的模塊，用於為Web 開發創建健壯的、可重用的組件。由於設置過程簡單，這個PHP 框架非常適合初學者。 CodeIgniter 框架優點 MVC 架構 Top-Notch 錯誤處理 提供卓越的性能 包中提供了幾種工具 內置安全工具 優秀的文檔 ","date":"2022-03-02","objectID":"/laravel/:3:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"CakePHP 該框架對個人是完全免費，並提供付費的商業用途。它將幫助您開發功能豐富且視覺上令人印象深刻的網站。 CakePHP 起初是一個簡單而優雅的工具包，在過去的15 年裡它變得更加強大。由於它的CRUD（創建、讀取、更新和刪除）框架，CakePHP 是最容易學習的框架。 使用CakePHP 部署Web 網站是\"小菜一碟\"，只需要一個Web 服務器和CakePHP 框架的副本。 CakePHP 框架優點 插件和組件的簡易擴展 適當的類繼承 零配置 現代框架 支持AJAX 快速構建 內置驗證 ","date":"2022-03-02","objectID":"/laravel/:3:4","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Zend 2 該框架是一個完整的面向對象的PHP 框架。這個PHP 框架是可定制的，對於需要添加項目特定功能的開發人員來說，這是一個好處。 Zend 構建於敏捷方法之上，可幫助開發人員為大型客戶創建、高質量的Web 應用程序的框架。它非常適合複雜的企業級項目，Zend 主要關注安全性、性能和可擴展性。 Zend 框架主要受大型IT 企業和銀行等金融機構的青睞。 Zend 2 框架優點 MVC 組件 卓越的前端技術支持工具 大型開發者社區 簡單的雲API 支持第三方組件 數據加密 支持AJAX 會話管理 ","date":"2022-03-02","objectID":"/laravel/:3:5","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"實作 Laravel 官網 我是參考 Laravel 官方網站 的文件來進行實作，也可以參考台灣的 Laravel.tw 來操作歐！ ","date":"2022-03-02","objectID":"/laravel/:4:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"環境設定 要安裝 Laravel 框架有一些系統的要求，要先安裝 PHP ，請參考PHP 官網的安裝教學 安裝完後可以使用來檢查是否安裝成功 $ php --version PHP 7.1.33 (cli) (built: Jan 20 2022 04:04:37) ( NTS ) Copyright (c) 1997-2018 The PHP Group 再安裝 Composer ，請參考 Composer 官網的安裝教學 $ composer --version Composer version 2.2.7 都安裝好後，我們就要來安裝 Laravel 框架囉，根據 Laravel 官網安裝步驟，先用 Composer 來安裝 $ composer global require \"laravel/installer\" 安裝後一樣先來檢查是否安裝成功 $ laravel --version zsh: command not found: laravel 發現 zsh 找不到 laravel 這個命令，那我們看一下官網怎麼說 ( zsh 是我所使用的 bash ，這邊會依照安裝環境而有所不同) Make sure to place the $HOME/.composer/vendor/bin directory (or the equivalent directory for your OS) in your $PATH so the laravel executable can be located by your system. 代表我們要將 Laravel 的目錄，放到 $PATH ，系統才可以使用 laravel 來執行檔案。 以 macOS 來說， Laravel installer 的目錄都會放在 $HOME/.composer/vendor/bin ，我們在根目錄建立一個 .bash_profile 的檔案來放置我們的 $PATH。 export PATH=\"$HOME/.composer/vendor/bin:$PATH\" 輸入上面的 PATH ，記得儲存離開後要用這個指令來更新一下檔案 $ source .bash_profile 我們再次檢查是否安裝好 Laravel $ laravel --version Laravel Installer 2.3.0 因為我們後續會使用到資料庫的功能，所以也可以先把他安裝好 ＭySQL 官網的安裝教學 $ mysql -V mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) 本次實作の版本配置 macOS 11.6 PHP 7.1.33 MySQL 8.0.28 Composer 2.2.7 Laravel Installer 2.3.0 Laravel Framework 5.4.36 ","date":"2022-03-02","objectID":"/laravel/:4:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"新增專案 安裝成功後，就可以開始來使用 Laravel 框架自動生成檔案囉！要怎麼做呢？就接著看下去吧 可以使用 Laravel 來新增專案 $ laravel new 專案名稱 也可以透過 composer 指令 (可以指定框架版本，那我們這次使用的是5.4版本) $ composer create-project --prefer-dist laravel/laravel 專案名稱 \"5.4.*\" 完成後就進入該專案目錄底下，接著可以執行該指令來檢查框架版本 $ php artisan -V Laravel Framework 5.4.36 小提醒 Laravel 框架可使用的的版本，取決於你的 PHP 版本，所以要找相對應的歐！使用 Laravel 5.4 跟 PHP 8.1 ，他會說 PHP 版本太新，無法安裝。 ","date":"2022-03-02","objectID":"/laravel/:4:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 資料夾與檔案介紹 我們可以看到這個專案目錄下，Laravel 幫我們生成了許多資料夾以及檔案，接著來簡單說明每一個資料夾與檔案的功能與用途吧 app：主要放置 controller 的地方，提供網站的應用處理流程，包括處理用戶的行為和資料 Model 上的改變等事件之類別方法，提供給 view 來呼叫。透過 Laravel 之架構也可透過 controller 輕易建構 RESTful API。 bootstrap：內含之 app.php 為將此框架初始化及建構起來之程式。 config：內含此專案網站之環境設定、資料庫設定等設定程式。 database：放置資料庫設定 (Model)。 public：放置網站入口，透過 index.php 導入 route 之設定首頁 resources：放置 view 的資源，用以呈現網站頁面 routes：放置所有專案 route 的設定，其中較常用之 web.php 做為主要頁面導向及與 controller 的溝通，而 api.php 則作為專案提供 api 的設定。 storage：主要放置些程式生成的檔案如頁面樣板 (Blade templates)、系統記錄 (logs)、file caches、file based sessions 等資料。 tests：放置測試用的案例 (Test Case)。 vendor：放置透過 composer 下載管理的套件。 artisan：可於專案中透過 php artisan 執行 Laravel 設計好的基本操作行為，如建立 controller 等動作。 composer.json：管理專案使用套件，詳細用法見 composer 官方說明。 composer.lock：鎖定專案使用套件版號。 package.json：管理 npm 套件，主要提供給前端使用。 phpunit.xml：phpunit 測試設定檔，可規範執行單元測試之範圍，做批量測試。 webpack.mix.js：build 設定檔，幫助我們將 resources 中之 js 及 sass 等前端設定檔 compile 成 js、css 等檔案並 deploy 到 public 中供頁面使用。 ","date":"2022-03-02","objectID":"/laravel/:4:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"建立第一個 Laravel 網頁 文章參考來源 下面教學流程是參考ReccaChao Laravel 6.0 初體驗！怎麼用最新的 laravel 架網站！ 的文章下去學習以及介紹，在學習過程中再加上自己的理解以及不同範例的筆記來分享給大家，大家也可以先去瀏覽大大的文章，再回來呦XD 我們經過千辛萬苦，將 Laravel 給安裝好，也設定好它所需的環境參數，打開 IED 準備開始學習如何建立第一個 Laravel 網頁吧！ 在開始說明前，還要先下一個指令。在介紹 Laravel 專案下的資料夾以及檔案中，其中一個 “Artisan”，是 Laravel 專用的指令工具，可以幫我們處理很多事情。 像是我們現在要啟動內建的伺服器來瀏覽我們的網站，這時我們要下 $ poser global requirephp artisan serve Laravel development server started: \u003chttp://127.0.0.1:8000\u003e [Thu Mar 3 15:13:07 2022] 127.0.0.1:52345 [200]: /favicon.ico 這個伺服器會在這個終端機下被建立，屬於這個專案的伺服器，如果想要關閉，可以使用 Ctrl + C 來關閉。 小提醒 由於此伺服器是專屬於該專案的伺服器，所以下指令時，也要在該專案的目錄下歐！ 如果想要使用特定的 Port ，可以在後面加入此參數，就可以依照設定的 Port 來當作我們伺服器的位子囉！(預設是8000 Port) $ php artisan serve --port=7777 Laravel development server started: \u003chttp://127.0.0.1:7777\u003e [Thu Mar 3 15:45:23 2022] 127.0.0.1:54206 [200]: /favicon.ico 維護模式 當我們想要修改系統或是資料庫的欄位時，就可以將該網站設定成維修模式。Laravel 讓這個工作變得很容易，只需要用以下兩個指令來控制 啟動維護模式 $ php artisan down --message=\"Upgrading Database\" --retry=60 還可以設定一些參數， --message 是用來顯示或紀錄客製化訊息， --retry 用來當作HTTP head 的 Retry-After 的值 Laravel 維護模式顯示頁面\" Laravel 維護模式顯示頁面 關閉維護模式 $ php artisan up 維護模式顯示模板 維護模式顯示的預設模板放置在 resources/views/errors/503.blade.php。你可以自由的根據需求修改。 Routes 路由 我們要來建立我的第一個網頁，網頁的其中一個關鍵就是路徑。那我們網站的路徑，在 Laravel 裡面，都放置在 routes/ 裡面，打開後可以看到4個檔案有 web.php：這個和我們現在要說明的路徑有關，我們在瀏覽器打的網址，前面是 domain name，那在 domain 之後的字串，會在我們這個檔案裡面來定義哪些字串要導向哪一個流程或是檔案，範例 url:{domain}/hello-world。 api.php：我們在做前後端分離的專案時會使用這個檔案，與 web.php 功能差不多，預設用來管理 API 的路徑。 channels.php：和 Broadcast 有關係，這個是 Laravel 的廣播功能，不太常使用，所以先跳過，之後有碰到再來說明。 console.php：這個和我們指令有關，像是我們上面介紹的 php artisan ，這個檔案就是和這個部分有關。 web.php 那我們就先來針對 web.php 來做介紹，我們剛剛使用指令開啟的伺服器網址是 http://127.0.0.1:8000，使用瀏覽器進入後，可以看到下面這個 Laravel 預設的頁面(此為 Laravel 5.4版本，新版的好像不太一樣) Laravel 預設首頁\" Laravel 預設首頁 那我們開啟 routes/web.php 檔案中，可以看到下面這一段預設的路由 Route::get('/', function () { return view('welcome'); }); 這段的意思就是代表，如果我們網址沒有輸入其他的目錄，就會顯示 welcome 這個網頁，那 welcome 這個顯示的畫面，就放在 resources/view 底下名為 welcome.blade.php 的檔案中，打開來看就是簡單的 HTML。 那現在我們了解路由的含義，現在換我們來實作一個看看，首先我們希望網址列輸入 https://127.0.0.1:8000/hello-world 可以出現 hello world 的字樣，那我們可以到 web.php 中，新增下面這個路由 Route::get('/hello-world', function () { return view('hello-world'); }); 再到到 resources/view 新增 hello-world.blade.php 檔案，簡單輸入 HTML 格式，如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e hello ~ pinyi \u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 使用瀏覽器在網址列輸入 http://127.0.0.1/hello-world ，就可以看到顯示 hello ~ pinyi 的字樣囉～ 除了回傳網頁來做顯示以外，也可以單獨回傳字串，並帶入參數歐，我們來試試看要怎麼做。 首先我們先將路由修改成下方，讓我們在 hello-world 後面可以輸入我們的名稱，並且顯示在畫面上 Route::get('/hello-world/{name}', function ($name) { return 'hello ~ ' . $name; }); 我們在網址列輸入 http://127.0.0.1/hello-world/pinyi 就會顯示 hello ~ pinyi ，很神奇吧，只要在括號中 {} 輸入你要的參數，並且後面的 function 也要帶入參數，就可以將資料給帶進去了 ! api.php 我們可以看到 api.php 檔案也是使用 Route 來運作，如下 Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); middleware 就是一種過濾或是防火牆的概念，這個我們後續會再說明。 我們也在此新增一個跟上面一樣的 hello-world，如下 Route::get('/hello-world', function () { return 'Hello World ~'; }); 在 api.php 比較特別的部分是需要在字串前面加入 api ，因為 api.php 就是預設讓我們來放 api 的地方，如範例 url:{domain}/api/hello-world，那就會回傳 hello world ~ View Blade 模板引擎 我們已經知道要怎麼透過路由，讓使用者輸入網址後，根據網址指向想要呈現的畫面，那我們的畫面要怎麼呈現呢 !? 上面有使用簡單的 HTML 來做說明，那本章節就來介紹怎麼修改我們的前端輸出吧。 Layout 我們在設計網頁時，通常都會使用樣板，讓網頁相同的地方只做一次就可以顯示，不需要每一個頁面都重複寫相同的程式碼，只需要在想要顯示的地方來顯示各自的內容就好 如果聽不太懂，我以我的 Blog 來舉例，紅色框框，在每一頁都會顯示，我們可以把他寫成一個檔案，就不需要每頁都重複去寫，藍色框框，會依照每一頁的內容來做顯示。 PinYi 小天地\" PinYi 小天地 那我們可以透過 Laravel 的 Blade Engine 輕鬆地達到這件事情，首先，到 resources/views/ 目錄下建立一個叫 layouts 的資料夾。這個資料夾之後會讓我們來放不同的模板 在 layouts 下建立一個 header.blade.php 檔案，內容如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e測試網站，我是標題\u003c/h1\u003e \u003cdiv class=\"container\"\u003e @yield('content') \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 可以看到我們","date":"2022-03-02","objectID":"/laravel/:4:4","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"RESTful API 實現 CRUD 接下來，就來到我們本次的重點，要使用 Laravel 來開發出留言板功能，搭配使用 RESTful API 來實現 CRUD 老樣子，我們先來設定我們的 route 路由，這次實作的是留言板，所以我們希望網址是 http://127.0.0.1:8000/api/messages，因為這次是 API，先到 routes/api.php 底下來設定 \u003c?php use Illuminate\\Http\\Request; /* |-------------------------------------------------------------------------- | API Routes |-------------------------------------------------------------------------- | | Here is where you can register API routes for your application. These | routes are loaded by the RouteServiceProvider within a group which | is assigned the \"api\" middleware group. Enjoy building your API! | */ Route::get('messages', 'MessageController@getAllMessages'); // 查詢全部留言 Route::get('messages/{id}', 'MessageController@getMessages'); // 查詢 {id} 留言 Route::post('messages', 'MessageController@createMessages'); // 新增留言 Route::put('messages/{id}', 'MessageController@updateMessages'); // 修改 {id} 留言 Route::delete('messages/{id}', 'MessageController@deleteMessages'); //刪除 {id} 留言 已經忘記的，可以先回到 Controller 控制器 複習一下上面的路由是什麼意思。 接下來，我們使用 建立屬於自己的 migration 來生成我們本次要使用的資料表，再來新增一個與 Eloquent Model 相同的物件，選擇我們要的資料表 \u003c?php namespace App; use Illuminate\\Database\\Eloquent\\Model; class Message extends Model { protected $table = 'Messages'; protected $fillable = [ 'name','content','created_at','updated_at' ]; } 都好了我們來撰寫我們的 controller，我會依照每一個功能(CRUD)來做說明，要記得加入剛剛的 model use App\\Message;。 查詢全部留言 class MessageController extends Controller { // 查詢全部留言 public function getAllMessages() { $messages = Message::get(['id','name','content','created_at','updated_at'])-\u003etoJson(JSON_PRETTY_PRINT); return response($messages, 200); } } 會依照 model 選擇的資料表來做查詢，只顯示 id、name、content 、created_at 、updated_at 五個欄位，並把他用 JSON 表示，最後用 response() 來回應 status code。 查詢{id}留言 class MessageController extends Controller { // 查詢{id}留言 public function getMessages($id) { if (Message::where('id',$id)-\u003eexists()) { $messages = Message::where('id',$id)-\u003eget(['id','name','content','created_at','updated_at'])-\u003etoJson(JSON_PRETTY_PRINT); return response($messages, 200); } else { return response()-\u003ejson([\"messages\" =\u003e \"找不到訊息\"], 404); } } } 先判斷輸入的 id 是否存在，如果存在才顯示 id、name、content 、created_at 、updated_at 五個欄位，並把他用 JSON 表示，最後用 response() 來回應 status code，如果不存在，直接用 JSON 表示 response() 404錯誤訊息。 新增留言 class MessageController extends Controller { // 查詢{id}留言 public function createMessages(Request $request) { if (strlen($request-\u003econtent)\u003c20){ $messages = new Message; $messages-\u003ename = $request-\u003ename; $messages-\u003econtent = $request-\u003econtent; $messages-\u003eupdated_at = NULL; $messages-\u003esave(); return response()-\u003ejson([\"messages\" =\u003e \"新增紀錄成功\"], 201); } if (strlen($request-\u003econtent)\u003e20){ return response()-\u003ejson([\"messages\" =\u003e \"內容長度超過20個字元\"], 400); } } } 我們希望輸入的內容不要超過20的字，所以我們先用 strlen() 來判斷輸入長度，如果小於20，就將 request 輸入的名字及內容輸入，用 save() 來儲存，並把他用 JSON 表示，最後用 response() 來回應 status code，如果小於20，直接用 JSON 表示 response() 400錯誤訊息。 修改留言 class MessageController extends Controller { // 修改{id}留言 public function updateMessages(Request $request,$id) { if (Message::where('id',$id)-\u003eexists() \u0026\u0026 Message::where('version',0)-\u003elockForUpdate() ) { if (strlen($request-\u003econtent)\u003c20){ $messages = Message::find($id); $messages-\u003ename = is_null($request-\u003ename) ? $messages-\u003ename : $request-\u003ename; $messages-\u003econtent = is_null($request-\u003econtent) ? $messages-\u003econtent : $request-\u003econtent; $messages-\u003eversion = '1'; $messages-\u003esave(); return response()-\u003ejson([\"message\" =\u003e \"修改成功\"],200); } if (strlen($request-\u003econtent)\u003e20){ return response()-\u003ejson([\"messages\" =\u003e \"內容長度超過20個字元\"], 400); } } else { return response()-\u003ejson([\"message\" =\u003e \"找不到訊息\"],404); } } 先判斷輸入的 id 是否存在以及是否有被上鎖，在判斷輸入的長度，如果小於20，再判斷是否有輸入，有就將 request 輸入的值輸入，用 save() 來儲存，並把他用 JSON 表示，最後用 response() 來回應 status code，如果小於20，直接用 JSON 表示 response() 400錯誤訊息。 刪除留言 class MessageController extends Controller { // 刪除{id}留言 public function deleteMessages($id) { if (Message::where('id',$id)-\u003eexists()) { $messages = Message::find($id); $messages-\u003edelete(); return response()-\u003ejson([\"message\" =\u003e \"刪除成功,沒有返回任何內容\"],204); ","date":"2022-03-02","objectID":"/laravel/:4:5","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"測試 寫完程式後，除了自己一個一個去測試，也可以寫成程式來測試是否有錯誤。會在此談到測試，是因為自動測試變得簡單也是 Laravel 這個框架的一個重要特性。 那我先來說明一下什麼是自動測試 簡單來說，常見的測試，就是我們在完成新功能後，會一個一個實際去測試我們寫的功能，是不是跟我們預想的那樣子運行。 一開始網站還小，功能不多時，還可以應付。但當網站越來越龐大，功能越來越多後，或是要使用不同權限帳號來檢查所有功能，會很辛苦的。 幸好，我們可以用自動測試的程式來解決這些瑣事！ 如果我們每次為每個功能撰寫程式時，都寫另一段小程式來測試這個功能。 隨著時間過去，需求的改變，雖然功能越來越多，但是相對應的，測試這些功能的程式也會越來越多，並且不管這個功能是多久之前開發的，每個功能都有相對應的測試。 ","date":"2022-03-02","objectID":"/laravel/:5:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"如何運行自動測試 在 PHP 的世界，自動測試通常使用 PHPUnit 這個工具。然後 Laravel 在安裝時，也自動幫我們安裝這個工具了～ Laravel 幫我們把 PHPUnit 安裝在 vendor/ 裡面，我們來看看要怎麼使用它吧！使用的指令如下 $ vendor/phpunit/phpunit/phpunit PHPUnit 5.7.27 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 146 ms, Memory: 10.00MB OK (2 tests, 2 assertions) 奇怪，我們什麼都還沒做，為什麼會有兩個程式已經通過測試了，是因為 Laravel 預設兩個檔案來當測試的案例，分別位於 tests/Feature/ExampleTest.php 以及 tests/Unit/ExampleTest.php (單元測試)，我這邊就簡單說明 Feature/ExampleTest.php 這個測試程式做哪些事情 \u003c?php namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; use Illuminate\\Foundation\\Testing\\DatabaseMigrations; use Illuminate\\Foundation\\Testing\\DatabaseTransactions; class ExampleTest extends TestCase { /** * A basic test example. * * @return void */ public function testBasicTest() { $response = $this-\u003eget('/'); $response-\u003eassertStatus(200); } } 這個 Feature/ExampleTest.php 的 testBasicTest() 會檢查如果連線到 / ，HTTP Status 有沒有回傳 200 (成功連線)，這個測試功能就是在檢查首頁是否存在 ～ ","date":"2022-03-02","objectID":"/laravel/:5:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"實作測試程式 大概了解原理後，一樣我們來實作看看，那我們先來輸入指令，產生一個測試程式 $ php artisan make:test HelloWorldTest Test created successfully. Laravel 會自動幫我們在 tests/Feature 底下新增了 HelloWorldTest.php 檔案，內容如下(框架版本5.4) \u003c?php namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; use Illuminate\\Foundation\\Testing\\DatabaseMigrations; use Illuminate\\Foundation\\Testing\\DatabaseTransactions; class HelloWorldTest extends TestCase { /** * A basic test example. * * @return void */ public function testExample() { $this-\u003eassertTrue(true); } } 我們測試的項目是想要連線到 hello-world/ 目錄，HTTP Status 會回傳 200 ，以及網站內要看到『 hello world ~ 』的文字，我們將他預設的 testExample() 的內容改成 public function testExample() { $response = $this-\u003eget('/hello-world'); // 如果連線 hello-world/，HTTP Status 應該要顯示 200 $response-\u003eassertStatus(200); //連線到網頁內，應該要可以看到「『 hello world ~』文字 $response-\u003eassertSee('hello world ~'); } 來運作一下吧，一樣使用同樣的指令來做測試，順便讓大家看一下測試錯誤的錯誤訊息吧！ $ vendor/phpunit/phpunit/phpunit PHPUnit 5.7.27 by Sebastian Bergmann and contributors. .F. 3 / 3 (100%) Time: 200 ms, Memory: 10.00MB There was 1 failure: 1) Tests\\Feature\\HelloWorldTest::testExample Expected status code 200 but received 404. Failed asserting that false is true. FAILURES! Tests: 3, Assertions: 3, Failures: 1. 我故意在 routes 下沒有放 hello-world/ 路徑，所以返回顯示 404 ，而不是 200 ，因此，就可以知道要怎麼去修改程式囉 ! ","date":"2022-03-02","objectID":"/laravel/:5:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Artisan 相關指令 ","date":"2022-03-02","objectID":"/laravel/:6:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Controller php artisan make:controller {檔案名稱}Controller //建立一個 Controller ","date":"2022-03-02","objectID":"/laravel/:6:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Migration php artisan make:seeder //產生seeder檔案 php artisan make:factory //產生factory 檔案 php artisan make:migration //產生migration 檔案 php artisan migrate //將這次的migration讀入資料庫建立架構 php artisan migrate:rollback //推回上一次的migration php artisan migrate:reset //推回全數的migration php artisan migrate:refresh //推回所有遷移並且再執行一次 php artisan migrate --seed //將這次的migration讀入資料庫建立架構並且也跑seeder php artisan migrate:refresh --seed //推回所有遷移並且再執行一次以及seeder php artisan db:seed //單純跑資料的seeder 填充資料 ","date":"2022-03-02","objectID":"/laravel/:6:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Test php artisan make:test {檔案名稱} //測試程式 想必大家到這步驟已經對 Laravel 不陌生了，已經熟悉上面的教學介紹後，可以再去學習下一篇 Laravel 進階，會有如何使用內建會員系統，以及如何判斷 RESTful API 是否登入等進階實作ㄡ～ ","date":"2022-03-02","objectID":"/laravel/:6:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"參考資料 PHP與Laravel簡介 比較 PHP 網頁框架 Laravel 從入門到放棄 (一) – 透過 composer 架設 laravel 網站 PHP Laravel 安裝教學 資料庫設計概念 - ORM Laravel 6.0 初體驗！怎麼用最新的 laravel 架網站！ Laravel Route(路由) ","date":"2022-03-02","objectID":"/laravel/:7:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"由於網路上文章幾乎都是使用 Apache 來實作第一個 PHP RESTful API，也比較沒有中文的介紹，剛好這次也還在學習，所以把學習的紀錄分享給大家，這次會搭配實作留言板來說明，那本次教學內容採用的是 macOS 11.6 Nginx 1.21.6 PHP 8.1.2 無框架 無物件導向 來做教學以及示範，那我們先來簡單了解一下什麼是RESTful API： ","date":"2022-02-24","objectID":"/php-restful-api/:0:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"什麼是RESTful API ","date":"2022-02-24","objectID":"/php-restful-api/:1:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"定義 REST ，指得是一組架構約束條件和原則，符合 REST 設計風格的Web API 稱為 RESTful API，主要以下面三點為定義 直觀簡單的資源網址 URL 比如：http://example.com/resources 對資源的操作：Web 服務在該資源上所支持的請求方法，比如：POST、GET、PUT、PATCH、DELETE 傳輸的資源：Web 服務接受與返回的類型，比如：JSON、XML 分別說明每一項定義 直觀簡單的資源網址 URL RESTful API URL 結構 (Best Practices for RESTful API Design)\" RESTful API URL 結構 (Best Practices for RESTful API Design) 可以看到這張圖後面的 Endpoint，分別代表應用服務 (Application context) 、 版本 (Version)、 資源(Resource)、 參數(Parameter) 。 應用服務：可以取名 api 或是 restful-api 。 版本：可以對 API 進行版本控制，可以有升級的服務，也不會對現有的 API 造成影響。 資源：要使用名詞而非動詞來命名，且建議使用複數 壞的命名(以我們要實作的留言板查詢、新增、修改、刪除示範) 查詢 /selectmessage 新增 /createmessage 修改 /updatemessage 刪除 /deletemessage 好的命名 查詢 GET =\u003e /messages (回傳所有留言) 新增 POST =\u003e /messages (新增留言) 修改 PUT =\u003e /messages/1 (修改單筆留言全部資料) 修改 PATCH =\u003e /messages/1 (修改單筆留言有更動資料) 刪除 DELETE =\u003e /messages/1 (刪除單筆留言) 對資源的操作 RESTful API 傳送時，會依照我們所定的 HTTP Request Method 請求方法，那主要有以下 5 種的 Method GET : 此方法只能向指定的資源要求取得資料，並不會更動內部的資料 POST：向指定的資源要求新增資料 PUT：向指定的資源要求修改資料內容 PATCH：向指定的資源要求修改部分資料內容 DELETE：向指定的資源要求刪除資料內容 傳輸的資源 剛剛是客戶端對伺服器的請求，那我們也要針對他的請求給予對應的回應 Response ，那回應的格式有 JSON 、XML ，但都以 JSON 較為普遍，所以我們後續實作也會以 JSON 作為我們的 Response 。 回應的格式內容會依照文件所自訂，但基本上都會回傳狀態碼 http status code ，下面就用表格的方式來說明常用的狀態碼、以及狀態碼對應的意思跟我們在 RESTful API 使用的場景。 狀態碼 名稱 說明 RESRful API 使用場景 200 OK 請求成功 GET、PUT 方法，取得資料 201 Created 新的資源已建立 POST 方法，新增資料 204 No Content 沒有返回任何內容 DELETE 方法，刪除資料 400 Bad Request 請求不正確 401 Unauthorized 用戶需要認證 403 Forbidden 禁止訪問，與401 不同的是，用戶已經認證，但沒有權限 404 Not Found 沒有找到指定的資源 GET、PUT、DELETE 方法，該資料不存在 500 Internal Server Error 伺服器發生錯誤 ( 參考RESTful Web API 設計指南 ) ","date":"2022-02-24","objectID":"/php-restful-api/:1:1","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"為什麼要使用 RESTful API REST 使用所有標準 HTTP 協議方法 - GET、POST、PUT、DELETE、PATCH ，以及更具體的 URL 。 REST 將客戶端與伺服器之間的操作分開 - 他允許開發人員使用它們希望使用的任何前端技術，包含像是 AngularJS、Bootstrap、VUE、Ember、ReactJS、CycleJS、ExtJS、PHP、.NET 等等，極大提高了可移植性。 REST 針對 web 進行了優化 - 因為它依賴 HTTP 協議。此外，由於它的主要數據格式是 JSON，它基本上兼容所有互聯網瀏覽器。 ","date":"2022-02-24","objectID":"/php-restful-api/:1:2","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"RESTful API 安全性 我們在設計 API 時，要確保 RESTful API 的安全性，像是 PUT 、 DELETE 更新刪除這類型的操作並不安全，沒有權限認證下任何人都可以使用來操作，總不可能讓陌生人去更動我們的資料吧？因此安全性沒有做足夠容易成為駭客攻擊的對象。 要怎麼做比較安全？ 例如我們的留言板：登入後(帳號密碼) \u003e 伺服器驗證成功並取的一組的 API token \u003e 就可以使用這組 token 來訪問 API 資源，也就知道是誰去對這筆資料進行操作 ","date":"2022-02-24","objectID":"/php-restful-api/:1:3","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"實作開始 ","date":"2022-02-24","objectID":"/php-restful-api/:2:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"1. 修改 Nginx.conf 我們這邊就直接對架設好的 Nginx 設定檔來修改，如果不清楚要怎麼架設的，這方面網路上蠻多文章，如果還是不清楚，可以留言告訴我，我在另外寫一篇文章來介紹環境安裝。 為什麼要先修改 conf 呢？修改的目的就是要讓原本網址 http://localhost/api/index.php?messages=all 變成 http://localhost/api/messages 來實現我們在介紹時所說的直觀簡單的資源網址，我說明一下上面網址的關係， http://localhost 是因為我們本地端運行，如果已經上線的，那就是你自己的網址， /api 是我來放這支 api 的目錄，他位於網頁的根目錄下方(詳細的配置下方會附上)， index.php 是我來放這支 api 的網頁，後面的 messages 是我們這次的資源，後面可以接我想要處理的參數 那要怎麼達成讓網址變成我們想要呈現的直觀簡單的網址呢，這時候我們就要使用 Nginx.conf 來做設定，網路上的文章比較多的是 apache 的 htaccess，我一開始還以為 Nginx 也可以使用 htaccess ，試了半天才知道，在 Nginx 要改用 Nginx.conf 來設定，那我下方會附上我原本的 .htaccess 以及轉換後的 conf，那接下來我一步一步來介紹 線上轉換工具 網路上蠻多工具可以線上轉換，我推薦可以用 Apache htaccess to Nginx converter Apache .htaccess 檔案 RewriteRule ^/api/messages$ /api/index.php?messages=all [nc,qsa] RewriteRule ^/api/messages/(\\d+)$ /api/index.php?messages=$1 [nc,qsa] 這是我會修改部分的 Nginx.conf ，可以看到最後兩條 location，這邊就是我們轉換過來的設定 Nginx.conf 檔案(片段) server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm index.php; } location = /api/messages { rewrite ^(.*)$ /api/index.php?messages=all; } location /api { rewrite ^/api/messages/(\\d+)$ /api/index.php?messages=$1; } 他的意思代表的我們網址路徑是在 /api/messages ，我們讓原本 /api/index.php?messages 這段變成 /api/messages/ 的設定，設定好記得先下 sh sudo nginx -t 指令來檢查一下Nginx.conf檔案是不是都正確，再用 sh sudo nginx -s reload 指令重新啟動 Nginx (是否成功，後面會帶到如何做測試，就繼續一起往下看吧！) CREATETABLE`messages`(`id`intNOTNULL,`name`varchar(20)CHARACTERSETutf8mb4COLLATEutf8mb4_unicode_ciNOTNULL,`message`textCHARACTERSETutf8mb4COLLATEutf8mb4_unicode_ciNOTNULL,`sendtime`datetimeNOTNULL,`version`intDEFAULTNULL)ENGINE=InnoDBDEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci; ","date":"2022-02-24","objectID":"/php-restful-api/:2:1","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"參考資料 PHP實現RESTful風格的API實例 [XAMPP][PHP] 製作Restful API Best Practices for RESTful API Design RESTful API與MVC名詞介紹 ","date":"2022-02-24","objectID":"/php-restful-api/:3:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"1. PHP 是什麼 PHP 全名是超文本前處理器(Hypertext Preprocessor)，是一種開源的通用電腦手稿語言 根據W3Techs的報告，截至2021年9月，有78.9%網站都是使用PHP，像是著名的 FaceBook、Tesla、Slack、WordPress stackshare 是分享開發工具的網站，可以看到不少公司也是使用PHP來進行開發的 其優點是 是開源、免費的 是跨平台的開發語言，Linux、Windows、macOS也可以使用 能開發：動態網站、爬蟲程式、WordPress 外掛佈景主題 也可以結合多種的資料庫，例如：Mysql、Mariadb、Oracle 過去使用 PHP 開發網頁程式，就是有什麼寫什麼，程式邏輯和網頁顯示混在一起，雖然開發方便但會造成高維護成本，和難以擴充功能 物件導向程式設計 函數式編程 事件驅動程式開發 PHP 有各式各樣的 Web Framework： Laravel - 最受歡迎的PHP Web Framewrok Codelgniter - 最新版的Codelgniter4 只有 1.4 MB，小而強 ","date":"2022-02-22","objectID":"/php/:1:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"php-cli vs php-fpm CGI CGI 是一種協定，為了保障 web server 傳過來的資料是標準格式 如果請求 index.html ，web server 會先去找這個文件，在丟給瀏覽器，但這個僅限靜態文件而已 如果請求 index.php ，就需要去找 php 的解析器來處理，那處理中一定會傳遞一些資料，像是 post 或是 url 還有 http header等，CGI 就是規定要傳哪些資料、以及怎麼樣的格式 FastCGI 是用來提高 CGI 處理性能用的 PHP-cli vs PHP-fpm PHP-cli 可以直接在命令列使用php命令來處理或顯示 php檔案，因為他內建了一個 HTTP 伺服器，可以提供 HTTP 服務 PHP-fpm 是一個多進程架構的 FastCGI 服務，內建了 PHP 的解析器，配合Nginx來使用 ","date":"2022-02-22","objectID":"/php/:1:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"2. PHP 基本語法 ","date":"2022-02-22","objectID":"/php/:2:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"標籤 PHP 程式可以放置在檔案中的任何位置，其檔案副檔名是.php， PHP的標籤是開頭 \u003c ?php 以及 ? \u003e 結尾 \u003c?php [ 程式碼 ] ?\u003e PHP 不分大小寫，例如 if、else、while、echo，函數等，但變數有區分大小寫 $color = 'blue'; echo \"My car is \" . $color . \"\u003cbr\u003e\"; ECHo \"My car is \" . $cOLOr . \"\u003cbr\u003e\"; eCHo \"My car is \" . $COLOR . \"\u003cbr\u003e\"; My car is blue My pen is My dog is ","date":"2022-02-22","objectID":"/php/:2:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"註解 PHP 程式中可以使用註解功能，註解後該段程式不會被執行 PHP 單行註解 // 註解的用意是可以告訴自己或是閱讀該程式的人該行程式碼的用意或想法 PHP 多行註解 /* 註解的用意是可以告訴自己或是閱讀該程式的人該行程式碼的用意或想法 echo \"My car is \" . $color . \"\u003cbr\u003e\"; ECHo \"My car is \" . $cOLOr . \"\u003cbr\u003e\"; eCHo \"My car is \" . $COLOR . \"\u003cbr\u003e\"; */ ","date":"2022-02-22","objectID":"/php/:2:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"變數 PHP 程式中可以使用變數功能，變數是儲存訊息的容器，變數以\" $ “符號開頭，後面是變數名稱 PHP 變數規則 變數名必須以字母或是下底線開頭，不可以用數字開頭 變數名只包含字母數字或是下底線(A-z、0-9、_) 變數名區分大小寫 ($age 跟 $AGE 是兩個不同的變數) $color = 'blue'; $items = 'Toy'; $num1 = '13'; $num2 = '18'; echo \"I have \" . $num1+$num2 . \" \" . $color . \" \" . $items; I have 31 blue Toy ","date":"2022-02-22","objectID":"/php/:2:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"變數作用區 PHP 變數有不同的作用區(local、global、static) local 函式中的變數具有local scope，只能用於該函式中使用 \u003c?php function myTest() { $x = 5; // local scope echo \"\u003cp\u003eVariable x inside function is: $x\u003c/p\u003e\"; } myTest(); // using x outside the function will generate an error echo \"\u003cp\u003eVariable x outside function is: $x\u003c/p\u003e\"; ?\u003e Variable x inside function is: 5 Variable x outside function is: global 函式外部的變數具有global scope，只能用於該函式外部使用 \u003c?php $x = 5; // global scope function myTest() { // using x inside this function will generate an error echo \"\u003cp\u003eVariable x inside function is: $x\u003c/p\u003e\"; } myTest(); echo \"\u003cp\u003eVariable x outside function is: $x\u003c/p\u003e\"; ?\u003e Variable x inside function is: Variable x outside function is: 5 想要在函式中，用外部的變數，就在函式內用global 來定義變數 \u003c?php $x = 5; $y = 10; function myTest() { global $x, $y; $y = $x + $y; } myTest(); echo $y; // outputs 15 ?\u003e 15 static 正常函式執行完，變數值都會被刪除，想要保留值可以加 static \u003c?php function myTest() { static $x = 0; echo $x; $x++; } myTest(); myTest(); myTest(); ?\u003e 012 ","date":"2022-02-22","objectID":"/php/:2:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"顯示 PHP 程式中可以用 echo 以及 print 來顯示資訊 PHP echo / print 顯示 \u003c?php $txt1 = \"學習PHP\"; $txt2 = \"Ian_Zhuang\"; $x = 5; $y = 4; echo \"\u003ch2\u003e\" . $txt1 . \"\u003c/h2\u003e\"; echo $txt2 . \" 在 \" . $txt1 . \"\u003cbr\u003e\"; echo $x + $y; print \"\u003ch2\u003e\" . $txt1 . \"\u003c/h2\u003e\"; print $txt2 . \" 在 \" . $txt1 . \"\u003cbr\u003e\"; print $x + $y; ?\u003e 學習PHP Ian_Zhuang 在 學習PHP 9 學習PHP Ian_Zhuang 在 學習PHP 9 ","date":"2022-02-22","objectID":"/php/:2:5","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"資料型態 變數可以儲存不同型態的資料，以下是 PHP 支持的資料型態 小提示 可以用var_dump() 函數來查看資料的型態以及值 字串 (String) 整數 (Integer) 浮點數 (Float) 布林 (Boolean) 陣列 (Array) 物件 (Object) 空值 (NULL) 字串 (String) 字串可以是引號內的任何文本，可以使用單引號或雙引號來表示 \u003c?php $x = \"Hello world!\"; $y = 'Hello world!'; echo $x; echo \"\u003cbr\u003e\"; echo $y; ?\u003e Hello world! Hello world! 整數 (Integer) 整數有幾點規則： 必須至少有一個數字 不能有小數點 可以是正數也可以是負數 可以指定不同的進制表示法 其範圍介於 -2,147,483,648 和 2,147,483,647 之間的非十進制數 \u003c?php $x = 5985; var_dump($x); ?\u003e int 5985 浮點數 (Float) 浮點數是帶小數點的數字或指數形式的數字 \u003c?php $x = 10.365; var_dump($x); ?\u003e float 10.365 布林 (Boolean) 布爾值表示兩種可能的狀態：TRUE 或 FALSE \u003c?php $x = true; $y = false; var_dump($x); ?\u003e boolean true 陣列 (Array) 陣列可以將多個值存在一個變數中 \u003c?php $x = 10.365; var_dump($x); ?\u003e array (size=3) 0 =\u003e string 'Apple' (length=5) 1 =\u003e string '小米' (length=6) 2 =\u003e string 'Sony' (length=4) 物件 (Object) 在討論物件前，要先知道類別(Class)與物件(Object)的關係 類別 (Class) ：可以比喻為房屋的設計藍圖，是為了讓大家了解房屋的結構與形狀。 物件 (Object) ：可以比喻為真的房屋，物件是類別的實體化 為了要蓋好一棟房子有房子的設計藍圖(類別)還不夠，還需要蓋房子的材料，而材料就是所謂的資料(data)。 類別定義結構和行為用來產生物件，當多個物件是由同一 個類別產生出來時，每個物件都是一個獨立個體。 建立類別語法很簡單，只需要使用 Class 來定義一個類別 \u003c?php class MyClass { // 在大括號裡面宣告類別的屬性與方法 } $obj = new MyClass; //使用 new 來實體化類別並將他存入變數中 var_dump($obj); //查看類別內容 ?\u003e object(MyClass)[1] 我們在替 MyClass 加入屬性，用 public 決定屬性的可視性 \u003c?php class MyClass { public $prop = \"I'm a class Property\"; } $obj = new MyClass; echo $obj-\u003eprop; ?\u003e I'm a class Property 因為有很多物件實例化都來自同一個類別，如果沒有指定被實體化的物件，程式碼會無法判斷，所以要用 -\u003e 在 PHP 的物件中，來存取物件的屬性和方法。 定義類別(Class)的方法(Methods)，方法(Methods)是類別裡面的函式(Functions)，物件可以藉由執行這些方法來更動每個物件的行為。 \u003c?php class MyClass { public $prop = \"I'm a class Property!\"; public function set($newval) { $this-\u003eprop = $newval; } public function get() { return $this-\u003eprop . \"\u003cbr /\u003e\"; } } $obj = new MyClass; echo $obj-\u003eget(); //得到屬性的值。 $obj-\u003eset(\"I'm a new Property value!\"); //設定新的屬性的值。 echo $obj-\u003eget(); ?\u003e I'm a class Property! I'm a new Property value! 物件導向允許物件透過$this來參考自己。物件使用$this就如同直接使用物件名稱來指定物件，同等於MyClass-\u003eprop1。 空值 (NULL) Null 是一種特殊的數據類型，它只能有一個值：NULL 如果創建的變量沒有值，則會自動為其分配 NULL \u003c?php $x = \"Hello world!\"; $x = null; var_dump($x); ?\u003e null ","date":"2022-02-22","objectID":"/php/:2:6","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"運算符號 PHP 將運算符號分為以下幾組 算術運算符 賦值運算符 比較運算符 邏輯運算符 字符串運算符 算術運算符 \u003c?php $x = 3; $y = 6; echo $x + $y; // 輸出 x + y ，3 + 6 ，顯示 9 echo $x - $y; // 輸出 x - y ，3 - 6 ，顯示 -3 echo $x * $y; // 輸出 x * y ，3 * 6 ，顯示 18 echo $x / $y; // 輸出 x / y ，3 / 6 ，顯示 0.5 echo $x % $y; // 輸出 x % y ，3 % 6 ，顯示 3 echo $x ** $y; // 輸出 x ^ y ，3 ^ 6 ，顯示 729 ?\u003e 賦值運算符 \u003c?php $x = 3; $y = 6; echo $x += $y; //輸出 x = x + y ， 9 = 3 + 6 ，輸出 9 $x = 3; $y = 6; echo $x -= $y; //輸出 x = x - y ， -3 = 3 - 6 ，輸出 -3 $x = 3; $y = 6; echo $x *= $y; //輸出 x = x * y ， 18 = 3 * 6 ，輸出 18 $x = 3; $y = 6; echo $x /= $y; //輸出 x = x / y ， 0.5 = 3 / 6 ，輸出 0.5 $x = 3; $y = 6; echo $x %= $y; //輸出 x = x % y ， 3 = 3 % 6 ，輸出 3 ?\u003e 比較運算符 \u003c?php $x = 3; $y = 6; $z = \"6\"; var_dump($x == $y); // 判斷 x 等於 y (值)，3 不等於6 ，回傳 false var_dump($x === $z); // 判斷 x 等於 z (型態and值)，數字不等於字串 ，回傳 false var_dump($x != $y); // 判斷 x 不等於 y (值)，3不等於6 ，回傳 true var_dump($x \u003c\u003e $y); // 判斷 x 不等於 y (型態)，數字不等於字串 ，回傳 true var_dump($x \u003e $y); // 判斷 x 大於 y ，3沒有大於6 ，回傳 false var_dump($x \u003c $y); // 判斷 x 小於 y ，3小於6 ，回傳 true var_dump($x \u003e= $y); // 判斷 x 大於等於 y ，3沒有大於等於6 ，回傳 false var_dump($x \u003c= $y); // 判斷 x 小於等於 y ，3小於等於6 ，回傳 true var_dump($x \u003c=\u003e $y); // 判斷 x y 的關係 ，如果 x 大於 y ，回傳 1 ; 如果 x 小於 y ，就回傳 -1 ; 如果 x 等於 y ，就回傳 0 ?\u003e 邏輯運算符 \u003c?php $x = 3; $y = 6; if ($x == 3 and $y == 6){ echo \"And\"; } // 判斷 x 等於 3 且 y 等於 6 (兩者都要true) if ($x == 3 or $y == 9){ echo \"Or\"; } // 判斷 x 等於 3 或 y 等於 9 (擇一true) if ($x == 3 \u0026\u0026 $y == 6){ echo \"And\"; } // 判斷 x 等於 3 且 y 等於 6 (兩者都要true) if ($x == 3 || $y == 9){ echo \"Or\"; } // 判斷 x 等於 3 或 y 等於 9 (擇一true) if ($x == 3 xor $y == 9){ echo \"Xor\"; } // 判斷 x 等於 3 或 y 等於 9 (任一者為true，但只能一者為true) if ($x != 4){ echo \"Not\"; } // 判斷 x 不等於 4 ?\u003e ","date":"2022-02-22","objectID":"/php/:2:7","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"條件判斷 條件語句用於根據不同的條件下的操作 if if…else if…elseif…else switch if 如果條件為真，就執行代碼 案例：如果現在時間(hour)小於20，就輸出 Have a good day ! \u003c?php $t = date(\"H\"); if ($t \u003c \"20\") { echo \"Have a good day!\"; }s ?\u003e 輸出 Have a good day! if-else 如果條件為真，就執行該程式碼，如果條件為假，就執行另一個程式碼 案例：如果現在時間(hour)小於20，就輸出 Have a good day! ，超過時間，就輸出 Have a good night! \u003c?php $t = date(\"H\"); if ($t \u003c \"20\") { echo \"Have a good day!\"; } else { echo \"Have a good night!\"; } ?\u003e if-elseif-else 針對兩個以上的條件判斷，如果條件為真，就執行該程式碼，如果條件為假，就執行另一個程式碼 案例：如果現在時間(hour)小於10，就輸出 Have a good morning! ，如果時間小於20，輸出Have a good day!，否則，就輸出 Have a good night! \u003c?php $t = date(\"H\"); if ($t \u003c \"10\") { echo \"Have a good morning!\"; } elseif ($t \u003c 20) { echo \"Have a good day!\"; } else { echo \"Have a good night!\"; } ?\u003e switch 根據不同的條件來執行不同的操作 \u003c?php $weather = '下雨天'; switch($weather) { case '晴天': echo \"今天天氣是『 $weather』\"; break; case '陰天': echo \"今天天氣是『 $weather』\"; break; case '下雨天': echo \"今天天氣是『 $weather』\"; break; default: echo \"世界末日\"; break; } ?\u003e ","date":"2022-02-22","objectID":"/php/:2:8","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"迴圈 想要相同程式碼反覆執行一定的次數 while do…while for foreach while 只要指定條件為真，就會循環通過該程式碼 \u003c?php $x = 1; while($x \u003c= 3) { echo \"The number is: $x\u003cbr\u003e\"; $x++; } ?\u003e 輸出 The number is: 1 The number is: 2 The number is: 3 do…while 先執行一次do，再檢查指定條件是否為真，是的話就會循環通過該程式碼 \u003c?php $x = 1; do { echo \"The number is: $x\u003cbr\u003e\"; $x++; } while ($x \u003c= 5); ?\u003e 輸出 The number is: 6 因為do…while的條件會在執行循環程式碼後才檢查，所以do…while 至少會循環一次該程式碼。 for 假如預先知道需要循環幾次，就可以使用for，可以設定程式碼在循環中的次數。 \u003c?php for ($x = 0; $x \u003c= 10; $x++) { echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 2 The number is: 3 The number is: 4 The number is: 5 The number is: 6 The number is: 7 The number is: 8 The number is: 9 The number is: 10 foreach 此循環適用於陣列，可以用來顯示陣列的key跟value \u003c?php $age = array(\"Peter\"=\u003e\"35\", \"Ben\"=\u003e\"37\", \"Joe\"=\u003e\"43\"); foreach($age as $x =\u003e $val) { echo \"$x= $val\u003cbr\u003e\"; } ?\u003e 輸出 Peter = 35 Ben = 37 Joe = 43 break 想要在迴圈執行中跳出，可以使用break 指令，來跳出循環。 \u003c?php for ($x = 0; $x \u003c 10; $x++) { if ($x == 4) { break; } echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 2 The number is: 3 continue continue 與 break 是相對的指令。break 中斷目前執行的迴圈，continue 則是回到迴圈的開頭，執行「下一次」迴圈。 \u003c?php for ($x = 0; $x \u003c 5; $x++) { if ($x == 2) { continue; } echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 3 The number is: 4 ","date":"2022-02-22","objectID":"/php/:2:9","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"函式 PHP除了內建的函式外，還可以創建自己的函式 注意：函式名稱必須以字母或下底線開頭。不區分大小寫。 \u003c?php function writeMsg() { echo \"Hello world!\"; } writeMsg(); // call the function ?\u003e 輸出 Hello world! 也可以在函式裡面放入任意數量的參數，只需要用逗號分開 \u003c?php function familyName($fname, $year) { echo \"$fnameBorn in $year\u003cbr\u003e\"; } familyName(\"Hege\", \"1975\"); familyName(\"Stale\", \"1978\"); familyName(\"Kai Jim\", \"1983\"); ?\u003e 輸出 Hege Born in 1975 Stale Born in 1978 Kai Jim Born in 1983 ","date":"2022-02-22","objectID":"/php/:2:10","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"3. PHP 常用函式 ","date":"2022-02-22","objectID":"/php/:3:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"日期和時間 可以透過輸入參數，顯示想要的日期 d - 代表月份中的某天（01 到 31） m - 代表一個月（01 到 12） Y - 代表年份（四位數） l（小寫“L”）— 代表星期幾 \u003c?php echo \"Today is \" . date(\"Y/m/d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"Y.m.d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"Y-m-d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"l\"); ?\u003e 輸出 Today is 2022/02/22 Today is 2022.02.22 Today is 2022-02-22 Today is Tuesday 可以透過輸入參數，顯示想要的時間 H - 一個小時的 24 小時格式（00 到 23） h - 小時的 12 小時格式，前面補零（01 到 12） i - 前面補零的分鐘（00 到 59） s - 前面補零的秒數（00 到 59） a - 小寫的 Ante meridiem 和 Post meridiem（am 或 pm） \u003c?php date_default_timezone_set(\"Asia/Taipei\"); echo \"The time is \" . date(\"h:i:sa\"); ?\u003e 輸出 The time is 12:12:10am 可以使用 strtotime()，顯示想要的日期 \u003c?php $d=strtotime(\"tomorrow\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; $d=strtotime(\"next Saturday\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; $d=strtotime(\"+3 Months\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; ?\u003e 輸出 2022-02-23 12:00:00am 2022-02-26 12:00:00am 2022-05-22 04:21:41am ","date":"2022-02-22","objectID":"/php/:3:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"json 可以使用 json_encode()，將陣列存為 JSON 格式，也可以用 json_decode()，將JSON格式變成陣列 \u003c?php $age = array(\"Peter\"=\u003e'35', \"Ben\"=\u003e'45', \"Ian\"=\u003e'22'); echo $enjson = json_encode($age); var_dump(json_decode($enjson,true)); ?\u003e 輸出 {\"Peter\":\"35\",\"Ben\":\"45\",\"Ian\":\"22\"} array (size=3) 'Peter' =\u003e string '35' (length=2) 'Ben' =\u003e string '45' (length=2) 'Ian' =\u003e string '22' (length=2) ","date":"2022-02-22","objectID":"/php/:3:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"min/max 可以使用 min()，來找到參數列表裡面的最小值，也可以 max()，來找到參數列表裡面的最大值 \u003c?php echo(min(0, 150, 30, 20, -8, -200)); echo '\u003cbr\u003e'; echo(max(0, 150, 30, 20, -8, -200)); ?\u003e 輸出 -200 150 ","date":"2022-02-22","objectID":"/php/:3:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"abs 可以使用 abs()，將參數值變成絕對值 \u003c?php echo(abs(-6.7)); ?\u003e 輸出 6.7 ","date":"2022-02-22","objectID":"/php/:3:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"round 可以使用 round()，將浮點數四捨五入到最接近的整數 \u003c?php echo(round(0.60)); echo '\u003cbr\u003e'; echo(round(0.49)); ?\u003e 輸出 1 0 ","date":"2022-02-22","objectID":"/php/:3:5","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"rand 可以使用 rand()，會隨機產生一個亂數，也可以設定最大值與最小值的範圍來隨機產生亂數 \u003c?php echo(round(0,100)); ?\u003e 輸出 88 ","date":"2022-02-22","objectID":"/php/:3:6","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"4. PHP 表單 ","date":"2022-02-22","objectID":"/php/:4:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"GET vs POST 舉個例子，如果 HTTP 代表現在我們現實生活中寄信的機制，那麼信封的撰寫格式就是 HTTP。我們可以將信封外的內容稱為 http-header，信封內的書信稱為 message-body。 假設 GET 表示信封內不得裝信件的寄送方式，像是明信片一樣，你可以把要傳遞的資訊寫在信封(http-header)上。而 POST 就是信封內有裝信件的寄送方式，不但信封可以寫東西，信封內 (message-body) 還可以放你想要寄送的資料或檔案。 因為使用 GET 的方法來傳送表單訊息對每個人都是可見的(所有的變數名稱與值都會顯示在 URL)，所以絕對不要使用 GET 來傳送密碼或是一些敏感訊息。 PHP 可以用 $_GET 和 $_POST 來收集表單數據 ","date":"2022-02-22","objectID":"/php/:4:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"GET 我們先模擬 $_GET ，先建立一個 index.html 的檔案程式碼如下 HTML 表單 (GET) \u003chtml\u003e \u003cbody\u003e \u003cform action=\"welcome_get.php\" method=\"get\"\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e E-mail: \u003cinput type=\"text\" name=\"email\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 再建立一個 welcome.php 的檔案程式碼如下 PHP ($_GET) \u003chtml\u003e \u003cbody\u003e Welcome \u003c?php echo $_GET[\"name\"]; ?\u003e\u003cbr\u003e Your email address is: \u003c?php echo $_GET[\"email\"]; ?\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-02-22","objectID":"/php/:4:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"POST 我們先模擬 $_POST ，先建立一個 index.html 的檔案程式碼如下 HTML 表單 (POST) \u003chtml\u003e \u003cbody\u003e \u003cform action=\"welcome_get.php\" method=\"post\"\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e E-mail: \u003cinput type=\"text\" name=\"email\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 再建立一個 welcome.php 的檔案程式碼如下 PHP ($_POST) \u003chtml\u003e \u003cbody\u003e Welcome \u003c?php echo $_POST[\"name\"]; ?\u003e\u003cbr\u003e Your email address is: \u003c?php echo $_POST[\"email\"]; ?\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-02-22","objectID":"/php/:4:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"資料驗證 密碼：需為8碼至20碼，且並包含特殊符號、大小寫英文字母、數字至少各1碼 \u003c?php $password = '@aaaa5aI'; if(preg_match('/(?=.*[@#$%^\u0026+=])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[@#$%^\u0026+=a-zA-Z0-9]{8,20}$/', $password)){ echo '密碼『',$password,'』正確。'; } else{ echo '密碼『',$password,'』不正確(需符合8至20碼，且包含特殊符號、大小寫英文、數字各一碼)。'; } ?\u003e 輸出 密碼『@aaaa5ai』不正確(需符合8至20碼，且包含特殊符號、大小寫英文、數字各一碼)。 密碼『@aaaa5aI』正確。 手機電話：需為10碼，且開頭為09接後8碼的數字 \u003c?php $phone = '0912345678'; if(preg_match('/^09[0-9]{8}$/', $password)){ echo '手機電話『',$phone,'』正確。'; } else{ echo '手機電話『',$phone,'』不正確(需為10碼，且符合開頭為09後接8碼的數字)。'; } ?\u003e 輸出 手機電話『0212345678』不正確(需為10碼，且符合開頭為09後接8碼的數字)。 手機電話『0912345678』正確。 信箱 \u003c?php $email = '123@gmail.com'; if(filter_var(\"$email\", FILTER_VALIDATE_EMAIL)) { echo '信箱『',$email,'』正確。'; } else{ echo '信箱『',$email,'』不正確。'; } ?\u003e 輸出 信箱『123@gmailcom』不正確。 信箱『123@gmail.com』正確。 ","date":"2022-02-22","objectID":"/php/:4:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"5. PHP RESTful REST ，指得是一組架構約束條件和原則，符合 REST 設計風格的Web API 稱為 RESTful API，主要以下面三點為定義 直觀簡單的資源網址URL 比如：http://example.com/resources 傳輸的資源：Web 服務接受與返回的類型，比如：JSON、XML 對資源的操作：Web 服務在該資源上所支持的請求方法，比如：POST、GET、PUT、PATCH、DELETE 加油 還有一篇可以一起學習 詳細可以參考另一篇文章 如何在 Nginx 下實作第一個 PHP 留言板 RESTful API 裡面有更詳細的介紹 ","date":"2022-02-22","objectID":"/php/:5:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"6. 資料來源 PHP 是什麼，架設網站最適合的程式語言 PHP 新手指南：3分鐘快速認識PHP PHP 教程 PHP基礎語法(一)：Hello world與基本資料型態 PHP-物件導向(OOP)介紹 秒懂PHP的FastCGI跟PHP-FPM有什麼關係 ","date":"2022-02-22","objectID":"/php/:6:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["youtube"],"content":"在過年要準備收假前，來一趟高級的露營，與很久不見的好友，一起泡溫泉、喝酒、吃烤肉、聊天， 還有甚麼事情，比這件事還更快樂的呢 ! 相關連結 過年自製MV(因版權，無法上傳YT)：Instagram 設備/剪輯/BGM 設備： 主攝影：GoPro 8 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Eternal Sunshine by LiQWYD \u0026 Luke Bergs https://soundcloud.com/liqwyd https://soundcloud.com/bergscloud Creative Commons — Attribution-ShareAlike 3.0 Unported — CC BY-SA 3.0 Free Download / Stream: https://bit.ly/3opx8U6 Music promoted by Audio Library https://youtu.be/Uzdp8rV2Nmc 相關連結 影片🎬：下方請收看 👇 ","date":"2022-02-20","objectID":"/lofi-land/:0:0","tags":["露營","朋友","旅遊","YouTube"],"title":"【自然圈豪華露營Lo fi Land】花好月圓人團圓VLOG","uri":"/lofi-land/"},{"categories":["codenotes"],"content":"PWA 全名是 Progressive Web App，也就是漸進式的網站應用程式，逐步的將網站漸進優化為具備 APP 的優點，其有以下幾點特性。 ","date":"2022-02-19","objectID":"/pwa/:0:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"介紹 PWA 全名是 Progressive Web App，也就是漸進式的網站應用程式，逐步的將網站漸進優化為具備 APP 的優點，其有以下幾點特性。 Progressive 漸進式，提供每一位用戶做基本的瀏覽。 Responsive 響應式的用戶介面，可以在不同裝置下作最佳化的顯示。 Connectivity independent 不依賴網路連接，透過 service workers 可以在低頻寬甚至是離線的環境下瀏覽網站。 App-like 讓網站可以具有像 APP 般的瀏覽速度等優點，提供更佳的用戶體驗。 Fresh 藉由 service worker 自動更新網站內容。 Installable 可以藉由 Add To Home，如同 App，會新增一個 icon，可以直接將網站加到手機桌面上做切換使用，不需要再透過 App Store 下載安裝。 詳細可參考官方網站 ","date":"2022-02-19","objectID":"/pwa/:1:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"實際安裝 範例下載位置 先下載 https://nas.pin-yi.me/sharing/nElXqbqyt (放置小弟NAS雲端上) 內有兩個檔案，分別是manifest.json、service-worker.js，以下各別做介紹 ","date":"2022-02-19","objectID":"/pwa/:2:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"manifest.json (簡易介紹，詳細可參考官方文件) { \"background_color\": \"#fff\", \"display\": \"standalone\", \"orientation\":\"portrait\", \"theme_color\": \"#fff\", \"short_name\": \"縮短名稱\", \"name\": \"名稱\", \"description\": \"說明\", \"lang\": \"zh-TW\", \"icons\": [ { \"src\": \"images/logo/logo180.ico\", \"sizes\": \"180x180\", \"type\": \"image/png\" }, { \"src\": \"images/logo/logo48.ico\", \"sizes\": \"48x48\", \"type\": \"image/png\" } ], \"start_url\": \"./index.php\" } background_color 背景顏色 定義 Web 應用程式預期的背景顏色，這能在 Web 應用程式的啟動和載入內容之間創建平順的過場。 \"background_color\": \"#fff\" display 背景顏色 定義開發者喜好的 Web 應用程式顯示模式。 \"display\": \"standalone\" 顯示模式 描述 fullscreen 所有可用的顯示區域都被填充並且不顯示使用者代理 chrome 。 standalone 這看起來和感覺上就像是獨立應用程式一樣，包括有不同的執行視窗、有圖示的應用程式啟動器 … 等等。 在這模式下，使用者代理將不包含控制導覽列，但能包含其他的 UI 元素，像是狀態列。 minimal-ui 這看起來和感覺上就像是獨立應用程式一樣，但將有控制導覽列 UI 元素的最小設置，元素會因瀏覽器而不同。 browser 預設值。 應用程式如常規般地被開啟於瀏覽器分頁或新視窗，依瀏覽器與平台而不同。 orientation 螢幕顯示方向 定義預設的顯示方向，通常應用在 GAME 裡，可能會需要強制設定方向。 \"orientation\": \"portrait\" theme_color 網站佈景顏色 設定網站每個頁面的主題顏色，例如改變 URL 的顏色。 \"theme_color\": \"#fff\" short_name 縮短名稱 定義 Web 應用程式的縮短名稱。 \"short_name\": \"縮短名稱\" name 名稱 定義 Web 應用程式的名稱。 \"name\": \"名稱\" name 名稱 定義 Web 應用程式的名稱。 \"name\": \"名稱\" description 說明 提供一段描述來形容這個 Web 應用程式的作用是什麼。 \"description\": \"說明\" lang 語言 定義 Web 應用程式的語言。 \"lang\": \"zh-TW\" icons 圖示 應用程式圖示的物件。 \"icons\": [ { \"src\": \"images/logo/logo180.ico\", \"sizes\": \"180x180\", \"type\": \"image/png\" }, { \"src\": \"images/logo/logo48.ico\", \"sizes\": \"48x48\", \"type\": \"image/png\" } ] start_url 開始網址 定義 Web 應用程式的開始位置。 \"start_url\": \"./index.php\" service-worker.js // 當service worker在「安裝階段」時會觸發此事件 self.addEventListener('install', function(event) { console.log('[Service Worker] Installing Service Worker ...', event); }); // 當service worker在「激活階段」時會觸發此事件 self.addEventListener('activate', function(event) { console.log('[Service Worker] Activating Service Worker ...', event); return self.clients.claim(); // 加上這行是為了確保service worker被正確載入和激活，不加也行 }); self.addEventListener('fetch', function(event) { console.log('[Service Worker] Fetch something ...', event); event.respondWith(fetch(event.request)); }); let deferredPrompt; self.addEventListener('beforeinstallprompt', function(event) { console.log('beforeinstallprompt fired'); event.preventDefault(); // 取消預設的直接跳出通知設定 deferredPrompt = event; // 將監聽到的install banner事件傳到deferredPrompt變數 return false; }); if(deferredPrompt) { // 確定我們有「攔截」到chrome所發出的install banner事件 deferredPrompt.prompt(); // 決定要跳出通知 // 根據用戶的選擇進行不同處理，這邊我指印出log結果 deferredPrompt.userChoice.then(function(choiceResult) { console.log(choiceResult.outcome); if(choiceResult.outcome === 'dismissed'){ console.log('User cancelled installation'); }else{ console.log('User added to home screen'); } }); deferredPrompt = null; // 一旦用戶允許加入後，之後就不會再出現通知 } ","date":"2022-02-19","objectID":"/pwa/:2:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"使用方式 先將 manifest.json 上述資料改為自己想要的設定，將manifest.json、service-worker.js 放置網頁根目錄，並開啟想要支援的網頁，以下使用小弟我個人頁面來做示範。 先至編輯器內將manifest.json放到head內 \u003clink rel=\"manifest\" href=\"./manifest.json\"\u003e 範例頁面\" 範例頁面 於程式最後新增以下 \u003cscript\u003e if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('./service-worker.js') .then(function() { console.log(\"Service Worker Registered, Cheers to PWA Fire!\"); }); } ); } \u003c/script\u003e 範例頁面\" 範例頁面 提醒 manifest.json、service-worker.js　依據自己放置位置做更改😀 ","date":"2022-02-19","objectID":"/pwa/:3:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"如何使用 ","date":"2022-02-19","objectID":"/pwa/:4:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"IOS 手機：Iphone 12 Pro (IOS 14.5) 瀏覽器：Safari 先瀏覽範例網站小弟個人頁面。 點選下方中間分享圖示，選擇加入主畫面，按下新增，就會出現在手機主畫面，打開後，就會發現操作跟APP相同。 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:4:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"ANDROID 手機：OnePlus 8T (ANDROID 11) 瀏覽器：Chrome 先瀏覽範例網站小弟個人頁面。 安裝應用程式至手機，經過下載，就會出現在手機主畫面，打開後，就會發現操作跟APP相同。 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:4:2","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"成功畫面 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:5:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"其他說明 以上為備份筆記 資料來源: https://ithelp.ithome.com.tw/articles/10186584 https://ithelp.ithome.com.tw/articles/10188514 ","date":"2022-02-19","objectID":"/pwa/:5:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["Network"],"content":"TCP 與 UDP 都是常見的網路通訊協定，這兩種協定能確保網際網路資料傳輸的快速以及完整性，它們的運作方式不太一樣，TCP 較為可靠，UDP 較為快速。 我們來慢慢分析兩種不同的網路通訊協定，有什麼特別之處!? ","date":"2022-02-18","objectID":"/tcp-udp-difference/:0:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"TCP 是什麼 TCP 是 (通訊控制協定) 也是網際網路上最常用的協定，這種協定較為可靠，其運作方法如下： TCP為每個封包分配一個唯一辨識碼和一個序號，這些號碼可以讓接收端識別封包的完整性以及封包順序。 當接收端收到封包後。如果順序正確，會向發送端傳送一個確認信號，以確定接收端有收到封包。 發送端收到確認信號後才會傳輸下一個封包。 如果封包遺失或是發送順序錯誤，接收端不會傳輸任何資訊，這代表發送端需要重新發送封包。 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:1:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"UDP 是什麼 UDP 不需要唯一識別碼和序號就可以完成相同工作，這種協定已串流方式傳輸資料，也因為發送端不會回傳確認信號，會不斷發送封包給接收端。UDP因為沒有確認，也不在乎封包是否遺失，所以很容易出錯，但因為不會檢查，所以傳輸速度比TCP更快。串流軟體、網路遊戲等都是使用此協定。 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:2:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"TCP vs. UDP 比較表 比較 TCP UDP 可靠性 可靠 不可靠 速度 慢 快 傳輸方式 封包依照順序傳輸 封包以串流方式傳輸 是否檢查錯誤與修正 有 無 適用服務內容 網站瀏覽、電子郵件、檔案瀏覽、要求可靠的傳輸服務 即時服務、線上遊戲、線上直播 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:3:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["youtube"],"content":"網路上流傳著一個說法，說台灣人一生必做的3大事情 登玉山 泳渡日月潭 單車環島 內文 雖然我這輩子應該不會想單車環島 但機車環島是我好久以前的一個夢想 大一時，剛學會騎車，很喜歡到處跑， 曾約了一群朋友要在大二時去環島， 可惜當時沒有時間去完成， 這次在退伍後工作前的空閒時間出發， 途中有藍天白雲，也有狂風暴雨，而且後者居多🥲 讓我看到台灣不一樣的景色 也算是送給我工作前的一份大禮🎁 旅遊各景點 景點代補上 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 8 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Be Myself by Nettson https://soundcloud.com/nettson Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/nettson-be-myself Music promoted by Audio Library https://youtu.be/bP17he7J85E Pineapple by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/2Xn3lAL Music promoted by Audio Library https://youtu.be/YxnWhkiLuHo Hold On by Spiring https://soundcloud.com/user-57630131 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/2VnhRHG Music promoted by Audio Library https://youtu.be/6UhZbct8UFs Our Time by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3ybRL96 Music promoted by Audio Library https://youtu.be/ASnMczLNZtg Santa Monica by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3AeTLOp Music promoted by Audio Library https://youtu.be/gzsiVYVH5hQ 相關連結 環島行程🏍：Google Map 環島影片🎬：下方請收看 👇 ","date":"2022-01-31","objectID":"/surround-island/:0:0","tags":["環島","機車","旅遊","YouTube"],"title":"【 四極點機車環島】台灣人一定要去一次的旅行，巧遇保育類動物穿山甲","uri":"/surround-island/"},{"categories":["youtube"],"content":"旅遊各景點 0:10 山姆先生咖啡館 0:30 馬太鞍濕地生態園區 1:16 紅瓦屋 1:48 光復糖廠 2:08 立川漁場 2:50 林田山林業文化園區 3:20 玉里麵 3:43 六十石山 4:57 金剛大道 5:44 七星潭 6:09 七星柴魚博物館 6:34 廟口紅茶 7:09 台開心農場 7:43 東大門夜市 8:25 太魯閣牌樓 8:49 燕子口步道 9:38 清水斷崖 10:21 清水斷崖獨木舟 12:18 野人火鍋 12:38 布洛灣山月吊橋 13:45 白楊步道水濂洞 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Scandinavianz - Love Me Jay Someday - Mind Travel Never A Goodbye 相關連結 影片🎬：下方請收看 👇 ","date":"2022-01-19","objectID":"/hualien-part3/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"好想再滑一次獨木舟 【Part 3】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part3/"},{"categories":["youtube"],"content":"我們的視野都是向前平視，何不試試用上帝視角來看花蓮海岸的美 旅遊各景點 0:12 雲山水夢幻湖 2:07 055龍蝦海鮮餐廳 2:45 花蓮路上 2:59 撒固兒步道 3:52 家咖哩總店 4:23 海崖谷露營休閒營區 6:01 海邊日出 7:14 親不知子斷崖 8:27 口福海鮮餐廳 8:43 北回歸線 9:15 石梯坪遊憩風景區 10:17 石門洞 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Poolside — LiQWYD [Audio Library Release] Never A Goodbye 相關連結 影片🎬：下方請收看 👇 ","date":"2022-01-16","objectID":"/hualien-part2/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"空拍帶你看花蓮 【Part 2】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part2/"},{"categories":["experience"],"content":"為什麼每次都會緊張到說不出話來?常被問的7個問題","date":"2022-01-14","objectID":"/interview/","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"自我介紹先放線頭，可以幫助面試官找到話題，以持續後面的面試 對徵才方的公司需要了解，且知道面試的職缺內容 不要只在乎自己能夠拿到甚麼，而是要說出自己對於這份工作可以付出多少的價值 ","date":"2022-01-14","objectID":"/interview/:0:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"履歷的基本技巧 面試後，必須自己提出問題，不僅僅只是單一方向的回答問題，也可以對問題提出討論或是感興趣的事(至少準備3個問題以上，且不要被問的問題框架給限制住了，可以先詢問問題的邊界在哪) 這個職位為甚麼而開，前一位同事是因為甚麼原因而離開的，想要知道自己適不適合，切記要使用禮貌性的問法 自我介紹目的是 : 1. 你能替公司解決甚麼問題 2. 你能替公司帶來甚麼價值 成功 我過去怎麼樣 擅長的事情 強項 我的最大強項是 令我感到自豪的 形式 要怎麼把你的技能，應用在你應徵的職位上 我在找的是 背下來，並重複練習，就會越來越習慣跟熟練 ","date":"2022-01-14","objectID":"/interview/:1:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"常見問題 面試者前往公司面試前，應事先準備以下幾點常見問題 答案盡量真實、切記說謊，避免日後產生更大的爭議。 請簡單自我介紹 不管面試官是否認真看過履歷，都沒有直接面對面的說明還來的直接，自我介紹通常是面試時，遇到的第一個問題。介紹時需簡短且着重自身專長以及工作經歷的描述上，一般而言，公司不會想知道你家庭背景，家裡有誰，只要提及自己是甚麼學校或科系，以及有甚麼特殊表現即可。 簡單說明前一份工作是做甚麼的、隸屬於甚麼部們、甚麼職稱，主要負責工作有那些、舉體表現以及相關成就如何，且使用數字化去量化它，不要只打執行主管交辦任務之類的答案。 如果是社會新鮮人，沒有工作經驗，可以放上在學校的專題成就或是參與社團經驗有甚麼讓你比較印象深刻，且與該工作內容性質有關。 自我介紹除了說明你自己的經歷外，也是一個最好行銷自己的方式，面試官可以從你自我介紹中更了解你，形成對你的第一印象，如果第一印象打壞了就很難救了，也不要講的漏洞百出，或是誇大其辭。 也建議大家要準備不同時間版本的自我介紹，一分鐘、三分鐘、五分鐘，先對鏡子練習，或找朋友協助，讓你習慣的這樣的感覺，在面試時，能夠發揮百分之百的你自己。 你的離職原因？ 為何想來我們公司？ 你的期望待遇是多少？ 你的優點是甚麼 你的弱點是甚麼 五年後的你在做甚麼 在所有候選人裡，我們為甚麼要僱用你 怎樣的狀況下你會選擇投入一家公司？怎樣的狀況下你會選擇離開？ 你還有什麼問題要問的？ 可以詢問這份履歷有沒有甚麼資訊不足，或是可以更好的地方 ","date":"2022-01-14","objectID":"/interview/:2:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"面試緊張恐懼要怎麼克服 面試時一定會遇到恐懼，其中以四種恐懼為主 個人形象的困擾：我們大多數人會不喜歡自己的聲音，不喜歡自己的身材，總會有些事情，讓我們不夠有自信，有時候，這就是我們內心的小劇場，我們要如何面對這種恐懼呢？ 可以先從衣著上提升，不管是視訊面試，還是現場面試，穿著體面的衣服，不要上半身正裝，下半身穿運動褲，當你把每件事情都做到100%，就可以投射出你的自信，修剪你的頭髮、擦亮你的皮鞋、確保你的個人衛生。 害怕說錯話：主管問你事情，你卻支支吾吾的，不知道該說甚麼，說錯話就會在心裡想：「我的天，我不應該這樣說的」，我們要如何面對這種恐懼呢？ 多練習，因為大部分的問題都是一樣的，當你知道問題，就應該要做好準備，可以讓親朋好友來協助你，讓他們多問幾次這些問題，從不同的角度，不管是面試的一開始，或是面試中和面試後，直到你可以不用思考就可以回答這些問題。腦中已經有個小腳本了，記得要把這些都寫出來，也不需要怕會不自然，就像是舞台上的表演者、或是在在演講的演講者，並不是他們都不需要排演。 害怕得不到這份工作：害怕自己失去這次機會，我們要如何面對這種恐懼呢？ 在去面試前，先靜下來，閉上眼睛，想像一下，你走進去面試場地或是加入線上聊天室中，大家面對你的微笑，試著想像成功，因為正面的期望，會帶來正面的效果。在腦中幻想的那些負面情緒，對你的表現沒有任何的幫助。 害怕別人的看法：作為一個人類，會很在乎大多數人或別人是怎麼看待我的，這是很正常的事情，我們要如何面對這種恐懼呢？ 你要把事情都先安排好，以防萬一發生，你可以有一個Plan B，但如果這是你的一切，你很難不緊張。可以先多找幾間要面試的公司，雖然那並不一定是你最想要的，但你知道，如果真的不幸搞砸了你最想要去的那一間，還有其他備案，將這種自信表現出來，你就可以很冷靜，表現出最真實的你自己。 ","date":"2022-01-14","objectID":"/interview/:3:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"資料來源 如何在面試中充滿自信 這樣回答保證錄取！破解面試官最愛問的 7 個問題 ","date":"2022-01-14","objectID":"/interview/:4:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"告訴你履歷製作的小技巧，以及什麼是千萬別做的地雷","date":"2022-01-14","objectID":"/resume/","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"在寫履歷之前，我們先設想一下，你這份履歷是要給誰看的呢? 像是HR、獵頭公司、跨部門同部門的同事嗎? 所以履歷的呈現方式，以及能不能讓他讀得懂很重要，你要把自己想成是個面試官，從面試官的角度去想，你希望看到那些內容 ","date":"2022-01-14","objectID":"/resume/:0:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"履歷的基本技巧 基本資料不用寫太多，不需要把從哪裡出生，家裡有幾個人通通寫出來，只需要簡單的名字、電話、地址等基本資料。 需要有明顯的內容分類，主要以四大為主，基本資料、工作經驗、最高學歷、相關技能。 履歷最好是不要超過一頁，除非是需要放作品集或是一些補充資訊，不管是有多少年的工作經驗，要想辦法把精華濃縮在這一頁中（將最重要以及最近期的工作經驗放到這一頁中，其他的相關經驗可以在面試時補充）最最最主要是要勾起面試官對你的好奇心。 如果是學生，剛出社會沒有任何的工作經驗，可以將學生時期所做的專案或是相關的課程放進履歷中。其中學生時期如果有實習經驗，更為重要，因為很多人就是沒有工作經驗，所以必須靠實習的經驗來加強你的履歷（真的沒有任何相關的工作經驗，可以將社團當任的那些職位，做了哪些事情，在其中達到了那些目標）。 要客制化自己的履歷，有時候會同時申請不同公司或是不同部門，要針對該公司該職位去客制化履歷。 例如面試的公司A是強調要獨立思考的，那在履歷中就可以寫自己所做的案子，B公司要的是團隊合作能力，那就可以在履歷中寫自己在團隊中扮演甚麼腳色，一起達到那些目標。 不要在履歷上寫到你的弱點，雖然面試時不能夠說謊去不承認你不會的東西，但是履歷就是一個包裝，履歷是給面試官的第一印象，你要把最完美的自己呈現出來。 在履歷表上，不要只說自己很會怎麼樣或是做過哪個案子，要把你做這個案子中，你做了那些改變，為公司或這麼案子帶來哪些好的影響，最好用數據化來量化你的成效（提升了多少的效率、幫公司省下多少錢），通常案子都是一個團體一起做，但是你只要強調你做出的貢獻。 要用實體的例子來證明自己的長處 可能會負責那些事情 會遇到那些困難 需要提供那些能力 這份工作需要的價值觀以及目標 ","date":"2022-01-14","objectID":"/resume/:1:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"履歷的地雷 不要放任何與職缺需要的專業能力無關的內容 如果是新鮮人，沒任何的工作經歷，也不要把參加活動的頭銜當作擁有的工作能力 要記得 要表現心目中那個好的自己，而且是最真實的自己 ! ","date":"2022-01-14","objectID":"/resume/:2:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["codenotes"],"content":".Net Core 是微軟新世代開發技術，不但實施了.NET跨平台開發與執行，同時也將框架大改造。 ","date":"2022-01-03","objectID":"/asp.net-core/:0:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"介紹 .Net Core 是微軟新世代開發技術，不但實施了.NET跨平台開發與執行，同時也將框架大改造。 優勢 跨平台 (可運行於Windows、Mac OSX、Ubuntu Liunx ) 是第一款Microsoft有跨平台能力的Ｗeb 開發框架，並支援雲端。 跨架構一致性（在x64、x86、ARM、ARM64不同處理器架構執行，仍然保持相同） 彈性部署（主機可用IIS、Apache、Docker）。 一種用於MVC和Web API的統一編程模型。 開放原始碼（使用MIS和Apache2授權的開放原始碼）。 單元測試（可測試性），並可模組化。 ","date":"2022-01-03","objectID":"/asp.net-core/:1:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"比較.NET Core / ASP.NET Code / ASP.NET Core MVC 比較 .NET Core ASP.NET Code ASP.NET Core MVC 代表 .NET Framework ASP.NET ASP.NET MVC 說明 平台框架，最廣泛的技術意義 網頁技術 ASP.NET Core 網頁技術中的MVC開發框架 ","date":"2022-01-03","objectID":"/asp.net-core/:2:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 是一種設計的樣式，代表Model、View、Controller 三個部分 Model 負責處理邏輯及資料面 (資料庫存取) View負責處理UI介面（HTML、Javescript、CSS） Controller負責接收Request請求、協調Model、View、將回應結果給使用者 該分工好處是可以達到關注點分離（SoC）、較好的分層架構、降低複雜度，往後方便對程式進行維護。 ","date":"2022-01-03","objectID":"/asp.net-core/:3:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"ASP.NET Core MVC? 是支援MVC設計的框架。 ","date":"2022-01-03","objectID":"/asp.net-core/:4:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 執行流程 使用者在瀏覽器輸入URL網址後，會發出Request 請求至伺服器 中間會先經過Routing路由機制，找到對應的Controller及Action Method Action 會呼叫Model，以讀取或是更新資料 Model會先進行邏輯計算及資料庫存取，再回傳給Action Action會將Model資料丟給View作網頁呈現 View Engine 將最終HTML 結果寫入Reponse 輸出資料流，回應給使用者瀏覽器。 ","date":"2022-01-03","objectID":"/asp.net-core/:5:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 專案資料夾功能說明 Properties\u003elaunchSettings.json (本機開發電腦的環境組態檔) wwwroot 資料夾 (公開的靜態資源檔目錄，如css、js、images等等) Controller 資料夾 (Controller 控制項類別所在目錄) Model 資料夾 (Model 模型類別所在目錄) View 資料夾 (有Home、Shared、_ViewImports.cshtml、_ViewStart.cshtml) Home 目錄內有Index、Provacy兩個cshtml Shared 目錄內有_Layout.cshtml、_ValidationScriptsPartial.cshtml、Error.cshtml appsettings.json (供應用程式使用的組態設定) Program.cs (程式進入點，主要負責創建Host、環境及組態設定) Startup.cs (負責DI Container及Middleware 元件設定) ","date":"2022-01-03","objectID":"/asp.net-core/:6:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["youtube"],"content":"花蓮LongStay 就從吉安鄉開始，和家人到花蓮長達一個月的生活正式開始囉！ 旅遊各景點 1:35 佳興檸檬汁 1:46 炸彈蔥油餅 3:45 貨櫃星巴克 4:18 玉里臭豆腐(貨櫃星巴克旁) 4:57 台灣海礦館 7:07 48高地戰備坑道 8:26 單一雞湯小卷米粉 8:59 松園別館 9:36 一心泡泡冰 10:25 好客藝術村 11:14 慶修院 11:50 慶豐麵店 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Travel Lovers Chasing Stars – Lesion X (No Copyright Music) Le Gang - I Don’t Need U 2 Say Anything AL’sic - Paradise 音樂版權聲明 Chasing Stars - Lesion X https://soundcloud.com/lesionxbeats Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3yeSVkb Music promoted by Audio Library https://youtu.be/WvXJm9seiJM 相關連結 影片🎬：下方請收看 👇 ","date":"2021-08-16","objectID":"/hualien-part1/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"花蓮吉安鄉在地旅遊 【Part 1】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part1/"},{"categories":["youtube"],"content":"想要知道花蓮該怎麼玩嗎？還不趕快訂閱加分享，下一集將在花蓮玩一個月給你看 從2021.08.01 到 2021.08.31 一個月的時間來玩遍整個花蓮 想要看哪個花蓮的景點，可以到下面留言喔🥰 設備/剪輯/BGM 設備： 主攝影：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： BGM：LAKEY INSPIRED - Chill Day 相關連結 影片🎬：下方請收看 👇 ","date":"2021-08-09","objectID":"/painting/:0:0","tags":["油畫","旅遊","YouTube"],"title":"【數字油畫 - 偷看貓 【番外篇】花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/painting/"},{"categories":["youtube"],"content":"跟老爸老弟騎機車去巨人之手💖 設備/剪輯/BGM 設備： 主攝影：GoPro 7 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Adobe Premiere Pro 照片後製： Canva BGM： Jarico Island Vlog No Copyright Music Markvard Desire Vlog No Copyright Music 相關連結 影片🎬：下方請收看 👇 ","date":"2021-02-05","objectID":"/giant-hand/:0:0","tags":["機車","旅遊","YouTube"],"title":"【巨人之手】 家庭機車出遊VLOG","uri":"/giant-hand/"},{"categories":["documentation"],"content":"FeelIt 主題在 Hugo 內置的 shortcode 的基礎上提供多個擴展的 shortcode.","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"FeelIt 主題在 Hugo 內置的 shortcode 的基礎上提供多個擴展的 shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意 Hugo extended 版本對於 style shortcode 是必需的. style shortcode 用來在你的文章中插入自定義樣式. style shortcode 有兩個位置參數. 第一個參數是自定義樣式的內容. 它支持  SASS 中的嵌套語法, 並且 \u0026 指代這個父元素. 第二個參數是包裹你要更改樣式的內容的 HTML 標簽, 默認值是 div. 一個 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈現的輸出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 鏈接語法 的替代. link shortcode 可以提供一些其它的功能並且可以在代碼塊中使用. 支持本地資源引用的完整用法. link shortcode 有以下命名參數: href [必需] (第一個位置參數) 鏈接的目標. content [可選] (第二個位置參數) 鏈接的內容, 默認值是 href 參數的值. 支持 Markdown 或者 HTML 格式. title [可選] (第三個位置參數) HTML a 標簽 的 title 屬性, 當懸停在鏈接上會顯示的提示. rel [可選] HTML a 標簽 的 rel 補充屬性. class [可選] HTML a 標簽 的 class 屬性. 一個 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈現的輸出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一個帶有標題的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈現的輸出效果如下 (將鼠標懸停在鏈接上，會有一行提示): Upstage ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 兩個依賴庫. 支持本地資源引用的完整用法. image shortcode 有以下命名參數: src [必需] (第一個位置參數) 圖片的 URL. alt [可選] (第二個位置參數) 圖片無法顯示時的替代文本, 默認值是 src 參數的值. 支持 Markdown 或者 HTML 格式. caption [可選] (第三個位置參數) 圖片標題. 支持 Markdown 或者 HTML 格式. title [可選] 當懸停在圖片上會顯示的提示. class [可選] HTML figure 標簽的 class 屬性. src_s [可選] 圖片縮略圖的 URL, 用在畫廊模式中, 默認值是 src 參數的值. src_l [可選] 高清圖片的 URL, 用在畫廊模式中, 默認值是 src 參數的值. height [可選] 圖片的 height 屬性. width [可選] 圖片的 width 屬性. linked [可選] 圖片是否需要被鏈接, 默認值是 true. rel [可選] HTML a 標簽 的 rel 補充屬性, 僅在 linked 屬性設置成 true 時有效. 一個 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈現的輸出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 種 幫助你在頁面中插入提示的橫幅. 支持 Markdown 或者 HTML 格式. 注意 一個 注意 橫幅 摘要 一個 摘要 橫幅 信息 一個 信息 橫幅 技巧 一個 技巧 橫幅 成功 一個 成功 橫幅 問題 一個 問題 橫幅 警告 一個 警告 橫幅 失敗 一個 失敗 橫幅 危險 一個 危險 橫幅 Bug 一個 Bug 橫幅 示例 一個 示例 橫幅 引用 一個 引用 橫幅 admonition shortcode 有以下命名參數: type [必需] (第一個位置參數) admonition 橫幅的類型, 默認值是 note. title [可選] (第二個位置參數) admonition 橫幅的標題, 默認值是 type 參數的值. open [可選] (第三個位置參數) 橫幅內容是否默認展開, 默認值是 true. 一個 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一個 **技巧** 橫幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一個 **技巧** 橫幅 {{\u003c /admonition \u003e}} 呈現的輸出效果如下: This is a tip 一個 技巧 橫幅 ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一個可以幫助你在文章中生成圖表和流程圖的庫, 類似 Markdown 的語法. 只需將你的 mermaid 代碼插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程圖 一個 流程圖 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 時序圖 一個 時序圖 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特圖 一個 甘特圖 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 類圖 一個 類圖 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 狀態圖 一個 狀態圖 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 圖 一個 Git 圖 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 實體關系圖 一個 erDiagram mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.8 用戶旅程圖 一個 旅行 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:8","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.9 餅圖 一個 餅圖 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:9","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一個幫助你生成交互式數據可視化的庫. ECharts 提供了常規的 折線圖, 柱狀圖, 散點圖, 餅圖, K線圖, 用於統計的 盒形圖, 用於地理數據可視化的 地圖, 熱力圖, 線圖, 用於關系數據可視化的 關系圖, treemap, 旭日圖, 多維數據可視化的 平行坐標, 還有用於 BI 的 漏鬥圖, 儀表盤, 並且支持圖與圖之間的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 選項即可. 一個 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折線統計圖\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"郵件營銷\", \"聯盟廣告\", \"視頻廣告\", \"直接訪問\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存為圖片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"郵件營銷\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"聯盟廣告\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"視頻廣告\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接訪問\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一個 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折線統計圖top:2%left:centertooltip:trigger:axislegend:data:- 郵件營銷- 聯盟廣告- 視頻廣告- 直接訪問- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存為圖片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:郵件營銷type:linestack:總量data:- 120- 132- 101- 134- 90- 230- 210- name:聯盟廣告type:linestack:總量data:- 220- 182- 191- 234- 290- 330- 310- name:視頻廣告type:linestack:總量data:- 150- 232- 201- 154- 190- 330- 410- name:直接訪問type:linestack:總量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:總量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一個 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折線統計圖\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"郵件營銷\", \"聯盟廣告\", \"視頻廣告\", \"直接訪問\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存為圖片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"郵件營銷\" type = \"line\" stack = \"總量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"聯盟廣告\" type = \"line\" stack = \"總量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"視頻廣告\" type = \"line\" stack = \"總量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接訪問\" type = \"line\" stack = \"總量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"總量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈現的輸出效果如下: echarts shortcode 還有以下命名參數: width [可選] (第一個位置參數) 數據可視化的寬度, 默認值是 100%. height [可選] (第二個位置參數) 數據可視化的高度, 默認值是 30rem. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一個 JavaScript 庫，它使用 WebGL, 以 vector tiles 和 Mapbox styles 為來源, 將它們渲染成互動式地圖. mapbox shortcode 有以下命名參數來使用 Mapbox GL JS: lng [必需] (第一個位置參數) 地圖初始中心點的經度, 以度為單位. lat [必需] (第二個位置參數) 地圖初始中心點的緯度, 以度為單位. zoom [可選] (第三個位置參數) 地圖的初始縮放級別, 默認值是 10. marked [可選] (第四個位置參數) 是否在地圖的初始中心點添加圖釘, 默認值是 true. light-style [可選] (第五個位置參數) 淺色主題的地圖樣式, 默認值是前置參數或者網站配置中設置的值. dark-style [可選] (第六個位置參數) 深色主題的地圖樣式, 默認值是前置參數或者網站配置中設置的值. navigation [可選] 是否添加 NavigationControl, 默認值是前置參數或者網站配置中設置的值. geolocate [可選] 是否添加 GeolocateControl, 默認值是前置參數或者網站配置中設置的值. scale [可選] 是否添加 ScaleControl, 默認值是前置參數或者網站配置中設置的值. fullscreen [可選] 是否添加 FullscreenControl, 默認值是前置參數或者網站配置中設置的值. width [可選] 地圖的寬度, 默認值是 100%. height [可選] 地圖的高度, 默認值是 20rem. 一個簡單的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈現的輸出效果如下: 一個帶有自定義樣式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基於 APlayer 和 MetingJS 提供了一個內嵌的響應式音樂播放器. 有三種方式使用 music shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定義音樂 URL 支持本地資源引用的完整用法. music shortcode 有以下命名參數來使用自定義音樂 URL: server [必需] 音樂的鏈接. type [可選] 音樂的名稱. artist [可選] 音樂的創作者. cover [可選] 音樂的封面鏈接. 一個使用自定義音樂 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音樂平台 URL 的自動識別 music shortcode 有一個命名參數來使用音樂平台 URL 的自動識別: auto [必需]] (第一個位置參數) 用來自動識別的音樂平台 URL, 支持 netease, tencent 和 xiami 平台. 一個使用音樂平台 URL 的自動識別的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定義音樂平台, 類型和 ID music shortcode 有以下命名參數來使用自定義音樂平台: server [必需] (第一個位置參數) [netease, tencent, kugou, xiami, baidu] 音樂平台. type [必需] (第二個位置參數) [song, playlist, album, search, artist] 音樂類型. id [必需] (第三個位置參數) 歌曲 ID, 或者播放列表 ID, 或者專輯 ID, 或者搜索關鍵詞, 或者創作者 ID. 一個使用自定義音樂平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它參數 music shortcode 有一些可以應用於以上三種方式的其它命名參數: theme [可選] 音樂播放器的主題色, 默認值是 #448aff. fixed [可選] 是否開啟固定模式, 默認值是 false. mini [可選] 是否開啟迷你模式, 默認值是 false. autoplay [可選] 是否自動播放音樂, 默認值是 false. volume [可選] 第一次打開播放器時的默認音量, 會被保存在瀏覽器緩存中, 默認值是 0.7. mutex [可選] 是否自動暫停其它播放器, 默認值是 true. music shortcode 還有一些只適用於音樂列表方式的其它命名參數: loop [可選] [all, one, none] 音樂列表的循環模式, 默認值是 none. order [可選] [list, random] 音樂列表的播放順序, 默認值是 list. list-folded [可選] 初次打開的時候音樂列表是否折疊, 默認值是 false. list-max-height [可選] 音樂列表的最大高度, 默認值是 340px. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一個內嵌的用來播放 bilibili 視頻的響應式播放器. 如果視頻只有一個部分, 則僅需要視頻的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一個 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈現的輸出效果如下: 如果視頻包含多個部分, 則除了視頻的 BV id 之外, 還需要 p, 默認值為 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一個帶有 p 參數的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基於 TypeIt 提供了打字動畫. 只需將你需要打字動畫的內容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 簡單內容 允許使用 Markdown 格式的簡單內容, 並且 不包含 富文本的塊內容, 例如圖像等等… 一個 typeit 示例: {{\u003c typeit \u003e}} 這一個帶有基於 [TypeIt](https://typeitjs.com/) 的 **打字動畫** 的 *段落*... {{\u003c /typeit \u003e}} 呈現的輸出效果如下: 另外, 你也可以自定義 HTML 標簽. 一個帶有 h4 標簽的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 這一個帶有基於 [TypeIt](https://typeitjs.com/) 的 **打字動畫** 的 *段落*... {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代碼內容 代碼內容也是允許的, 並且通過使用參數 code 指定語言類型可以實習語法高亮. 一個帶有 code 參數的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分組內容 默認情況下, 所有打字動畫都是同時開始的. 但是有時你可能需要按順序開始一組 typeit 內容的打字動畫. 一組具有相同 group 參數值的 typeit 內容將按順序開始打字動畫. 一個帶有 group 參數的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 這個段落開始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然後**, 這個段落開始 {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用來在你的文章中插入  Javascript 腳本. 注意 腳本內容可以保證在所有的第三方庫加載之後按順序執行. 所以你可以自由地使用第三方庫. 一個 script 示例: {{\u003c script \u003e}} console.log('Hello FeelIt!'); {{\u003c /script \u003e}} 你可以在開發者工具的控制台中看到輸出. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12 oEmbed oEmbed endpoints allow you to get embed HTML and basic metadata for pages, posts, and videos in order to display them in another website or app. The oEmbed endpoints require either an App Access Token or Client Access Token. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.1 oEmbed Facebook a. oEmbed Facebook Pages Sample input of Facebook Pages {{\u003c oembed \"fb\" \"page\" \"https://www.facebook.com/FacebookforDevelopers\" \u003e}} Sample output of Facebook Pages URL Formats https://www.facebook.com/{page-name} https://www.facebook.com/{page-id} b. oEmbed Facebook Posts Sample input of Facebook Posts {{\u003c oembed \"fb\" \"post\" \"https://www.facebook.com/FacebookforDevelopers/photos/a.441861428552/10151617410093553\" \u003e}} Sample output of Facebook Posts URL Formats https://www.facebook.com/{page-name}/posts/{post-id} https://www.facebook.com/{username}/posts/{post-id} https://www.facebook.com/{username}/activity/{activity-id} https://www.facebook.com/photo.php?fbid={photo-id} https://www.facebook.com/photos/{photo-id} https://www.facebook.com/permalink.php?story_fbid={post-id}\u0026id={page-or-user-id} https://www.facebook.com/media/set?set={set-id} https://www.facebook.com/questions/{question-id} https://www.facebook.com/notes/{username}/{note-url}/{note-id} c. oEmbed Facebook Videos Sample input of Facebook Videos {{\u003c oembed \"fb\" \"video\" \"https://www.facebook.com/FacebookforDevelopers/videos/2201055573317594\" \u003e}} Sample output of Facebook Videos URL Formats https://www.facebook.com/{page-name}/videos/{video-id}/ https://www.facebook.com/{username}/videos/{video-id}/ https://www.facebook.com/video.php?id={video-id} https://www.facebook.com/video.php?v={video-id} ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.2 oEmbed Instagram a. oEmbed Instagram Post Sample input of Instagram Post {{\u003c oembed \"ig\" \"p\" \"BWNjjyYFxVx\" \"hidecaption\" \u003e}} Sample output of Instagram Post b. oEmbed Instagram TV Sample input of Instagram TV {{\u003c oembed \"ig\" \"tv\" \"BkQUbR8h1sp\" \"hidecaption\" \u003e}} Sample output of Instagram TV ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.3 oEmbed Twitter Sample input of ‘oembed tweet’ {{\u003c oembed \"tweet\" \"https://twitter.com/GoHugoIO/status/877500564405444608\" \u003e}} Sample output of ‘oembed tweet’ Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"這篇文章展示了基本的 Markdown 語法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"這篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 語法示例. 注意 這篇文章借鑒了一篇很棒的來自 Grav 的文章. 如果你想了解 FeelIt 主題的擴展 Markdown 語法, 請閱讀擴展 Markdown 語法頁面. 事實上, 編寫 Web 內容很麻煩. WYSIWYG所見即所得 編輯器幫助減輕了這一任務. 但通常會導致代碼太糟, 或更糟糕的是, 網頁也會很醜. 沒有通常伴隨的所有覆雜和醜陋的問題, Markdown 是一種更好的生成 HTML 內容的方式. 一些主要好處是: Markdown 簡單易學, 幾乎沒有多余的字符, 因此編寫內容也更快. 用 Markdown 書寫時出錯的機會更少. 可以產生有效的 XHTML 輸出. 將內容和視覺顯示保持分開, 這樣就不會打亂網站的外觀. 可以在你喜歡的任何文本編輯器或 Markdown 應用程序中編寫內容. Markdown 使用起來很有趣! John Gruber, Markdown 的作者如是說: Markdown 格式的首要設計目標是更具可讀性. 最初的想法是 Markdown 格式的文檔應當以純文本形式發布, 而不會看起來像被標簽或格式說明所標記. 雖然 Markdown 的語法受到幾種現有的文本到 HTML 轉換工具的影響, 但 Markdown 語法的最大靈感來源是純文本電子郵件的格式. – John Gruber 話不多說, 我們來回顧一下 Markdown 的主要語法以及生成的 HTML 樣式! 技巧  將此頁保存為書簽，以備將來參考! ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"1 標題 從 h2 到 h6 的標題在每個級別上都加上一個 ＃: ## h2 標題 ### h3 標題 #### h4 標題 ##### h5 標題 ###### h6 標題 輸出的 HTML 看起來像這樣: \u003ch2\u003eh2 標題\u003c/h2\u003e \u003ch3\u003eh3 標題\u003c/h3\u003e \u003ch4\u003eh4 標題\u003c/h4\u003e \u003ch5\u003eh5 標題\u003c/h5\u003e \u003ch6\u003eh6 標題\u003c/h6\u003e 標題 ID 要添加自定義標題 ID, 請在與標題相同的行中將自定義 ID 放在花括號中: ### 一個很棒的標題 {#custom-id} 輸出的 HTML 看起來像這樣: \u003ch3 id=\"custom-id\"\u003e一個很棒的標題\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"2 注釋 注釋是和 HTML 兼容的： \u003c!-- 這是一段注釋 --\u003e 不能看到以下的注釋: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"3 水平線 HTML 中的 \u003chr\u003e 標簽是用來在段落元素之間創建一個 “專題間隔” 的. 使用 Markdown, 你可以用以下方式創建一個 \u003chr\u003e 標簽: ___: 三個連續的下劃線 ---: 三個連續的破折號 ***: 三個連續的星號 呈現的輸出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"4 段落 按照純文本的方式書寫段落, 純文本在呈現的 HTML 中將用 \u003cp\u003e/\u003c/p\u003e 標簽包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 輸出的 HTML 看起來像這樣: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一個空白行進行換行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"5 內聯 HTML 元素 如果你需要某個 HTML 標簽 (帶有一個類), 則可以簡單地像這樣使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 這是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"6 強調 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"加粗 用於強調帶有較粗字體的文本片段. 以下文本片段會被 渲染為粗體. **渲染為粗體** __渲染為粗體__ 輸出的 HTML 看起來像這樣: \u003cstrong\u003e渲染為粗體\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"斜體 用於強調帶有斜體的文本片段. 以下文本片段被 渲染為斜體. *渲染為斜體* _渲染為斜體_ 輸出的 HTML 看起來像這樣: \u003cem\u003e渲染為斜體\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"刪除線 按照 GFMGitHub flavored Markdown 你可以使用刪除線. ~~這段文本帶有刪除線.~~ 呈現的輸出效果如下: 這段文本帶有刪除線. 輸出的 HTML 看起來像這樣: \u003cdel\u003e這段文本帶有刪除線.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"組合 加粗, 斜體, 和刪除線可以 組合使用. ***加粗和斜體*** ~~**刪除線和加粗**~~ ~~*刪除線和斜體*~~ ~~***加粗, 斜體和刪除線***~~ 呈現的輸出效果如下: 加粗和斜體 刪除線和加粗 刪除線和斜體 加粗, 斜體和刪除線 輸出的 HTML 看起來像這樣: \u003cem\u003e\u003cstrong\u003e加粗和斜體\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e刪除線和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e刪除線和斜體\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜體和刪除線\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"7 引用 用於在文檔中引用其他來源的內容塊. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈現的輸出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 輸出的 HTML 看起來像這樣: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈現的輸出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"無序列表 一系列項的列表, 其中項的順序沒有明顯關系. 你可以使用以下任何符號來表示無序列表中的項: * 一項內容 - 一項內容 + 一項內容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 輸出的 HTML 看起來像這樣: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"有序列表 一系列項的列表, 其中項的順序確實很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 輸出的 HTML 看起來像這樣: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你對每一項使用 1., Markdown 將自動為每一項編號. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"任務列表 任務列表使你可以創建帶有覆選框的列表. 要創建任務列表, 請在任務列表項之前添加破折號 (-) 和帶有空格的方括號 ([ ]). 要選擇一個覆選框，請在方括號之間添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈現的輸出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"9 代碼 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"行內代碼 用 ` 包裝行內代碼段. 在這個例子中, `\u003csection\u003e\u003c/section\u003e` 會被包裹成 **代碼**. 呈現的輸出效果如下: 在這個例子中, \u003csection\u003e\u003c/section\u003e 會被包裹成 代碼. 輸出的 HTML 看起來像這樣: \u003cp\u003e 在這個例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 會被包裹成 \u003cstrong\u003e代碼\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"縮進代碼 將幾行代碼縮進至少四個空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈現的輸出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 輸出的 HTML 看起來像這樣: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"圍欄代碼塊 使用 “圍欄” ``` 來生成一段帶有語言屬性的代碼塊. ```markdown Sample text here... ``` 輸出的 HTML 看起來像這樣: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"語法高亮 GFMGitHub Flavored Markdown 也支持語法高亮. 要激活它，只需在第一個代碼 “圍欄” 之後直接添加你要使用的語言的文件擴展名, ```js, 語法高亮顯示將自動應用於渲染的 HTML 中. 例如, 在以下 JavaScript 代碼中應用語法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈現的輸出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文檔中的 語法高亮頁面 介紹了有關語法高亮的更多信息, 包括語法高亮的 shortcode. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"10 表格 通過在每個單元格之間添加豎線作為分隔線, 並在標題下添加一行破折號 (也由豎線分隔) 來創建表格. 注意, 豎線不需要垂直對齊. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈現的輸出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 輸出的 HTML 看起來像這樣: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右對齊或居中對齊 在任何標題下方的破折號右側添加冒號將使該列的文本右對齊. 在任何標題下方的破折號兩邊添加冒號將使該列的對齊文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈現的輸出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"11 鏈接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"基本鏈接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈現的輸出效果如下 (將鼠標懸停在鏈接上，沒有提示): https://assemble.io contact@revolunet.com Assemble 輸出的 HTML 看起來像這樣: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"添加一個標題 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈現的輸出效果如下 (將鼠標懸停在鏈接上，會有一行提示): Upstage 輸出的 HTML 看起來像這樣: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"定位標記 定位標記使你可以跳至同一頁面上的指定錨點. 例如, 每個章節: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 將跳轉到這些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位標記的位置幾乎是任意的. 因為它們並不引人注目, 所以它們通常被放在同一行了. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"12 腳注 腳注使你可以添加注釋和參考, 而不會使文檔正文混亂. 當你創建腳注時, 會在添加腳注引用的位置出現帶有鏈接的上標編號. 讀者可以單擊鏈接以跳至頁面底部的腳注內容. 要創建腳注引用, 請在方括號中添加插入符號和標識符 ([^1]). 標識符可以是數字或單詞, 但不能包含空格或制表符. 標識符僅將腳注引用與腳注本身相關聯 - 在腳注輸出中, 腳注按順序編號. 在中括號內使用插入符號和數字以及用冒號和文本來添加腳注內容 ([^1]：這是一段腳注). 你不一定要在文檔末尾添加腳注. 可以將它們放在除列表, 引用和表格等元素之外的任何位置. 這是一個數字腳注[^1]. 這是一個帶標簽的腳注[^label] [^1]: 這是一個數字腳注 [^label]: 這是一個帶標簽的腳注 這是一個數字腳注1. 這是一個帶標簽的腳注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"13 圖片 圖片的語法與鏈接相似, 但包含一個在前面的感嘆號. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像鏈接一樣, 圖片也具有腳注樣式的語法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍後在文檔中提供參考內容, 用來定義 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 FeelIt 主題提供了一個包含更多功能的 圖片的 shortcode. 這是一個數字腳注 ↩︎ 這是一個帶標簽的腳注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"Hugo 和 FeelIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"Emoji 可以通過多種方式在 Hugo 項目中啟用. emojify 方法可以直接在模板中調用, 或者使用行內 Shortcodes. 要全局使用 emoji, 需要在你的網站配置中設置 enableEmoji 為 true, 然後你就可以直接在文章中輸入 emoji 的代碼. 它們以冒號開頭和結尾，並且包含 emoji 的 代碼: 去露營啦! :tent: 很快就回來. 真開心! :joy: 呈現的輸出效果如下: 去露營啦! ⛺ 很快就回來. 真開心! 😂 以下符號清單是 emoji 代碼的非常有用的參考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"表情與情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"笑臉表情 圖標 代碼 圖標 代碼 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"愛意表情 圖標 代碼 圖標 代碼 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"吐舌頭表情 圖標 代碼 圖標 代碼 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"帶手的表情 圖標 代碼 圖標 代碼 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"中性表情 圖標 代碼 圖標 代碼 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"困倦的表情 圖標 代碼 圖標 代碼 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"不適的表情 圖標 代碼 圖標 代碼 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"戴帽子的表情 圖標 代碼 圖標 代碼 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"戴眼鏡的表情 圖標 代碼 圖標 代碼 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"擔心的表情 圖標 代碼 圖標 代碼 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"否定的表情 圖標 代碼 圖標 代碼 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"特殊打扮的表情 圖標 代碼 圖標 代碼 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"貓臉表情 圖標 代碼 圖標 代碼 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"猴臉表情 圖標 代碼 圖標 代碼 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"情感 圖標 代碼 圖標 代碼 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人與身體 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"張開手掌的手勢 圖標 代碼 圖標 代碼 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"部分手指的手勢 圖標 代碼 圖標 代碼 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"一根手指的手勢 圖標 代碼 圖標 代碼 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"握緊的手勢 圖標 代碼 圖標 代碼 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"兩只手 圖標 代碼 圖標 代碼 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"握住東西的手勢 圖標 代碼 圖標 代碼 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"身體部位 圖標 代碼 圖標 代碼 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人 圖標 代碼 圖標 代碼 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"身體動作 圖標 代碼 圖標 代碼 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物角色 圖標 代碼 圖標 代碼 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"幻想的人物 圖標 代碼 圖標 代碼 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物活動 圖標 代碼 圖標 代碼 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"體育 圖標 代碼 圖標 代碼 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"休息 圖標 代碼 圖標 代碼 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"家庭 圖標 代碼 圖標 代碼 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物符號 圖標 代碼 圖標 代碼 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"動物與自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"哺乳動物 圖標 代碼 圖標 代碼 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"鳥類 圖標 代碼 圖標 代碼 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"兩棲動物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"爬蟲類 圖標 代碼 圖標 代碼 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"海洋動物 圖標 代碼 圖標 代碼 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"蟲類 圖標 代碼 圖標 代碼 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"花類植物 圖標 代碼 圖標 代碼 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它植物 圖標 代碼 圖標 代碼 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"食物與飲料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"水果 圖標 代碼 圖標 代碼 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"蔬菜 圖標 代碼 圖標 代碼 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"快餐 圖標 代碼 圖標 代碼 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"亞洲食物 圖標 代碼 圖標 代碼 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"海鮮 圖標 代碼 圖標 代碼 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"甜點 圖標 代碼 圖標 代碼 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"飲料 圖標 代碼 圖標 代碼 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"餐具 圖標 代碼 圖標 代碼 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旅遊與地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"地圖 圖標 代碼 圖標 代碼 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"地理現象 圖標 代碼 圖標 代碼 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"建築物 圖標 代碼 圖標 代碼 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"宗教建築 圖標 代碼 圖標 代碼 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它地點 圖標 代碼 圖標 代碼 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"陸路運輸 圖標 代碼 圖標 代碼 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"水路運輸 圖標 代碼 圖標 代碼 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"空中運輸 圖標 代碼 圖標 代碼 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旅館 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"時間 圖標 代碼 圖標 代碼 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"天空與天氣 圖標 代碼 圖標 代碼 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"活動 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"事件 圖標 代碼 圖標 代碼 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"獎杯與獎牌 圖標 代碼 圖標 代碼 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"體育運動 圖標 代碼 圖標 代碼 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"遊戲 圖標 代碼 圖標 代碼 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"藝術與工藝 圖標 代碼 圖標 代碼 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"服裝 圖標 代碼 圖標 代碼 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"聲音 圖標 代碼 圖標 代碼 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"音樂 圖標 代碼 圖標 代碼 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"樂器 圖標 代碼 圖標 代碼 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"電話 圖標 代碼 圖標 代碼 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"電腦 圖標 代碼 圖標 代碼 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"燈光與影像 圖標 代碼 圖標 代碼 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"書與紙張 圖標 代碼 圖標 代碼 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"錢 圖標 代碼 圖標 代碼 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"郵件 圖標 代碼 圖標 代碼 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"書寫 圖標 代碼 圖標 代碼 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"辦公 圖標 代碼 圖標 代碼 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"鎖 圖標 代碼 圖標 代碼 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"工具 圖標 代碼 圖標 代碼 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"科學 圖標 代碼 圖標 代碼 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"醫療 圖標 代碼 圖標 代碼 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"生活用品 圖標 代碼 圖標 代碼 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它物品 圖標 代碼 圖標 代碼 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"符號 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"交通標識 圖標 代碼 圖標 代碼 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"警告 圖標 代碼 圖標 代碼 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"箭頭 圖標 代碼 圖標 代碼 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"宗教 圖標 代碼 圖標 代碼 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"生肖 圖標 代碼 圖標 代碼 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"影像符號 圖標 代碼 圖標 代碼 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"數學 圖標 代碼 圖標 代碼 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"標點符號 圖標 代碼 圖標 代碼 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"貨幣 圖標 代碼 圖標 代碼 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"按鍵符號 圖標 代碼 圖標 代碼 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"字母符號 圖標 代碼 圖標 代碼 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"幾何符號 圖標 代碼 圖標 代碼 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它符合 圖標 代碼 圖標 代碼 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旗幟 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"常用旗幟 圖標 代碼 圖標 代碼 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"國家和地區旗幟 圖標 代碼 圖標 代碼 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":null,"content":"經驗 ","date":"2022-02-19","objectID":"/about/:1:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"簡疫聊天室 參與GDSC聯合黑客松比賽 2021/05/14 - 2021/05/16  利用PWA支援各式裝置的特性以及GPS定位功能打造屬於疫情期間的專屬聊天室。 背景介紹 在疫情嚴峻下，為了保護國民健康，實施居家隔離，一個人居家隔離14天，難免會感到寂寞與無聊， 因此透過黑客松比賽，與團隊共同開發網頁聊天室，不需要下載就可以使用， 並且使用PWA支援各式裝置，配合GPS定位功能，讓使用者可以與附近的居家隔離者聊天， 當系統偵測到使用者離開定位區或是14天居家隔離到期，帳號將會被註銷，讓記憶永遠留在這裡。  從16組 Google 學生開發者社群中榮獲 第二名 成績。  只花了 三天 的時間從零到開發聊天室前後端以及宣傳影片。 簡疫聊天室首頁\" 簡疫聊天室首頁 ","date":"2022-02-19","objectID":"/about/:1:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"活動申請系統 承包學校專案 2020/08 - 至今  利用PHP+Mysql+jQuery 開發線上填單系統，並且結合線上審核功能，串接Google日曆API、線上電子章產生。 背景介紹 協助學校開發活動申請系統，將以往的紙本送單，改成線上電子化，可以先於線上進行審核，減少紙張浪費，並且可以妥善保存歷屆活動紀錄，不會交接完資料遺失。   Google Analytics 當⽉最高活躍使用者數量：967 瀏覽量：40671。   原先紙本申請的 5天 工作流程，因活動申請系統電子化後減少到 1天，縮短了80% 的活動申請流程時間。 活動申請系統管理員介面\" 活動申請系統管理員介面 ","date":"2022-02-19","objectID":"/about/:1:2","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"證照 ","date":"2022-02-19","objectID":"/about/:2:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"RED HAT CERTIFIED ENGINEER (RHCE) 紅帽認證工程師 2019/07/05  熟悉設定NFS-Server/Client、Samba-Server/Client、ISCSI-Server/Client、Apache-Server、Database。  客製化bash參數、FireWall-SSH/Port Forwarding、啟用IPv6、Link aggrigation、Mail-Server、YUM Repo。 RHCE介紹 RHCE即是Red Hat 認證系統工程師，透過嚴謹的「Performance Base」實機操作考試方式，可以證明取得認證者擁有真正的專業技術實力。 RHCE證照\" RHCE證照 ","date":"2022-02-19","objectID":"/about/:2:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"RED HAT CERTIFIED SYSTEM ADMINISTRATOR (RHCSA) 紅帽初級認證 2019/01/11  熟悉重設Root密碼、設定網路、設定SELinux、設定時區、YUM Repository。  LVM、權限管理、Crontab、建立目錄及權限、更新Kernel、LDAP、文件處理。 RHCSA介紹 擁有RHCSA認證者能夠扮演著企業內各式各樣的角色，舉凡資料庫管理員，開發人員和技術支持人員…等職務，能重建與部署企業核心Linux環境，更能代表您具備管理技術與駕馭系統的能力。 RHCSA證照\" RHCSA證照 ","date":"2022-02-19","objectID":"/about/:2:2","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"教育 ","date":"2022-02-19","objectID":"/about/:3:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"朝陽科技大學 資訊工程系(CSIE) 2017 - 2021  系排第一畢業。  被學校邀請擔任過系統講師。  發現學校DNS安全漏洞，並開發腳本找出漏洞。 ","date":"2022-02-19","objectID":"/about/:3:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"新民高級中學 資訊科 2014 - 2017 ","date":"2022-02-19","objectID":"/about/:3:2","tags":null,"title":"關於我","uri":"/about/"}]