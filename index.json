[{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主題的全部內容和背後的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - FeelIt 主題的全部內容和背後的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 準備 由於 Hugo 提供的便利性, Hugo 本身是這個主題唯一的依賴. 直接安裝滿足你操作系統 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.84.0). 為什麽不支持早期版本的 Hugo? 由於 Markdown 渲染鉤子函數 在 Hugo 聖誕節版本 中被引入 一些圖像資源使用的是0.84.0中引入的webp, 本主題只支持高於 0.84.0 的 Hugo 版本. 推薦使用 Hugo extended 版本 由於這個主題的一些特性需要將  SCSS 轉換為  CSS, 推薦使用 Hugo extended 版本來獲得更好的使用體驗. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安裝 以下步驟可幫助你初始化新網站. 如果你根本不了解 Hugo, 我們強烈建議你按照此 快速入門文檔 進一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 創建你的項目 Hugo 提供了一個 new 命令來創建一個新的網站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安裝主題 FeelIt 主題的倉庫是: https://github.com/khusika/FeelIt. 你可以下載主題的 最新版本  .zip 文件 並且解壓放到 themes 目錄. 另外, 也可以直接把這個主題克隆到 themes 目錄: git clone https://github.com/khusika/FeelIt.git themes/FeelIt 或者, 初始化你的項目目錄為 git 倉庫, 並且把主題倉庫作為你的網站目錄的子模塊: git init git submodule add https://github.com/khusika/FeelIt.git themes/FeelIt ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基礎配置 以下是 FeelIt 主題的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 設置默認的語言 defaultContentLanguage = \"zh-cn\" # 網站語言, 僅在這里 CN 大寫 languageCode = \"zh-CN\" # 是否包括中日韓文字 hasCJKLanguage = true # 網站標題 title = \"我的全新 Hugo 網站\" # 更改使用 Hugo 構建網站時使用的默認主題 theme = \"FeelIt\" [params] # FeelIt 主題版本 version = \"1.0.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名稱 (允許 HTML 格式) 之前添加其他信息, 例如圖標 pre = \"\" # 你可以在名稱 (允許 HTML 格式) 之後添加其他信息, 例如圖標 post = \"\" name = \"文章\" url = \"/posts/\" # 當你將鼠標懸停在此菜單鏈接上時, 將顯示的標題 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"標簽\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分類\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文檔的配置 [markup] # 語法高亮設置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的設置 (https://github.com/khusika/FeelIt/issues/158) noClasses = false 注意 在構建網站時, 你可以使用 --theme 選項設置主題. 但是, 我建議你修改配置文件 (config.toml) 將本主題設置為默認主題. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 創建你的第一篇文章 以下是創建第一篇文章的方法: hugo new posts/first_post.md 通過添加一些示例內容並替換文件開頭的標題, 你可以隨意編輯文章. 注意 默認情況下, 所有文章和頁面均作為草稿創建. 如果想要渲染這些頁面, 請從元數據中刪除屬性 draft: true, 設置屬性 draft: false 或者為 hugo 命令添加 -D/--buildDrafts 參數. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地啟動網站 使用以下命令啟動網站: hugo serve 去查看 http://localhost:1313. 基本配置下的預覽基本配置下的預覽 \" 基本配置下的預覽 技巧 當你運行 hugo serve 時, 當文件內容更改時, 頁面會隨著更改自動刷新. 注意 由於本主題使用了 Hugo 中的 .Scratch 來實現一些特性, 非常建議你為 hugo server 命令添加 --disableFastRender 參數來實時預覽你正在編輯的文章頁面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 構建網站 當你準備好部署你的網站時, 運行以下命令: hugo 會生成一個 public 目錄, 其中包含你網站的所有靜態內容和資源. 現在可以將其部署在任何 Web 服務器上. 技巧 網站內容可以通過 Netlify 自動發布和托管 (了解有關通過 Netlify 進行 HUGO 自動化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 網站配置 除了 Hugo 全局配置 和 菜單配置 之外, FeelIt 主題還允許您在網站配置中定義以下參數 (這是一個示例 config.toml, 其內容為默認值). 請打開下面的代碼塊查看完整的示例配置 : [params] # FeelIt 主題版本 version = \"1.0.X\" # 網站描述 description = \"這是我的全新 Hugo 網站\" # 網站關鍵詞 keywords = [\"Theme\", \"Hugo\"] # 網站默認主題樣式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 倉庫路徑，僅在 enableGitInfo 設為 true 時有效 gitRepo = \"\" # 哪種哈希函數用來 SRI, 為空時表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 網站圖片, 用於 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 是否啟用 CSS 和 JS 源映射 SourceMap = true # PWA config [params.pwa] # whether to enable PWA support enable = true # service-worker version version = \"1.0.1\" # 應用圖標配置 [params.app] # 當添加到 iOS 主屏幕或者 Android 啟動器時的標題, 覆蓋默認標題 title = \"FeelIt\" # 是否隱藏網站圖標資源鏈接 noFavicon = false # 更現代的 SVG 網站圖標, 可替代舊的 .png 和 .ico 文件 svgFavicon = \"\" # Android 瀏覽器主題色 themeColor = \"#ffffff\" # Safari 圖標顏色 iconColor = \"#5bbad5\" # Windows v8-10磁貼顏色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的類型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章內容最長索引長度 contentLength = 4000 # 搜索框的占位提示語 placeholder = \"\" # 最大結果數目 maxResultLength = 10 # 結果內容片段長度 snippetLength = 50 # 搜索結果中高亮部分的 HTML 標簽 highlightTag = \"em\" # 是否在搜索索引中使用基於 baseURL 的絕對路徑 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 頁面頭部導航欄配置 [params.header] # 桌面端導航欄模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移動端導航欄模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 頁面頭部導航欄標題配置 [params.header.title] # LOGO 的 URL logo = \"\" # 標題名稱 name = \"\" # 你可以在名稱 (允許 HTML 格式) 之前添加其他信息, 例如圖標 pre = \"\" # 你可以在名稱 (允許 HTML 格式) 之後添加其他信息, 例如圖標 post = \"\" # 是否為標題顯示打字機動畫 typeit = false # 是否顯示RSS圖標 rss = true # 頁面底部信息配置 [params.footer] enable = true # 自定義內容 (支持 HTML 格式) custom = '' # 是否顯示 Hugo 和主題信息 hugo = true # 是否顯示版權信息 copyright = true # 是否顯示作者 author = true # 網站創立年份 since = 2019 # ICP 備案信息，僅在中國使用 (支持 HTML 格式) icp = \"\" # 許可協議信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 頁面配置 [params.section] # section 頁面每頁顯示文章數量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章數目 rss = 10 # List (目錄或標簽) 頁面配置 [params.list] # list 頁面每頁顯示文章數量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章數目 rss = 10 # # 關於頁面配置 [params.about] # 是否啟用關於頁面的配置文件 # 依賴於取決於 .Site.Params.home.profile.enable enable = true # 是否啟用參數布局 param = true # 參數布局的標題 paramTitle = \"個人信息\" # 您網站的一般描述 # 可以用markdown樣式寫 description = \"[FeelIt](https://github.com/khusika/FeelIt) 是一個由 [Khusika](https://khusika.com) 開發的**簡潔**、**優雅**且**高效**的 [Hugo](https://gohugo.io/) 博客主題。 它的原型基於 [LoveIt 主題](https://github.com/dillonzq/LoveIt), [LeaveIt 主題](https://github.com/liuzc/LeaveIt), 和 [KeepIt 主題](https://github.com/Fastbyte01/KeepIt)。\" # 你的狀態描述 [[params.about.status]] faIcon = \"fas fa-building\" title = \"公司\" desc = \"FeelIt\" [[params.about.status]] faIcon = \"fas fa-briefcase fa-fw\" title = \"職業\" desc = \"自由職業者\" [[params.about.status]] title = \"地點\" faIcon = \"fas fa-map-marker-alt\" desc = \"地球\" # 參數說明 [[params.about.parameter]] language = \"UI/UX\" level = \"80\" [[params.about.parameter]] language = \"HTML\" level = \"70\" [[params.about.parameter]] language = \"Go\" level = \"60\" # 主頁配置 [params.home] # RSS 文章數目 rss = 10 # 主頁個人信息 [params.home.profile] enable = true # Gravatar 郵箱，用於優先在主頁顯示的頭像 gravatarEmail = \"\" # 主頁顯示頭像的 URL avatarURL = \"/images/avatar.png\" # 主頁顯示的網站標題 (支持 HTML 格式) title = \"\" # 主頁顯示的網站副標題 subtitle = \"這是我的全新 Hugo 網站\" # 是否為副標題顯示打字機動畫 typeit = true # 是否顯示社交賬號 social = true # 免責聲明 (支持 HTML 格式) disclaimer = \"\" # 主頁文章列表 [params.home.posts] enable = true # 主頁每頁顯示文章數量 paginate = 6 # display image-preview imagePreview = true # 被 params.page 中的 hiddenFromHomePage 替代 # 當你沒有在文章前置參數中設置 \"hiddenFromHomePage\" 時的默認行為 defaultHiddenFromHomePage = false # oEmbed config [params.oembed] # Privacy config (https://gohugo.io/about/hugo-and-gdpr/) privacy = false [params.oembed.facebook] # Facebook Aplication Identity and Cl","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 網站圖標, 瀏覽器配置, 網站清單 強烈建議你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目錄. 利用 https://realfavicongenerator.net/ 可以很容易地生成這些文件. 可以自定義 browserconfig.xml 和 site.webmanifest 文件來設置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定義樣式 注意 Hugo extended 版本對於自定義樣式是必需的. 通過定義自定義 .scss 樣式文件, FeelIt 主題支持可配置的樣式. 包含自定義 .scss 樣式文件的目錄相對於 你的項目根目錄 的路徑為 assets/css. 在 assets/css/_override.scss 中, 你可以覆蓋 themes/FeelIt/assets/css/_variables.scss 中的變量以自定義樣式. 這是一個例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 樣式代碼以自定義樣式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多語言和 i18n FeelIt 主題完全兼容 Hugo 的多語言模式, 並且支持在網頁上切換語言. 語言切換語言切換 \" 語言切換 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 語言 Hugo 代碼 HTML lang 屬性 主題文檔 Lunr.js 支持 德語 de de 英語 en en 西班牙語 es es 法語 fr fr 印度尼西亞 id id 意大利語 it it 波蘭語 pl pl 巴西葡萄牙語 pt-br pt-BR 羅馬尼亞語 ro ro 俄語 ru ru 塞爾維亞語 sr sr 越南語 vi vi 簡體中文 zh-cn zh-CN 波斯語 fa fa ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 學習了 Hugo如何處理多語言網站 之後, 請在 站點配置 中定義你的網站語言. 例如, 一個支持英語, 中文和法語的網站配置: # [en, zh-cn, fr, pl, ...] 設置默認的語言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 網站\" # 網站語言, 僅在這里 CN 大寫 languageCode = \"zh-CN\" languageName = \"簡體中文\" # 是否包括中日韓文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"標簽\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分類\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然後, 對於每個新頁面, 將語言代碼附加到文件名中. 單個文件 my-page.md 需要分為三個文件: 英語: my-page.en.md 中文: my-page.zh-cn.md 法語: my-page.fr.md 注意 請注意, 菜單中僅顯示翻譯的頁面. 它不會替換為默認語言內容. 技巧 也可以使用 文章前置參數 來翻譯網址. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默認的翻譯字符串 翻譯字符串用於在主題中使用的常見默認值. 目前提供一些語言的翻譯, 但你可能自定義其他語言或覆蓋默認值. 要覆蓋默認值, 請在你項目的 i18n 目錄 i18n/\u003clanguageCode\u003e.toml 中創建一個新文件，並從 themes/FeelIt/i18n/en.toml 中獲得提示. 另外, 由於你的翻譯可能會幫助到其他人, 請花點時間通過  創建一個 PR 來貢獻主題翻譯, 謝謝! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基於 Lunr.js 或 algolia, FeelIt 主題支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 輸出配置 為了生成搜索功能所需要的 index.json, 請在你的 網站配置 中添加 JSON 輸出文件類型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基於 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 這是你的 網站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的類型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章內容最長索引長度 contentLength = 4000 # 搜索框的占位提示語 placeholder = \"\" # 最大結果數目 maxResultLength = 10 # 結果內容片段長度 snippetLength = 50 # 搜索結果中高亮部分的 HTML 標簽 highlightTag = \"em\" # 是否在搜索索引中使用基於 baseURL 的絕對路徑 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎樣選擇搜索引擎? 以下是兩種搜索引擎的對比: lunr: 簡單, 無需同步 index.json, 沒有 contentLength 的限制, 但占用帶寬大且性能低 (特別是中文需要一個較大的分詞依賴庫) algolia: 高性能並且占用帶寬低, 但需要同步 index.json 且有 contentLength 的限制 文章內容被 h2 和 h3 HTML 標簽切分來提高查詢效果並且基本實現全文搜索. contentLength 用來限制 h2 和 h3 HTML 標簽開頭的內容部分的最大長度. 關於 algolia 的使用技巧 你需要上傳 index.json 到 algolia 來激活搜索功能. 你可以使用瀏覽器來上傳 index.json 文件但是一個自動化的腳本可能效果更好. Algolia Atomic 是一個不錯的選擇. 為了兼容 Hugo 的多語言模式, 你需要上傳不同語言的 index.json 文件到對應的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主題文檔 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 FeelIt 主題中快速, 直觀地創建和組織內容.","date":"2020-03-05","objectID":"/theme-documentation-content/","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 FeelIt 主題中快速, 直觀地創建和組織內容. ","date":"2020-03-05","objectID":"/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"1 內容組織 以下是一些方便你清晰管理和生成文章的目錄結構建議: 保持博客文章存放在 content/posts 目錄, 例如: content/posts/我的第一篇文章.md 保持簡單的靜態頁面存放在 content 目錄, 例如: content/about.md 本地資源組織 本地資源引用 有三種方法來引用圖片和音樂等本地資源: 使用頁面包中的頁面資源. 你可以使用適用於 Resources.GetMatch 的值或者直接使用相對於當前頁面目錄的文件路徑來引用頁面資源. 將本地資源放在 assets 目錄中, 默認路徑是 /assets. 引用資源的文件路徑是相對於 assets 目錄的. 將本地資源放在 static 目錄中, 默認路徑是 /static. 引用資源的文件路徑是相對於 static 目錄的. 引用的優先級符合以上的順序. 在這個主題中的很多地方可以使用上面的本地資源引用, 例如 鏈接, 圖片, image shortcode, music shortcode 和前置參數中的部分參數. 頁面資源或者 assets 目錄中的圖片處理會在未來的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置參數 Hugo 允許你在文章內容前面添加 yaml, toml 或者 json 格式的前置參數. 注意 不是所有的以下前置參數都必須在你的每篇文章中設置. 只有在文章的參數和你的 網站設置 中的 page 部分不一致時才有必要這麽做. 這是一個前置參數例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位於 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位於 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章標題. subtitle: 文章副標題. date: 這篇文章創建的日期時間. 它通常是從文章的前置參數中的 date 字段獲取的, 但是也可以在 網站配置 中設置. lastmod: 上次修改內容的日期時間. draft: 如果設為 true, 除非 hugo 命令使用了 --buildDrafts/-D 參數, 這篇文章不會被渲染. author: 文章作者. authorLink: 文章作者的鏈接. description: 文章內容的描述. license: 這篇文章特殊的許可. images: 頁面圖片, 用於 Open Graph 和 Twitter Cards. tags: 文章的標簽. categories: 文章所屬的類別. featuredImage: 文章的特色圖片. featuredImagePreview: 用在主頁預覽的文章特色圖片. hiddenFromHomePage: 如果設為 true, 這篇文章將不會顯示在主頁上. hiddenFromSearch: 如果設為 true, 這篇文章將不會顯示在搜索結果中. twemoji: 如果設為 true, 這篇文章會使用 twemoji. lightgallery: 如果設為 true, 文章中的圖片將可以按照畫廊形式呈現. ruby: 如果設為 true, 這篇文章會使用 上標注釋擴展語法. fraction: 如果設為 true, 這篇文章會使用 分數擴展語法. fontawesome: 如果設為 true, 這篇文章會使用 Font Awesome 擴展語法. linkToMarkdown: 如果設為 true, 內容的頁腳將顯示指向原始 Markdown 文件的鏈接. rssFullText: 如果設為 true, 在 RSS 中將會顯示全文內容. toc: 和 網站配置 中的 params.page.toc 部分相同. code: 和 網站配置 中的 params.page.code 部分相同. math: 和 網站配置 中的 params.page.math 部分相同. mapbox: 和 網站配置 中的 params.page.mapbox 部分相同. share: 和 網站配置 中的 params.page.share 部分相同. comment: 和 網站配置 中的 params.page.comment 部分相同. library: 和 網站配置 中的 params.page.library 部分相同. seo: 和 網站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地資源引用的完整用法. 如果帶有在前置參數中設置了 name: featured-image 或 name: featured-image-preview 屬性的頁面資源, 沒有必要在設置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.webp- name:featured-image-previewsrc:featured-image-preview.jpg ","date":"2020-03-05","objectID":"/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"3 內容摘要 FeelIt 主題使用內容摘要在主頁中顯示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要預覽文章摘要預覽 \" 文章摘要預覽 ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"自動摘要拆分 默認情況下, Hugo 自動將內容的前 70 個單詞作為摘要. 你可以通過在 網站配置 中設置 summaryLength 來自定義摘要長度. 如果您要使用 CJK中文/日語/韓語 語言創建內容, 並且想使用 Hugo 的自動摘要拆分功能，請在 網站配置 中將 hasCJKLanguage 設置為 true. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"手動摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符來拆分文章生成摘要. 摘要分隔符之前的內容將用作該文章的摘要. 注意 請小心輸入\u003c!--more--\u003e ; 即全部為小寫且沒有空格. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"前置參數摘要 你可能希望摘要不是文章開頭的文字. 在這種情況下, 你可以在文章前置參數的 summary 變量中設置單獨的摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作為摘要 你可能希望將文章前置參數中的 description 變量的內容作為摘要. 你仍然需要在文章開頭添加 \u003c!--more--\u003e 摘要分割符. 將摘要分隔符之前的內容保留為空. 然後 FeelIt 主題會將你的文章描述作為摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要選擇的優先級順序 由於可以通過多種方式指定摘要, 因此了解順序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前沒有內容, 則使用描述作為摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 則將按照手動摘要拆分的方法獲得摘要. 如果文章前置參數中有摘要變量, 那麽將以該值作為摘要. 按照自動摘要拆分方法. 注意 不建議在摘要內容中包含富文本塊元素, 這會導致渲染錯誤. 例如代碼塊, 圖片, 表格等. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本語法 這部分內容在 Markdown 基本語法頁面 中介紹. ","date":"2020-03-05","objectID":"/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 擴展語法 FeelIt 主題提供了一些擴展的語法便於你撰寫文章. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 這部分內容在 Emoji 支持頁面 中介紹. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"數學公式 FeelIt 基於 $ \\KaTeX $ 提供數學公式的支持. 在你的 網站配置 中的 [params.math] 下面設置屬性 enable = true, 並在文章的前置參數中設置屬性 math: true來啟用數學公式的自動渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函數 清單. 公式塊 默認的公式塊分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈現的輸出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行內公式 默認的行內公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈現的輸出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 網站配置 中自定義公式塊和行內公式的分割符. Copy-tex Copy-tex 是一個 $ \\KaTeX $ 的插件. 通過這個擴展, 在選擇並覆制 $ \\KaTeX $ 渲染的公式時, 會將其 $ \\LaTeX $ 源代碼覆制到剪貼板. 在你的 網站配置 中的 [params.math] 下面設置屬性 copyTex = true 來啟用 Copy-tex. 選擇並覆制上一節中渲染的公式, 可以發現覆制的內容為 LaTeX 源代碼. mhchem mhchem 是一個 $ \\KaTeX $ 的插件. 通過這個擴展, 你可以在文章中輕松編寫漂亮的化學方程式. 在你的 網站配置 中的 [params.math] 下面設置屬性 mhchem = true 來啟用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈現的輸出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注釋 FeelIt 主題支持一種 字符注音或者注釋 Markdown 擴展語法: [Hugo]^(一個開源的靜態網站生成工具) 呈現的輸出效果如下: Hugo一個開源的靜態網站生成工具 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"分數 FeelIt 主題支持一種 分數 Markdown 擴展語法: [淺色]/[深色] [99]/[100] 呈現的輸出效果如下: 淺色/深色 90/100 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome FeelIt 主題使用 Font Awesome 作為圖標庫. 你同樣可以在文章中輕松使用這些圖標. 從 Font Awesome 網站 上獲取所需的圖標 class. 去露營啦! :(fas fa-campground fa-fw): 很快就回來. 真開心! :(far fa-grin-tears): 呈現的輸出效果如下: 去露營啦!  很快就回來. 真開心! ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"轉義字符 在某些特殊情況下 (編寫這個主題文檔時 ), 你的文章內容會與 Markdown 的基本或者擴展語法沖突, 並且無法避免. 轉義字符語法可以幫助你渲染出想要的內容: {?X} -\u003e X 例如, 兩個 : 會啟用 emoji 語法. 但有時候這不是你想要的結果. 可以像這樣使用轉義字符語法: {?:}joy: 呈現的輸出效果如下: :joy: 而不是 😂 技巧 這個方法可以間接解決一個還未解決的 Hugo 的 issue. 另一個例子是: [link{?]}(#escape-character) 呈現的輸出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主題文檔 - 內容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔.","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔. Hugo 使用 Markdown 為其簡單的內容格式. 但是, Markdown 在很多方面都無法很好地支持. 你可以使用純 HTML 來擴展可能性. 但這恰好是一個壞主意. 大家使用 Markdown, 正是因為它即使不經過渲染也可以輕松閱讀. 應該盡可能避免使用 HTML 以保持內容簡潔. 為了避免這種限制, Hugo 創建了 shortcodes. shortcode 是一個簡單代碼段, 可以生成合理的 HTML 代碼, 並且符合 Markdown 的設計哲學. Hugo 附帶了一組預定義的 shortcodes, 它們實現了一些非常常見的用法. 提供這些 shortcodes 是為了方便保持你的 Markdown 內容簡潔. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文檔 一個 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" alt=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈現的輸出效果如下: Lighthouse (figure) 輸出的 HTML 看起來像這樣: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" alt=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文檔 一個 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈現的輸出效果如下: 輸出的 HTML 看起來像這樣: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文檔 一個 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈現的輸出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram At the moment, Hugo using deprecated oEmbed-legacy linked API endpoint. Those deprecated API causes an error when Hugo retrieving the data. The newest API has been included in the extended shortcode. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文檔 一個 param 示例: {{\u003c param description \u003e}} 呈現的輸出效果如下: Hugo 提供了多個內置的 Shortcodes, 以方便作者保持 Markdown 內容的整潔. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文檔 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet This method was moved with the newest API in the extended shortcode documentation. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文檔 一個 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文檔 一個 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈現的輸出效果如下: Ctrl+A or Ctrl+V 總共有：3627 字 在線上修改圖片，相片，照片So Easy. 點此看 » 線上工具 | Sitemap | 聯絡我們 | 繪文字 | 許願樹 Copyright ©2022 Online Tools,All Rights Reserved. TOP GmailFacebookTwitterWhatsAppTelegramWeChatLine分享 讀取中… ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主題文檔 - 內置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":null,"content":"本文章是使用 Node.js 來寫一個 Repository Restful API 的留言板，並且會使用 express 以及 sequelize (使用 Mysql)套件。 建議可以先觀看 Node.js 介紹 文章來簡單學習 Node 語言。 範例程式連結 點我 😘 版本資訊 macOS：11.6 node：v16.14.2 npm：8.5.0 Mysql：mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:0:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"實作 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"檔案結構 . ├── app.js ├── config │ └── config.json ├── controllers │ ├── auth.js │ ├── message.js │ └── reply.js ├── middleware │ └── index.js ├── migrations │ ├── 20220331054531-create-user.js │ ├── 20220401093019-create-message.js │ └── 20220404041905-create-reply.js ├── models │ ├── index.js │ ├── message.js │ ├── reply.js │ └── user.js ├── node_modules(以下檔案省略) ├── package-lock.json ├── package.json ├── repositories │ ├── auth.js │ ├── message.js │ └── reply.js └── router └── index.js 我們來說明一下上面的資料夾以及檔案各別功能與作用 app.js：程式的啟動入口，裡面會放置有關程式系統需要呼叫哪些套件等等。 config：放置資料庫連線資料 (使用 sequelize-cli 套件自動產生)。 controllers：商用邏輯控制。 middleware：用來檢查登入權限。 migrations：放置產生不同 Model 資料表 (使用 sequelize-cli 套件自動產生)。 models：定義資料表資料型態 (使用 sequelize-cli 套件自動產生)。 node_modules：放置下載使用的套件位置。 package.json/package-lock.json：專案資訊的重要檔案 (使用 npm init 自動產生)。 repositories：處理與資料庫進行交握。 router：設定網站網址路由。 以下詳細說明部分，只會說明 app.js、config、controllers、middleware、migrations、models、repositories、router (介紹會依照程式流程來介紹)。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:1","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"config { \"development\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" }, \"test\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" }, \"production\": { \"username\": \"root\", \"password\": \"\", \"database\": \"node\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"dialectOptions\": { \"dateStrings\": true, \"typeCast\": true }, \"timezone\": \"+08:00\" } } 由 sequelize-cli 套件自動產生，可以依照不同程式狀態(開發 development、測試 test、上線 production)來修改連線時的參數。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:2","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"migrations 檔案基本上都雷同，舉其中一個為說明。migrations 也是由 sequelize-cli 套件自動產生，相關指令會統一放在最後。 20220401093019-create-message.js \"use strict\";module.exports = {async up(queryInterface, Sequelize) {await queryInterface.createTable(\"message\", {id:{allowNull:false,autoIncrement:true,primaryKey:true,type:Sequelize.INTEGER,},user_id:{allowNull:false,type:Sequelize.INTEGER,references:{model:\"user\",key:\"id\",},},content:{allowNull:false,type:Sequelize.STRING,},version:{type:Sequelize.INTEGER,defaultValue:0,},createdAt:{allowNull:false,type:Sequelize.DATE,},updatedAt:{allowNull:true,type:Sequelize.DATE,},deletedAt:{allowNull:true,type:Sequelize.DATE,},});},async down(queryInterface, Sequelize) {await queryInterface.dropTable(\"message\");},}; 這個檔案的格式也是透過指令產生，會有 up 跟 down，up 就是執行指令後會產生什麼，主要都會是新增資料表或是修改資料表，down 則是回復的功能，可以將資料表給 dropTable 。我們主要會修改的地方是 createTable 內的資料，裡面的資料代表資料表的欄位，以下列出常用的格式： allowNull：是否為空值 autoIncrement：自動累加 primaryKey：主鍵 type：裡面就放欄位類型，例如 INTEGER、STRING、DATE等等 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:3","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"app.js \"use strict\"; const express = require(\"express\"); const sessions = require(\"express-session\"); const app = express(); const port = 8888; // 設定 Session const oneDay = 1000 * 60 * 60 * 1; app.use( sessions({ secret: \"mySecret\", name: \"user\", saveUninitialized: false, rolling: true, cookie: { maxAge: oneDay }, resave: false, }) ); // 註冊路由 app.use(\"/api/v1\", require(\"./router\")); // 檢查是否有table，沒有就建立 // const Message = require(\"./models\").message; // const User = require(\"./models\").user; // Message.sync(); // User.sync(); // 開啟監聽 app.listen(port, console.log(\"啟動 Server,Port:\" + port)); 先引入會使用的套件 (express：node web 框架、express-session：session 套件) 設定 app 為 express() 實例，port 為 8888。 設定 session 失效時間、名稱等設定。 secret(必要)：用來簽章 sessionID 的cookie, 可以是一secret字串或是多個secret組成的一個陣列。 name：在response中，設定的 sessionID cookie 名字。預設是 connect.sid。 saveUninitialized：強制將未初始化的session存回 session store，未初始化的意思是它是新的而且未被修改。 rolling：強制在每一次回應時，重新設置一個sessionID cookie。 cookie：設定sessionID 的cookie相關選項。 resave：強制將session存回 session store, 即使它沒有被修改。 註冊路由，連線 http://127.0.0.1/api/v1 後面會導向 router 檔案。 註解部分為可以每次啟動後先檢查是否有table，沒有就建立。 開啟 port(8888) 監聽。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:4","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"router \"use strict\"; const express = require(\"express\"); const middleware = require(\"../middleware\"); const router = express(); const { register, login, lojsut } = require(\"../controllers/auth\"); const { getAllMessage, getMessage, createMessage, updateMessage, deleteMessage, } = require(\"../controllers/message\"); const { createReply, updateReply, deleteReply, } = require(\"../controllers/reply\"); // 註冊、登入、登出 router.post(\"/register\", express.json(), register); router.post(\"/login\", express.json(), login); router.post(\"/lojsut\", lojsut); // 查詢留言 router.get(\"/message\", getAllMessage); router.get(\"/message/:message_id\", getMessage); //需要驗證才可以使用（新增留言、修改留言、刪除留言、新增留言回覆、修改留言回覆、刪除留言回覆） router.use(middleware); router.post(\"/message\", express.json(), createMessage); router.patch(\"/message/:message_id\", express.json(), updateMessage); router.delete(\"/message/:message_id\", deleteMessage); router.post(\"/message/:message_id\", express.json(), createReply); router.patch(\"/message/:message_id/:reply_id\", express.json(), updateReply); router.delete(\"/message/:message_id/:reply_id\", deleteReply); module.exports = router; 設定路由，分別是註冊、登入、登出、新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function。express.json() 函數是為了要讓 body-parser 解析帶有 JSON 傳入後面的 controller，其中比較特別的是因為新增留言、修改留言、刪除留言、新增留言回覆、修改留言回覆、刪除留言回覆需要登入後才可以使用，所以多一個 middleware 來驗證是否登入。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:5","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"middleware \"use strict\"; module.exports = (req, res, next) =\u003e { if (!req.session.userid) { return res.status(401).json({ message: \"用戶需要認證\" }); } next(); }; 使用 session 來驗證是否有登入。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:6","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"models 會放置與資料表資料型態有關的資訊，其中 index.js 是由 sequelize-cli 套件自動產生，用來讀取目前寫在 config 的連線設定檔等資訊。 index.js \"use strict\"; const fs = require(\"fs\"); const path = require(\"path\"); const Sequelize = require(\"sequelize\"); const basename = path.basename(__filename); const env = process.env.NODE_ENV || \"development\"; const config = require(__dirname + \"/../config/config.json\")[env]; const db = {}; let sequelize; if (config.use_env_variable) { sequelize = new Sequelize(process.env[config.use_env_variable], config); } else { sequelize = new Sequelize( config.database, config.username, config.password, config ); } fs.readdirSync(__dirname) .filter((file) =\u003e { return ( file.indexOf(\".\") !== 0 \u0026\u0026 file !== basename \u0026\u0026 file.slice(-3) === \".js\" ); }) .forEach((file) =\u003e { const model = require(path.join(__dirname, file))( sequelize, Sequelize.DataTypes ); db[model.name] = model; }); Object.keys(db).forEach((modelName) =\u003e { if (db[modelName].associate) { db[modelName].associate(db); } }); db.sequelize = sequelize; db.Sequelize = Sequelize; module.exports = db; user.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class user extends Model { static associate(models) { user.hasMany(models.message, { foreignKey: \"user_id\", }); } } user.init( { username: { type: DataTypes.STRING, unique: true, }, password: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"user\", } ); return user; }; 此為 user 資料表的欄位資料，有預設的 init 初始化，比較特別的是如果有用到關聯性的外鍵等等要記得在 associate 做設定，user.hasMany(models.message,{foreignKey: \"user_id\",}) 代表 user 這張表可以有很多個 message，其 message 外鍵是 user_id。 paranoid：代表會執行軟刪除而不是硬刪除，但必須要多一個 deletedAt 來存放軟刪除時間。 freezeTableName：因為 sequelize 會自動再產生資料表時加上複數，如果不想要就必須使用它讓 sequelize 不會自動加入 s (複數)。 modelName：此 model 名稱。 message.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class message extends Model { static associate(models) { message.hasMany(models.reply, { foreignKey: \"message_id\", }); message.belongsTo(models.user, { foreignKey: \"user_id\", }); } } message.init( { user_id: { type: DataTypes.INTEGER, allowNull: false, }, content: { type: DataTypes.STRING, allowNull: false, }, version: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"message\", } ); return message; }; 此為 message 資料表的欄位資料，associate 設定有 message.hasMany(models.reply,{foreignKey: \"message_id\",}) 代表 message 這張表可以有很多個 reply，其 reply 外鍵是 message_id。以及 message.belongsTo(models.user, {foreignKey: \"user_id\",}); 代表 message 存在一對一的關係，外鍵是 user_id。 reply.js \"use strict\"; const { Model } = require(\"sequelize\"); module.exports = (sequelize, DataTypes) =\u003e { class reply extends Model { static associate(models) { reply.belongsTo(models.message, { foreignKey: \"message_id\", }); reply.belongsTo(models.user, { foreignKey: \"user_id\", }); } } reply.init( { message_id: { type: DataTypes.INTEGER, allowNull: false, }, user_id: { type: DataTypes.INTEGER, allowNull: false, }, content: { type: DataTypes.STRING, allowNull: false, }, version: { type: DataTypes.STRING, }, }, { sequelize, paranoid: true, freezeTableName: true, modelName: \"reply\", } ); return reply; }; 此為 reply 資料表的欄位資料，associate 設定有reply.belongsTo(models.message, {foreignKey: \"message_id\",}); 代表 reply 存在一對一的關係，外鍵是 message_id，以及 reply.belongsTo(models.user, {foreignKey: \"user_id\",}); 代表 reply 存在一對一的關係，外鍵是 user_id。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:7","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"controllers 我們遵循 MVC 的設計規範，所有的商用邏輯都會放在 controller 內，repository 只負責與資料庫進行交握。 auth.js const Auth = require(\"../repositories/auth\"); const bcrypt = require(\"bcrypt\"); // 註冊 const register = async (req, res) =\u003e { if (!req.body.username || !req.body.password) { return res.status(400).json({ user: \"沒有正確輸入帳號或密碼\" }); } const salt = await bcrypt.genSalt(10); const bcrypt_password = await bcrypt.hash(req.body.password, salt); user = await Auth.register(req.body.username, bcrypt_password); if (!user[1]) { return res.status(400).json({ user: \"username已存在\" }); } return res.status(201).json({ user: user }); }; // 登入 const login = async (req, res) =\u003e { if (!req.body.username || !req.body.password) { return res.status(400).json({ user: \"沒有正確輸入帳號或密碼\" }); } user = await Auth.login(req.body.username, req.body.password); if (!user) { return res.status(400).json({ user: \"帳號或密碼錯誤\" }); } session = req.session; session.userid = user.id; return res.status(200).json({ user: \"登入成功\" }); }; // 登出 const logout = async (req, res) =\u003e { session = req.session; session.destroy(); return res.status(200).json({ user: \"登出成功\" }); }; module.exports = { register, login, logout, }; 主要有3 個部份，註冊、登入、登出： 註冊：會先驗證是否正確輸入資料(包含欄位是否錯誤等)，如果有錯，就會回應 400 以及沒有正確輸入帳號或密碼。接下來會使用到 bcrypt 來幫密碼進行加密處理，再把加密後的密碼以及帳號丟到 Auth.register repository 來進行資料庫的存取，如果錯誤會回應 400 以及 username 已存在，成功會回應 201 以及新增的帳號資訊。 登入：一樣會先檢查輸入資料，接著把資料丟到 Auth.login repository 來進行資料庫的驗證，如果錯誤會回應 400 以及帳號或密碼錯誤，成功會回應 200 以及登出成功。 登出：將 session 給清除，然後回應 200 以及登出成功。 message.js (由於內容較多，所以依照功能拆分後說明) 查詢留言功能 const Message = require(\"../repositories/message\"); const Reply = require(\"../repositories/reply\"); // 查詢所有留言 const getAllMessage = async (req, res) =\u003e { message = await Message.getAll(); return res.status(200).json({ message: message }); }; //查詢{id}留言 const getMessage = async (req, res) =\u003e { if (!(message = await Message.get(req.params.message_id))) { return res.status(404).json({ message: \"找不到留言\" }); } return res.status(200).json({ message: message }); }; 先載入要使用的 repository ，查詢所有留言會使用 Message.getAll() repository 來進行資料庫的讀取，會回應 200 以及查詢內容，若是尚未有留言則會顯示空陣列。查詢{id}留言會將 req.params.message_id 丟到 Message.get repository 來進行資料庫的讀取，如果錯誤會回應 404 以及 找不到留言，成功會回應 200 以及查詢內容。 新增留言功能 //新增留言 const createMessage = async (req, res) =\u003e { if (!req.body.content || req.body.content.length \u003e 20) { return res.status(400).json({ message: \"沒有輸入內容或長度超過20個字元\" }); } message = await Message.create(req.session.userid, req.body.content); return res.status(201).json({ message: message }); }; 新增留言會先檢查輸入內容是否為空以及不能大於20個字元，如果錯誤就回應 400 以及沒有輸入內容或長度超過20個字元，再將 req.session.userid、req.body.content 丟到 Message.create repository 來進行資料庫的存取，成功會回應 201 以及新增的留言。 修改留言功能 //修改留言 const updateMessage = async (req, res) =\u003e { if (!(message = await Message.get(req.params.message_id))) { return res.status(404).json({ message: \"找不到留言\" }); } if (!req.body.content || req.body.content.length \u003e 20) { return res.status(400).json({ message: \"沒有輸入內容或長度超過20個字元\" }); } if ( (await Message.update( req.params.message_id, req.session.userid, req.body.content, message[\"version\"] )) == \"0\" ) { return res.status(400).json({ message: \"修改留言失敗\" }); } return res.status(200).json({ message: \"修改留言成功\" }); }; 修改留言因為需要先從資料中取得 version 來檢查樂觀鎖，所以會先將 req.params.message_id 丟到 Message.get repository 來進行資料庫的查詢，錯誤會回應 404 以及找不到留言。 先檢查輸入內容是否為空以及不能大於20個字元，如果錯誤就回應 400 以及沒有輸入內容或長度超過20個字元，再將 req.params.message_id、req.session.userid、req.body.content、message[\"version\"] 丟到 Message.update repository 來進行資料庫的更新，錯誤會回應 400 以及修改留言失敗，成功會回應 200 以及修改留言成功。 刪除留言功能 //刪除留言 const deleteMessage = async (req, res) =\u003e { if (!(await Message.delete(req.params.message_id, req.session.userid))) { return res.status(400).json({ message: \"刪除留言失敗\" }); } // 刪除留言時同步刪除所有回覆 await Reply.deleteMessage(req.params.message_id); return res.status(204).json({ message: \"刪除留言成功\" }); }; 刪除留言會將 req.params.message_id、req.session.userid 丟到 Message.delete repository 來進行資料庫的軟刪除，錯誤會回應 400 以及刪除留言失敗，因為我們刪除留言後，不能在對該留言進行回覆的任何功能，所以一同軟刪除所有的回覆，成功後會回應 204 以及刪除留言成功。 reply.js (由於內容較多，所以依照功","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:8","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"repositories 此會放置與資料庫進行交握的程式。 auth.js const User = require(\"../models\").user; const bcrypt = require(\"bcrypt\"); const auth = { // 註冊 async register(username, bcrypt_password) { return await User.findOrCreate({ where: { username: username }, defaults: { username: username, password: bcrypt_password }, }); }, // 登入 async login(username, password) { const user = await User.findOne({ where: { username: username } }); if (user) { return (await bcrypt.compare(password, user.password)) ? user : false; } }, }; module.exports = auth; auth 內主要有兩個與資料庫進行互動，分別是，註冊以及登入，註冊會將傳入的帳號以及加密過後密碼使用 User.findOrCreate 來進行查詢或新增，如果帳號不存在才會進行新增動作。登入會將傳入的帳號及密碼使用 User.findOne 來檢查是否存在，如果存在再檢查密碼與資料庫是否正確。 message.js const Message = require(\"../models\").message; const Reply = require(\"../models\").reply; const repository = { async getAll() { return await Message.findAll({ include: { model: Reply } }); }, async get(message_id) { return await Message.findOne({ include: { model: Reply, }, where: { id: message_id }, }); }, async create(user_id, content) { return await Message.create({ user_id: user_id, content: content }); }, async update(message_id, user_id, content, version) { return await Message.update( { content: content, version: version + 1, }, { where: { id: message_id, user_id: user_id, version: version, }, } ); }, async delete(message_id, user_id) { return await Message.destroy({ where: { id: message_id, user_id: user_id }, }); }, }; module.exports = repository; message.js 裡面有會查詢全部留言、查詢{id}留言、新增留言、修改{id}留言、刪除{id}留言等，以下會說明各別負責功用： 查詢全部留言 getAll()：使用 Message.findAll 來顯示查詢結果，並且 include model Reply 回覆內容。 查詢{id}留言 get()：使用 Message.findOne 查詢 message.id 等於 message_id 的結果，並且 include model Reply 回覆內容。 新增留言 create()：使用 Message.create 新增 message.user_id 以及 message.content。 修改{id}留言 update()：使用 Message.update 更新 content 以及 version，且 message.id 要等於 message_id 及 message.user_id 等於 user_id 及 message.version 等於 version。 刪除{id}留言 delete()：使用 Message.destroy 刪除符合 message.id 等於 message_id 及 message.user_id 等於 user_id。 reply.js const Message = require(\"../models\").message; const Reply = require(\"../models\").reply; const reply = { async get(reply_id, message_id) { return await Reply.findOne({ where: { id: reply_id, message_id: message_id }, }); }, async create(message_id, user_id, content) { is_exist = await Message.findOne({ where: { id: message_id }, }); if (is_exist) { return await Reply.create({ message_id: message_id, user_id: user_id, content: content, }); } }, async update(reply_id, message_id, user_id, content, version) { return await Reply.update( { content: content, version: version + 1, }, { where: { id: reply_id, message_id: message_id, user_id: user_id, version: version, }, } ); }, async delete(reply_id, message_id, user_id) { return await Reply.destroy({ where: { id: reply_id, message_id: message_id, user_id: user_id, }, }); }, async deleteMessage(message_id) { return await Reply.destroy({ where: { message_id: message_id, }, }); }, }; module.exports = reply; reply.js 裡面有會新增回覆、修改{id}回覆、刪除{id}回覆等，除此之外還多了兩個 get、deleteMessage 用來取得 version 樂觀鎖以及同步刪除回覆功能，那以下會說明各別負責功用： 新增回覆 create()：因為要先確認留言是否被刪除，所以先使用 Message.findOne 檢查留言是否被刪除，在用 Reply.create 新增 reply.message_id 跟 reply.user_id 以及 reply.content。 修改{id}回覆 update()：使用 Reply.update 更新 content 以及 version，且 reply.id 要等於 reply_id 及 reply.message_id 等於 message_id 及 reply.user_id 等於 user_id 及 reply.version 等於 version。 刪除{id}回覆 delete()：使用 Reply.destroy 刪除符合 reply.id 等於 reply_id 跟 reply.message_id 等於 message_id 及 reply.user_id 等於 user_id。 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:1:9","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"常用指令 (sequelize-cli) sequelize db:migrate：將資料表依照 up 內容執行(migrate 檔案)。 sequelize db:migrate:undo:all：將資料表依照 down 內容執行(migrate 檔案)。 sequelize db:seed：產生假資料 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:2:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"Postman 測試 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 成功 註冊 成功\" 註冊 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:1","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 失敗(無輸入) 註冊 失敗(無輸入)\" 註冊 失敗(無輸入) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:2","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"註冊 - 失敗(已經註冊過) 註冊 失敗(已經註冊過)\" 註冊 失敗(已經註冊過) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:3","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"登入 - 成功 登入 成功\" 登入 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:4","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"登入 - 失敗 登入 失敗\" 登入 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:5","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢全部留言 - 成功(無資料) 查詢留言 成功(無資料)\" 查詢留言 成功(無資料) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:6","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢全部留言 - 成功(有資料) 查詢留言 成功(有資料)\" 查詢留言 成功(有資料) ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:7","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢{id}留言 - 成功 查詢{id}留言 成功\" 查詢{id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:8","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"查詢{id}留言 - 失敗 查詢{id}留言 失敗\" 查詢{id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:9","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增留言 - 成功 新增留言 成功\" 新增留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:10","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增留言 - 失敗 新增留言 失敗\" 新增留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:11","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}留言 - 成功 修改 {id}留言 成功\" 修改 {id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:12","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}留言 - 失敗 修改 {id}留言 失敗\" 修改 {id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:13","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}留言 - 成功 刪除 {id}留言 成功\" 刪除 {id}留言 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:14","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}留言 - 失敗 刪除 {id}留言 失敗\" 刪除 {id}留言 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:15","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增回覆 - 成功 新增回覆 成功\" 新增回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:16","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"新增回覆 - 失敗 新增回覆 失敗\" 新增回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:17","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}回覆 - 成功 修改 {id}回覆 成功\" 修改 {id}回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:18","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"修改{id}回覆 - 失敗 修改 {id}回覆 失敗\" 修改 {id}回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:19","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}回覆 - 成功 刪除 {id}回覆 成功\" 刪除 {id}回覆 成功 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:20","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"刪除{id}回覆 - 失敗 刪除 {id}回覆 失敗\" 刪除 {id}回覆 失敗 ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:3:21","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":null,"content":"參考資料 Node.js 官網 Sequelize 透過 sequelize 來達成 DB Schema Migration How to create JOIN queries with Sequelize ","date":"2022-04-11","objectID":"/node-restful-api-repository-messageboard/:4:0","tags":["Node.js","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)","uri":"/node-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"什麼是 Node.js ? Node.js 是能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台執行環境。 Node.js 的出現，讓前端網站開發人員可以使用 JaveScript 來做後端或是系統層面的工作。讓前端開發網站開發人員使用已懂的 JavaScript 語言就可以自行設定網站伺服器。 Node.js 採用 Google 開發的 Chrome V8 JavaScript 引擎和 libuv 函式庫，可以用指令去執行 JavaScript，使用非阻塞輸入輸出、非同步、事件驅動等技術來提高效能，可最佳化應用程式的傳輸量和規模。這些技術通常用於資料密集的即時應用程式。 主要的 Node.js 組件 (An Intro to Node.js That You May Have Missed)\" 主要的 Node.js 組件 (An Intro to Node.js That You May Have Missed) 其他開源、低級組件，主要用 C/C++ 編寫： c-ares : 用於非同步 DNS 請求的 C 函式庫，用於 Node.js 中的一些 DNS 請求。 http-parser：一個輕量級的 HTTP 請求/回應解析器。 OpenSSL：一個著名的通用密碼庫。用於 tls 和 cryto 模組。 zlib：無損數據壓縮庫。 Node.js 能快速的原因是因為他對資源的調校不同，當程式收到一筆連線， 相較於 PHP 的每次連線都會新生成一個執行緒，當連線數量暴增時很快就會消耗掉系統的資源，並且容易產生阻塞 (block)， 而 Node.js 則是會通知作業系統透過 epoll、kqueue、/dev/poll、select 等將連線保留，並放入 heap 中配置，先讓連線進入休眠 (Sleep) 狀態，等系統通知才觸發連線的 callback。 這種處理方式只會佔用記憶體，並不會使用到 CPU 資源。另外因為 JavaScript 語言的特性，每一個 request 都會有一個 callback，可以避免發生阻塞的狀況發生。 以下會先從非阻塞輸入輸出、非同步，再談到事件驅動。 ","date":"2022-03-30","objectID":"/node/:1:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"非阻塞 (non-blocking) 輸入輸出(I/O) 是程式跟系統記憶體或網路的互動，例如發送 HTTP 請求、對資料庫CRUD 操作等等。 以網站開發者角度來看，大部分的網站程式都不需要太多的 CPU 計算，反而是在等待大量的 I/O 處理完畢 (HTTP 請求、資料庫的取得資料或是更新資料等)，所以處理 I/O 的速度會是網頁程式效能的關鍵。 那要怎麼才能讓等待 I/O 的時間，不要卡住後續的程式碼呢？可以讓程式一邊等 I/O 處理，一邊繼續執行其他部分的程式碼，主要有兩種方法： 多執行緒 (multi-threaded)：使用阻塞 (blocking) I/O 的設計。 單執行緒 (single-threaded)：使用非阻塞 (non-blocking) I/O 的設計 + 非同步 (asynchronous) 處理。 阻塞就是 I/O 的處理阻擋了其他後續程式碼的執行。舉個例子： 阻塞 (blocking) 非阻塞 (non-blocking) 阻塞後續程式碼的執行，就好像是我們去附近買烤肉，交給老闆後，為了想吃到熱騰騰的食物，所以只能留在原地，不能先去其他地方 非阻塞不會阻擋後續程式碼的執行，就好像是我們去百貨公司美食街點餐，點完餐後會拿到一個呼叫器，就可以先離開，等到呼叫器響了再回去拿即可 像是 Python、Ruby 等語言是使用多執行緒 (multi-threaded)，使用阻塞 I/O ： 程式會等網路或是記憶體的作業結束後才會繼續往下，等待時間這個作業中的執行緒不會去做其他事情。 如果想要達到『等待 I/O 期間不要卡住其他程式碼』，的做法就是新開一個執行緒，直到任務完成，再告訴主執行緒說( 我完成囉！) 即可。 Node.js 使用單執行緒 (single-threaded) ，非阻塞 I/O + 非同步函式： Node.js 使用非阻塞設計，那要怎麼去操作資料庫或是 HTTP 請求的輸入輸出呢？就要透過非同步 (asynchronous) 來處理囉！ ","date":"2022-03-30","objectID":"/node/:1:1","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"非同步 (asynchronous) 非同步也可以稱為異步，它的作用就是讓程式不要被阻擋等 I/O 處理完，才可以跑下一行程式碼，是直到函式中的 callback 被呼叫的時候再執行後續要做的事情。 同步 vs. 非同步 非同步 (asynchronous) 可以想像一下你去咖啡廳買拿鐵跟黑咖啡，可能會發生的情況是： 你點了拿鐵跟黑咖啡 店員在收銀機上輸入點餐內容 店員請同事 A 準備拿鐵、請同事 B 準備黑咖啡，並告知做完後，要提醒店員 黑咖啡製作會比較快，B 同事會先完成，而剛好店員剛幫你結帳完沒事，所以把黑咖啡拿給你 拿鐵製作包含較多步驟，花費時間較久，等 A 同事完成後，店員剛好沒事，所以把拿鐵拿給你 可以看到，櫃檯店員一次只能做一件事情，但為了節省時間，店員將工作分配給其他同事，在下完指令後，店員會繼續幫你結帳，等同事們各自完成後會告知店員，店員在依序把飲料交給你 - 最終等待時間減少，也不會浪費閒置的資源，這就是現實生活中非同步的情況。 同步 (synchronous) 一樣我們點了拿鐵跟黑咖啡，換成同步的話： 店員在收銀機上輸入點餐內容 店員請同事 A 開始準備拿鐵 A 同事準備完拿鐵，店員轉交給你 店員請同事 B 開始準備黑咖啡 B 同事準備完黑咖啡，店員交給你 店員幫你刷載具、打統編、找錢等等 同樣的餐點內容，如果是同步處理，代表要等每一件事情做完，才可以做下一步。也就是說同事 A 完成拿鐵後，店員才請 B 同事準備黑咖啡。相對於非同步來說，會花費不少時間以及浪費不少閒置資源。 從咖啡店的例子中可以發現： 櫃檯店員手上一次能做的事情只有一件 (Single thread 單執行緒)，只是在非同步的例子中，將製作咖啡的事情委派給其他同事處理，讓自己可以繼續幫你結帳，來提高效率 — JavaScript 是 Single thread，一次只能做一件事情。 在非同步的例子中，櫃檯店員將製作咖啡的事情委派出去，其實店員也不知道哪一個任務會先被完成，但店員還是可以繼續完成結帳的任務，不會因為同事 A、B 還在製作咖啡，就不能接下去動作 (non-blocking) — JavaScript 一次只能做一件事，但藉由 Node 提供的 API 協助，在背後處理這些事件 (同事在背後製作咖啡)，可以等待製作同時，不會被阻塞 (blocking) 到下一件事情的執行。 非同步的例子中，店員委派事情的流程很簡單：就是請同事完成製作咖啡 (event) + 在收到同事通知完成後接手咖啡，並轉交給你 (callback function) — 若是採用非同步處理，會有 callback function 來指定事件完成後要接續做什麼：它不會立即被執行，而是等待委託的事情被完成後才觸發。 當同事 A、B 分別通知完成後，就會依序把咖啡放在店員的旁邊排成一排 (event queue)。想向店員有一個小助手 (event loop) ，他的工作內容是確認店員結帳完了沒有：如果結帳完了，就會把隊伍中第一杯咖啡叫給店員，讓店員交給你 (觸發 callback function) ; 如果店員還在結帳，就會讓隊伍中的咖啡擺在旁邊繼續等待。 JaveScript 實現非同步的方法不斷演進著：從 callback、promise 到最新的 async-await 函式。 Callback 什麼是 Callback 假設有 A、B、C 三件工作，其中 B 必須等待 C 做完才能執行。大部份的人幾乎都是做 A，再做 C，等待 C 做完以後最後做 B。但對於可多工的人來說，卻可能是同時做 A 與 C（多工），等待 C 完成後做 B。 Callback function 是一個被作為參數帶入另一個函式中的「函式」，這個被作為參數帶入的函式將在「未來某個時間點」被呼叫和執行 — 這是處理非同步事件的一種方式。 再次舉 A、B、C 三件工作的例子，其中 B 必須等待 C 做完才能執行，於是我們將 B 放到 C 的 callback 中，讓宿主環境在收到 C 完成的回應時後 B 放到佇列中準備執行。 doA(); doC(function() { doB(); }); 常見的例子： 使用瀏覽器所提供的 setTimeout()或是 setInterval() setTimeout(() =\u003e { console.log('這個訊息將在三秒後被印出來') }, 3000) 提供一個匿名函式作為參數帶入 setTimeout() 函式中，目的就是請 setTimeout() 在未來某個時間點（三秒後）呼叫和執行這個匿名函式。 DOM 的事件監聽 const btn = document.querySelector('button') btn.addEventListener('click', callbackFunctionName) callbackFunctionName 做為參數被帶入 addEventListener() 中，callbackFunctionName 不會立即被執行，而是未來按鈕被點擊時才會執行。 Callback 主要有一個缺點：回呼地獄 回呼地獄 (Callback Hell) 回呼地獄 (Callback Hell) 又稱為「毀滅金字塔」，指的是層次太深的巢狀 Callback，讓程式變的更複雜且難以預測或是追蹤。 向遠端伺服器發出請求並獲得資訊後，執行 Callback，再發出請求，獲得資訊後執行 Callback，再發出請求，獲得資訊後執行 Callback，就會不小心一層包一層，變成所謂的 Callback Hell。 doA(function() { doB(); doC(function() { doD(); }); doE(); }); doF(); 缺點： 可讀性低：如果程式碼出錯，要回頭慢慢找錯誤的地方 可維護性低：如果要修改其中一組函式，牽一髮而動全身 那在同步執行情況下，可以使用 try...catch 來捕捉錯誤訊息，但如果是在非同步情況下，要怎麼處理錯誤或是例外訊息呢！？ 主要有兩種方式： 分別回呼 (Split Callback) 分別的回呼要設定兩個 Callback，一個用於成功通知，另一個則用於錯誤通知。如下，第一個參數是用於成功的 Callback，第二個參數是用於失敗的 Callback： function success(data) { console.log(data); } function failure(err) { console.error(error); } ajax('http://sample.url', success, failure); 那如果在 Callback 中發生錯誤，要怎麼辦呢!? function success(data) { console.log(x); } function failure(err) { console.error(error); } ajax('http://sample.url', success, failure); // Uncaught (in promise) ReferenceError: x is not defined 會直接報錯，並不會進入到 failure 這個 Callback 裡面，也就是說，如果是在 Callback 內發生錯誤，是不會被捕捉到的。 錯誤優先處理 (Error-First Style) Node.js 的 API 常見這樣的設計方式，第一個參數是 error ，第二個參數是回應的資料 (data)。檢查 error 是否有值或是 true，否則就接續處理 data。 function response(err, data) { if(err) { console.error(err); } else { console.log(data); } } ajax('http://sample.url', response); 接下來我們來看 Promise，可以解決 callback 可讀性低的 Callback Hell 問題。 Promise Promise：Callback 以外的另一種方式來處理非同步事件，且可讀性與可維護性比 Callback 好很多。 Promise 是一個物件，代表著一個尚未完成，但最終會完成的一個動作 - 在一個非同步處理流程中，它只是一個暫存的值。 我們一樣來說剛剛咖啡店的例子： 當我們點完拿鐵跟黑咖啡後，店員會給你一張印有號碼的收據，然後告訴你等等聽到號碼，就可以來領咖啡了，而這張收據就是 Promise，代表這個任務完成後，就可以接著執行接下來的動作了。 在等待過程中，其實無法百分百確定最後一定會拿到咖啡 (Promise) ; 店員可能順利做完咖啡交到你手上 (Resolved) ; 可能牛奶或是咖啡豆沒了，所以店員告訴你今天做不出來咖啡 (Rejected)。 Promise 就像上面的例子中，會處在三個任意階段中： Pedning：等待事情完成中，但不確定最終會順利完成或失敗 Resolved（或稱 Fulfilled）：代表順利完成了，並轉交結果 Rejectesd：代表失敗了，並告知失敗原因 const getData = new Promise((resolve, reject) =\u003e { // 製作咖啡..... // 作業完成，並回傳錯誤訊息時 if (error) { return reject('牛奶或是咖啡豆沒了') } // 作業成功完成 resolve(","date":"2022-03-30","objectID":"/node/:1:2","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"事件驅動 (event-driven) 在講事件驅動前，我們先來了解一下什麼是事件： 事件 (event) 事件是指用戶或是系統作出的動作，例如使用者點選按鈕，或是檔案讀取完成、某種錯誤產生等等，都叫做事件。 事件驅動 (event-driven) 事件驅動是一種程式執行模型，表示程式的進行是依據事件的發生而定，監聽到事件就處理、處理完就執行 callback ，透過不斷的監聽跟回應事件執行程式。 而事件驅動在不同的地方有不同的實現。瀏覽器 (前端) 和 Node.js (後端) 基於不同的技術實現了各自的事件迴圈。就 Ndoe.js 來說，事件就是交給 libuv 去處理 ; 至於瀏覽器的事件迴圈在 HTML 5 的規範中有定義。 事件迴圈 (event loop) 因為 Node.js 只有一個執行緒，所以當 libuv 把非同步事件處理完後，callback 要被丟回應用程式中排隊，等待主執行緒的 stack 為空的時候，才會開始執行。這個排隊的地方就是事件佇列 (event queue)。 libuv 會不斷檢查有沒有 callback 需要被執行，有的話分配到主執行緒結束手邊的程式後處理，因此這個過程稱為 『事件迴圈』。 事件迴圈(event loop) (Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈)\" 事件迴圈(event loop) (Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈) libuv 事件迴圈有哪些階段呢？ libuv 事件迴圈 (nexocode)\" libuv 事件迴圈 (nexocode) libuv 的事件迴圈共有六個階段，每個階段的作用如下： Timers：等計時器 (setTimeout、setInterval) 的時間一到，會把他們的 callback 放到這裡等待執行。 Pending callbacks：會把作業系統層級的錯誤給callback (TCP errors、sockets 連線被拒絕)。 Idle, prepare：內部使用。 Poll：最重要的一個階段。 如果 Queue 不為空，依次取出 callback 函數執行，直到 Queue 為空或是抵達系統最大限制。 如果 Queue 為空但有設置 「setImmediate」，就進入 check 階段。 如果 Queue 為空但沒有設置 「setImmediate」，就會在 Poll 階段等到直到 Queue 有東西或是 Timers 時間抵達。 Check：處理 setImmediate 的 callback。 Close callbacks：執行 close 事件的 callback，利如 socket.destroy()。 事件迴圈就是不斷重複以上階段。每個階段都有自己的 callback 佇列，在進入某個階段時，都會從所屬的佇列中取出 callback 來執行，當佇列為空或者被執行 callback 的數量達到系統的最大數量時，就會進入下一階段。 根據以上提到事件驅動、單執行緒和非同步、非阻塞的 I/O 處理特性，Node.js 很適合拿來開發 I/O 密集型應用程式，如影音串流、即時互動、在線聊天、遊戲、協作工具、股票行情等軟體。 ","date":"2022-03-30","objectID":"/node/:1:3","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"NPM NPM 是跟 Node.js 一起安裝的線上套件庫，可以下載各式各樣的 JavaScript 套件來使用，能解決 Node.js 代碼部署上的很多問題。 安裝好後，可以使用 npm -v 來檢查版本： $ npm -v 8.5.0 跟 NPM 息息相關的是 package.json 這個檔案，他是掌管專案資訊的重要檔案，我們可以使用 init 指令來設定 package.json： $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. .... 省略 .... Press ^C at any time to quit. package name: (message) demo version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: ian \u003c880831ian@gmail.com\u003e license: (ISC) name: 就是該專案的名字，它預設就是該目錄名。 description: 專案描述。 entry point: 專案切入點，這有點複雜，之後再說。 test command: 專案測試指令，之後說。 git repository: 專案原始碼的版本控管位置。 keywoard: 專案關鍵字 author: 專案作者，以 author-name author@email.com 寫之。 license: 專案版權。 設定好後，專案資料夾就會多一個 package.json 的檔案，打開後可以看到，是我們剛剛所設定好的資訊： { \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"ian \u003c880831ian@gmail.com\u003e\", \"license\": \"ISC\" } 接下來，要如何下載網路上的模組，要使用 install 指令來下載，我們下載 Node.js 最小又靈活的 Web 應用程式框架 express 來做示範： $ npm install express added 50 packages, and audited 51 packages in 1s 2 packages are looking for funding run `npm fund` for details found 0 vulnerabilities 下載好後，可以看到剛剛 package.json 檔案多了 dependencies 欄位，它裡面會紀錄我們安裝了哪些套件，所以未來我們想知道專案使用了哪些套件，我們可以從 dependencies 這個欄位知道。 { \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"ian \u003c880831ian@gmail.com\u003e\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"^4.17.3\" } } 除此之外，還會多一個 node_modules 資料夾，這個資料夾就會存放我們所下載的套件 $ ls node_modules/ accepts cookie-signature etag inherits mime-types qs setprototypeof array-flatten debug express ipaddr.js ms range-parser statuses body-parser depd finalhandler media-typer negotiator raw-body toidentifier bytes destroy forwarded merge-descriptors on-finished safe-buffer type-is content-disposition ee-first fresh methods parseurl safer-buffer unpipe content-type encodeurl http-errors mime path-to-regexp send utils-merge cookie escape-html iconv-lite mime-db proxy-addr serve-static vary 當我們都安裝好後，express 已經包在 node_modules 目錄內，在專案裡面，就可以使用 require(‘套件名稱‘) 來使用套件囉！ var express = require('express'); 因為這些套件都可以直接在網路上下載到，所以在推送 git 專案時，可以使用 .gitignore 來隱藏不想被 push 的檔案，當我們想要下載套件回來時，只要使用： $ npm install 就可以依照 package.json 裡面的 dependencies 來下載套件！ ","date":"2022-03-30","objectID":"/node/:2:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"REPL Node.js REPL (交互式解釋器)：表示一個電腦環境，類似 Windoes 系統的終端或是 Unix/Linux 的 Shell，我們可以在終端機上輸入命令，並接收系統的響應。 Node 自帶了交互式解釋器，可以執行以下任務： 讀取：讀取用戶輸入，解析輸入的 JavaScript 數據結構並儲存在內存中。 執行：執行輸入的數據結構。 顯示：輸出結果。 循環：循環以上任務直到用戶按下兩次的 ctrl+c 按鈕退出。 我們可以輸入以下命令來啟動 Node 的終端： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e 可以執行簡單的數學運算： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e 1+4 5 \u003e 5/2 2.5 \u003e 3*7 21 \u003e 4-3 1 \u003e 1 + (2*4) -5 4 \u003e 也可以將數據存在變數中，在需要時使用它。變數宣告需要使用 var 關鍵字，如果沒有使用關鍵字，會直接顯示出來。也可以使用 console.log() 來輸出變數 $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e x = 19 19 \u003e var y = 10 undefined \u003e x + y 29 \u003e console.log(\"Hello\") Hello undefined \u003e Node REPL 也支持輸入多行程式，我們試著寫一個 do-while 迴圈： Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e var x = 0 undefined \u003e do { ... x++; ... console.log(\"x:\" + x); ... } while (x\u003c5); x:1 x:2 x:3 x:4 x:5 undefined \u003e 也可以使用下底線(_)來獲得上一個程式的運算結果： $ node Welcome to Node.js v16.14.2. Type \".help\" for more information. \u003e var x = 10 undefined \u003e var y = 20 undefined \u003e x + y 30 \u003e var sum = _ undefined \u003e console.log(sum) 30 undefined \u003e ","date":"2022-03-30","objectID":"/node/:3:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"Express 框架 Node.js 在實作上不會單獨使用，通常會搭配框架去使用，像是 Express JS 後端框架，可以讓開發人員在寫同一個功能時，少寫很多程式的工具。 Express 是 Node.js 環境下提供的輕量後端架構，自由度極高，透過豐富的 HTTP 工具，能快速發開後端應用程式，它提供： 替不同 HTTP Method、不同 URL 路徑的 requests 編寫不同的處理方法。 透過整合「畫面」的渲染引擎來達到插入資料到樣板產生 response。 設定常見的 web 應用程式，例如：連線用的 Port 和產生 response 樣板的位置。 在 request 的處理流程中增加而外的中間層 (Middleware) 進行處理。 第一個 Express Hello world 程式： const express = require('express') const app = express() const port = 3000 app.get('/', (req, res) =\u003e { res.send('Hello World!') }) app.listen(port, () =\u003e { console.log(`Example app listening on port ${port}`) }) $ node app.js Example app listening on port 3000 使用 node 來啟動伺服器，並使用 Port 3000 來連線。應用程式指向 URL (/) 的路由，以 “Hello World!” 回應如果是其他路徑，res 就會回應 404 找不到。 ","date":"2022-03-30","objectID":"/node/:4:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"畫面 (view) 剛剛有提到說它可以使用整合「畫面」的渲染引擎來顯示到樣板，我們可以透過 --view 指令來產生樣板以及應用程式的目錄： $ express --view=pub create : public/ create : public/javascripts/ create : public/images/ create : public/stylesheets/ create : public/stylesheets/style.css create : routes/ create : routes/index.js create : routes/users.js create : views/ create : app.js create : package.json create : bin/ create : bin/www ","date":"2022-03-30","objectID":"/node/:4:1","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"路由 (router) 路由是判斷應用程式如何回應用戶端對特定端點的要求，而特定端點是一個 URL 或是路徑，與一個特定的 HTTP 要求方法 (GET、POST) 等，路由定義的結構如下： app.METHOD(PATH, HANDLER) 其中 app 是 express 的實例。 METHOD 是 HTTP 要求的方法。 PATH 是伺服器上的路徑。 HANDLER 是當路由相符時要執行的函數。 以下範例簡單說明不同 HTTP 要求的方法： 首頁中以 Hello World! 回應。 app.get('/', function (req, res) { res.send('Hello World!'); }); 對根路由 (/)（應用程式的首頁）發出 POST 要求時的回應： app.post('/', function (req, res) { res.send('Got a POST request'); }); 對 /user 路由發出 PUT 要求時的回應： app.put('/user', function (req, res) { res.send('Got a PUT request at /user'); }); 對 /user 路由發出 DELETE 要求時的回應： app.delete('/user', function (req, res) { res.send('Got a DELETE request at /user'); }); ","date":"2022-03-30","objectID":"/node/:4:2","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"參考資料 Node.js 官網 Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈 An Intro to Node.js That You May Have Missed Sequelize 透過 sequelize 來達成 DB Schema Migration 認識同步與非同步 — Callback + Promise + Async/Await 你懂 JavaScript 嗎？#23 Callback How to create JOIN queries with Sequelize ","date":"2022-03-30","objectID":"/node/:5:0","tags":["Node.js","實作","介紹"],"title":"Node.js 介紹","uri":"/node/"},{"categories":["codenotes"],"content":"本文章是使用 Go 來寫一個 Repository Restful API 的留言板，並且會使用 gin 以及 gorm (使用 Mysql)套件。 建議可以先觀看 Go 介紹 文章來簡單學習 Go 語言。 範例程式連結 點我 😘 版本資訊 macOS：11.6 Go：go version go1.18 darwin/amd64 Mysql：mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:0:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"實作 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"檔案結構 . ├── controller │ └── controller.go ├── go.mod ├── go.sum ├── main.go ├── model │ └── model.go ├── repository │ └── repository.go ├── router │ └── router.go └── sql ├── connect.yaml └── sql.go 我們來說明一下上面的資料夾個別功能與作用 sql：放置連線資料庫檔案。 controller：商用邏輯控制。 model：定義資料表資料型態。 repository：處理與資料庫進行交握。 router：設定網站網址路由。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:1","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"go.mod 一開始我們創好資料夾後，要先來設定 go.mod 的 module $ go mod init message go.mod 檔案 module message go 1.18 接著使用 go get 來引入 gin、gorm、mysql、yaml 套件 $ go get -u github.com/gin-gonic/gin $ go get -u gorm.io/gorm $ go get -u gorm.io/driver/mysql $ go get -u gopkg.in/yaml.v2 可以在查看一下 go.mod 檔案是否多了很多 indirect ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:2","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"main.go package main import ( \"fmt\" \"message/model\" \"message/router\" \"message/sql\" ) func main() { //連線資料庫 if err := sql.InitMySql(); err != nil { panic(err) } //連結模型 sql.Connect.AutoMigrate(\u0026model.Message{}) //sql.Connect.Table(\"message\") //也可以使用連線已有資料表方式 //註冊路由 r := router.SetRouter() //啟動埠為8081的專案 fmt.Println(\"開啟127.0.0.0.1:8081...\") r.Run(\"127.0.0.1:8081\") } 引入我們 Repository 架構，將 config、model、router 導入，先測試是否可以連線資料庫，使用 AutoMigrate 來新增資料表(如果沒有才新增)，或是使用 Table 來連線已有資料表，註冊網址路由，最後啟動專案，我們將 Port 設定成 8081。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:3","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"sql 我們剛剛有引入 yaml 套件，因為我們設定檔案會使用 yaml 來編輯 connect.yaml host:127.0.0.1username:rootpassword:\"密碼\"dbname:\"資料庫名稱\"port:3306 我們把 mysql 連線的資訊寫在此處。 sql.go (下面為一個檔案，但長度有點長，分開說明) package sql import ( \"io/ioutil\" \"fmt\" \"gopkg.in/yaml.v2\" \"gorm.io/gorm\" \"gorm.io/driver/mysql\" ) import 會使用到的套件。 var Connect *gorm.DB type conf struct { Host string `yaml:\"host\"` UserName string `yaml:\"username\"` Password string `yaml:\"password\"` DbName string `yaml:\"dbname\"` Port string `yaml:\"port\"` } func (c *conf) getConf() *conf { //讀取config/connect.yaml檔案 yamlFile, err := ioutil.ReadFile(\"sql/connect.yaml\") //若出現錯誤，列印錯誤訊息 if err != nil { fmt.Println(err.Error()) } //將讀取的字串轉換成結構體conf err = yaml.Unmarshal(yamlFile, c) if err != nil { fmt.Println(err.Error()) } return c } 設定資料庫連線的 conf 來讀取 yaml 檔案。 //初始化連線資料庫 func InitMySql() (err error) { var c conf //獲取yaml配置引數 conf := c.getConf() //將yaml配置引數拼接成連線資料庫的url dsn := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\", conf.UserName, conf.Password, conf.Host, conf.Port, conf.DbName, ) //連線資料庫 Connect, err = gorm.Open(mysql.New(mysql.Config{DSN: dsn}), \u0026gorm.Config{}) return } 初始化資料庫，會把剛剛讀取 yaml 的 conf 串接成可以連接資料庫的 url ，最後連線資料庫。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:4","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"router.go package router import ( \"message/controller\" \"github.com/gin-gonic/gin\" ) func SetRouter() *gin.Engine { //顯示 debug 模式 gin.SetMode(gin.ReleaseMode) r := gin.Default() v1 := r.Group(\"api/v1\") { //新增留言 v1.POST(\"/message\", controller.Create) //查詢全部留言 v1.GET(\"/message\", controller.GetAll) //查詢 {id} 留言 v1.GET(\"/message/:id\", controller.Get) //修改 {id} 留言 v1.PATCH(\"/message/:id\", controller.Update) //刪除 {id} 留言 v1.DELETE(\"/message/:id\", controller.Delete) } return r } 設定路由，版本 v1 網址是 api/v1 ，分別是新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function 。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:5","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"model.go package model import \"gorm.io/gorm\" func (Message) TableName() string { return \"message\" } type Message struct { Id int `gorm:\"primary_key,type:INT;not null;AUTO_INCREMENT\"` User_Id int `json:\"User_Id\" binding:\"required\"` Content string `json:\"Content\" binding:\"required\"` Version int `gorm:\"default:0\"` // 包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位 gorm.Model } 設定資料表的結構，使用 gorm.Model 預設裡面會包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:6","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"controller.go (下面為一個檔案，但長度有點長，分開說明) package controller import ( \"message/model\" \"message/repository\" \"net/http\" \"unicode/utf8\" \"github.com/gin-gonic/gin\" ) import 會使用到的套件。 查詢留言功能 func GetAll(c *gin.Context) { message, err := repository.GetAllMessage() if err != nil { c.JSON(http.StatusBadRequest, gin.H{\"message\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } func Get(c *gin.Context) { var message model.Message if err := repository.GetMessage(\u0026message, c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } GetAll() 會使用到 repository.GetAllMessage() 查詢並回傳顯示查詢的資料。 c.Param(\"id\") 是網址讀入後的 id，網址是http://127.0.0.1:8081/api/v1/message/{id} ，將輸入的 id 透過 repository.GetMessage() 查詢並回傳顯示查詢的資料。 新增留言功能 func Create(c *gin.Context) { var message model.Message if c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) \u003e= 20 { c.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"}) return } c.Bind(\u0026message) repository.CreateMessage(\u0026message) c.JSON(http.StatusCreated, gin.H{\"message\": message}) } 使用 Gin 框架中的 Bind 函數，可以將 url 的查詢參數 query parameter，http 的 Header、body 中提交的數據給取出，透過 repository.CreateMessage() 將要新增的資料帶入，如果失敗就顯示 http.StatusBadRequest，如果成功就顯示 http.StatusCreated 以及新增的資料。 修改留言功能 func Update(c *gin.Context) { var message model.Message if c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) \u003e= 20 { c.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"}) return } if err := repository.UpdateMessage(\u0026message, c.PostForm(\"Content\"), c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusOK, gin.H{\"message\": message}) } 先使用 repository.GetMessage() 以及 c.Param(\"id\") 來查詢此 id 是否存在，再帶入要修改的 Content ，透過 repository.UpdateMessage() 將資料修改，，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusOK 以及修改的資料。 刪除留言功能 func Delete(c *gin.Context) { var message model.Message if err := repository.DeleteMessage(\u0026message, c.Param(\"id\")); err != nil { c.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"}) return } c.JSON(http.StatusNoContent, gin.H{\"message\": \"刪除留言成功\"}) } 透過 repository.DeleteMessage() 將資料刪除，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusNoContent。 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:7","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"repository.go (下面為一個檔案，但長度有點長，分開說明) 所有的邏輯判斷都要在 controller 處理，所以 repository.go 就單純對資料庫就 CRUD： package repository import ( \"message/model\" \"message/sql\" ) import 會使用到的套件。 查詢留言資料讀取 //查詢全部留言 func GetAllMessage() (message []*model.Message, err error) { err = sql.Connect.Find(\u0026message).Error return } //查詢 {id} 留言 func GetMessage(message *model.Message, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Error return } 新增留言資料讀取 //新增留言 func CreateMessage(message *model.Message) (err error) { err = sql.Connect.Create(\u0026message).Error return } 修改留言資料讀取 //更新 {id} 留言 func UpdateMessage(message *model.Message, content, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Update(\"content\", content).Error return } 刪除留言資料讀取 //刪除 {id} 留言 func DeleteMessage(message *model.Message, id string) (err error) { err = sql.Connect.Where(\"id=?\", id).First(\u0026message).Delete(\u0026message).Error return } ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:1:8","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"Postman 測試 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢全部留言 - 成功(無資料) 查詢留言 成功(無資料)\" 查詢留言 成功(無資料) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:1","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢全部留言 - 成功(有資料) 查詢留言 成功(有資料)\" 查詢留言 成功(有資料) ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:2","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢{id}留言 - 成功 查詢{id}留言 成功\" 查詢{id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:3","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"查詢{id}留言 - 失敗 查詢{id}留言 失敗\" 查詢{id}留言 失敗 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:4","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"新增留言 - 成功 新增留言 成功\" 新增留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:5","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"修改{id}留言 - 成功 修改 {id}留言 成功\" 修改 {id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:6","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"修改{id}留言 - 失敗 修改 {id}留言 失敗\" 修改 {id}留言 失敗 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:7","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"刪除{id}留言 - 成功 刪除 {id}留言 成功\" 刪除 {id}留言 成功 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:8","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"執行結果 執行結果\" 執行結果 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:2:9","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"參考資料 基於Gin+Gorm框架搭建MVC模式的Go語言後端系統 ","date":"2022-03-27","objectID":"/go-restful-api-repository-messageboard/:3:0","tags":["Go","RESTful API","Mysql","Repository","實作","介紹"],"title":"用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)","uri":"/go-restful-api-repository-messageboard/"},{"categories":["codenotes"],"content":"什麼是 Go ? Go 全名是 go programming language 又被稱為 Golang，是因為 go 這個詞太廣泛，不易搜尋，所以也可以叫 Golang。 Go 是由 Google 開發並維護的編譯程式語言，支援垃圾回收與併發，由於開發人之一也是 C 語言的作者，所以 Go 也繼承了許多 C 的風格 其特點有以下幾點： 靜態型別：因爲靜態型別的特性，可以在編譯期間就進行完整的型別檢查，可以找出大部分的型別錯誤。 編譯速度：因為 Go 語言先天優勢是架構設計非常單純，並不像物件導向語言龐大，在編譯時不用相依其他的 library，因此讓他有更好的執行效率。 語法簡潔：Go 關鍵字不多，不到30幾個，因為其關鍵字不少也與 C 的關鍵字重複，學習更容易上手。 垃圾回收：Go 有自動內存回收機制，不需要由開發人員來管理。垃圾回收是一種記憶體管理機制。當程式所佔用記憶體不再被該程式給存取時，會借助垃圾回收演算法，將記憶體空間歸還給作業系統。 原生支援併發：Go 語言支持併發，只需要透過 go 關鍵字來開啟 goroutine 將可。goroutine 是 Go 語言實現併發的一種方式，在執行的過程需要少量的記憶體，來暫存自己的上下文，就可在不同的時間點來分段執行程式。並且有 channel 可以跟 goroutine 進行資料溝通。 靜態型別/動態型別 靜態型別的意思是指當宣告一個變數時，你必須同時宣告此變數所存放的資料型態為何 var age int // int var name string // string 動態型別指的是程式執行時，系統才可以看見的型別，什麼型別都可以 var i interface {} i = 18 i = \"Golang 程式設計\" 編譯式語言/直譯式語言 編譯式：當我們寫完程式時，我們需要將程式 compile (編譯) 成電腦看得懂的程式，再將程式拿去執行。 直譯式：當我們寫完程式時，直接使用直譯器一行一行翻譯成電腦語言並執行。 比較： 編譯式執行效率較佳 直譯式相對容易 Debug 編譯式語言編譯完後，可以直接在各類 OS 系統中執行，因為編譯完的程式，就是電腦看得懂的。 那我們大致了解 Go 後就來安裝 Go吧！ ","date":"2022-03-21","objectID":"/go/:1:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"安裝 Go 本次作業系統為 macOS，所以後續都以 macOS 為主，如果是使用其他的作業系統，可以直接到官網來下載。 macOS 可以用 brew 等工具來下載，但這次我使用官網直接下載 pkg 來安裝。 Go 官網下載位置\" Go 官網下載位置 下載完後，使用 go version 來檢查是否安裝成功： $ go version go version go1.18 darwin/amd64 接著我們來看一下他的環境變數，使用 go env，來查看： $ go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/ian_zhuang/Library/Caches/go-build\" GOENV=\"/Users/ian_zhuang/Library/Application Support/go/env\" GOEXE=\"\" GOEXPERIMENT=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GOMODCACHE=\"/Users/ian_zhuang/go/pkg/mod\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/ian_zhuang/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/go\" 這邊簡單的列出來，比較重要的是 GOPATH：他是有關管理程式碼和套件執行檔的地方，在 Go 1.8 版本以前，GOPATH 預設為空。從 1.8 以後，Go 安裝完後，都會直接給預設的路徑 說一下這個路徑的內容，我在依照預設的路徑，像我是在 Users/使用者/go，在 go 底下新增三個資料夾： src：主要放置專案的地方 pkg：套件主要儲存的資料夾 bin：存放編譯好的執行檔案 在 Go 1.11 後提供了 go modules 讓我們不一定要把專案程式碼放在 $GOPATH/src 中做開發，因此我們先來設定我在要放專案的資料夾，打開 .bash_profile： export GOPATH=你專案的路徑/goworkspace $ source .bash_profile 接著我們來實作第一隻 Go 程式吧，我們會依照官網的示範，但為了要介紹 modules 是什麼，所以會小修改內容。 ","date":"2022-03-21","objectID":"/go/:2:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"第一隻 Go 程式 我們依照官網的示範教學，先建立一個資料夾(要放在我們剛剛的 GOPATH 目錄下方歐)，來放我們第一個 Go 程式 “印出 Hello world” (程式碼可以從此處下載)： mkdir helloworld cd helloworld 接著下指令來新增 Go module： $ go mod init helloworld go: creating new go.mod: module helloworld 如果成功，會產生一個 go.mod 檔案，我們來看看內容有什麼： $ cat go.mod module helloworld go 1.18 go.mod 是用來定義 module 的文件，用來標示此 module 的名稱、所使用的 go 版本以及相依的 Go module。 我們分別再新增兩個資料夾，以及兩個 .go 檔，來建立我們範例所需要的環境： mkdir greeting cli touch greeting/greeting.go cli/say.go 到目前為止結構如下： . ├── cli │ └── say.go ├── go.mod └── greeting └── greeting.go 我們來修改一下 greeting.go 以及 say.go 程式碼吧。 greeting.go 是一個簡單的 package，用以顯示所傳入的字串 ; 而 say.go 則是以呼叫 greeting.go package 所提供的函式來顯示資料。 greeting.go 內容： package greeting import \"fmt\" func Say(s string) { fmt.Println(s) } say.go 內容： package main import ( \"helloworld/greeting\" ) func main(){ greeting.Say(\"Hello World\") } 順便來介紹一下程式裡面分別是什麼意思吧！ Package：package 主要分成兩種，一個是可執行，另一個則是可重複使用的，而 package main 就是可執行的檔案，像我們上面這個有包含 package main 的檔案，在編譯時，就會產生一個 say 的執行檔，電腦就是依照此檔案執行的。 Import：當我們寫程式時，一定會引入其他人寫的套件。而 Go 語言的標準函式庫為開發團隊先寫好，提供一些常用的功能，當然也可以使用其他第三方套件，還滿足內建以及標準函式庫的不足。我們在 greeting.go 裡面引入的 fmt 就是開發團隊寫好的，然而在 say.go 裡面引入的就是greeting.go ，我們就可以使用其內容的函式來做使用。 Main Function：每個 Go 語言的專案基本上都會有一個主程式，主程式裡的程式通常都為最核心的部分。 最後使用 go run say.go 來將此程式運行起來： $ go run say.go Hello World 就可以看到程式成功將 Hello World 給印出來拉！ ","date":"2022-03-21","objectID":"/go/:3:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"常見指令 接下來要簡單介紹一下常用的另外3個指令，分別是 go build、go install、go clean： go get：來下載套件到當前的模組，並安裝他們 $ go get github.com/fatih/color go: downloading github.com/fatih/color v1.13.0 .... 省略 .... go build：還記得我們前面說 Go 是編譯式程式，所以我們可以將程式用 go build 來編譯成電腦看得懂的執行檔歐，檔案會存放在當前目錄或是指定目錄中 ~ $ ls go.mod $ go build cli/say.go go.mod say $ ./say Hello World 多的這個 say 就是編譯後的執行檔，將他執行會顯示跟我們使用 run 來運行的一樣，顯示 Hello World。 go install：如果編譯沒有錯誤，一樣跟 build 會產生執行檔，不同的是，會將執行檔，產生於 $GOPATH/bin 內。 $ ls /Users/ian_zhuang/go/bin dlv go-outline gomodifytags goplay gopls gotests impl staticcheck $ go install $ ls /Users/ian_zhuang/go/bin dlv go-outline gomodifytags goplay gopls gotests hello impl staticcheck go clean：執行後會將 build 產生的檔案都刪除 (install 的不會) $ ls go.mod hello . $ go clean $ ls go.mod . ","date":"2022-03-21","objectID":"/go/:3:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"套件相依性管理 Go modules 提供的另一個方便的功能則是套件相依性管理，接下來實際透過以下指令來安裝套件： $ go get github.com/fatih/color go: downloading github.com/fatih/color v1.13.0 go: downloading github.com/mattn/go-isatty v0.0.14 go: downloading github.com/mattn/go-colorable v0.1.9 go: downloading golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c go: added github.com/fatih/color v1.13.0 go: added github.com/mattn/go-colorable v0.1.9 go: added github.com/mattn/go-isatty v0.0.14 go: added golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c 安裝成功，可以再查看一下 go.mod： module github.com/880831ian/go/helloworld go 1.18 require github.com/fatih/color v1.13.0 require ( github.com/mattn/go-colorable v0.1.12 // indirect github.com/mattn/go-isatty v0.0.14 // indirect golang.org/x/sys v0.0.0-20220319134239-a9b59b0215f8 // indirect ) 會多了下面這些 require github.com/fatih/color v1.13.0 代表目前專案使用 v1.13.0 版本的 github.com/fatih/color 下面的 indirect 指的是被相依的套件所使用的 package 接著我們將 greeting.go、say.go 兩個檔案修改一下，使用我們剛剛所安裝的 package： greeting.go package greeting import ( \"fmt\" \"github.com/fatih/color\" ) func Say(s string) { fmt.Println(s) } func SayWithRed (s string) { color.Red(s) } func SayWithBlue (s string) { color.Blue(s) } func SayWithYellow (s string) { color.Yellow(s) } 我再多 import 了剛剛的 github.com/fatih.color，並使用該套件的函式 color 來分別顯示 Red、Blud、Yellow 三種顏色。 say.go package main import ( \"github.com/880831ian/go/helloworld/greeting\" ) func main(){ greeting.Say(\"Hello World\") greeting.SayWithRed(\"Hello World\") greeting.SayWithBlue(\"Hello World\") greeting.SayWithYellow(\"Hello World\") } 我們將 greeting 三種顯示顏色的函式帶入。 一樣我們來運行一下程式，來看看結果如何，這次我們直接編譯，使用 go build 來編譯，最後直接執行產生的執行檔： $ go build cli/say.go $ ./say Hello World Hello World //紅色 Hello World //藍色 Hello World //黃色 由於 Makedown 沒辦法於程式碼區域顯示正確顏色，用註解標示一下XD ","date":"2022-03-21","objectID":"/go/:3:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"變數 在使用變數做宣告時，要注意以下幾個 Go 保留字，不能拿來當變數名稱，其 Go 有三種宣告的方式： Go 保留字，不能拿來當變數名稱\" Go 保留字，不能拿來當變數名稱 ","date":"2022-03-21","objectID":"/go/:4:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"使用 := 來宣告 表示之前沒有進行宣告過。這是 Go 中最常見的變數宣告方式，但不能用縮寫方式來定義變數 (foo := bar) ，因為 package scope 的變數都是以 keyword 作為開頭。且只能在 function 中使用。 func main (){ a := \"bar\" b := 4 c := true // 也可以簡寫成這樣 d,e,f := \"bar\",4,true fmt.Println(a,b,c); fmt.Println(d,e,f); } $ go run . bar 4 true bar 4 true ","date":"2022-03-21","objectID":"/go/:4:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"先宣告資料型態 當不知道變數的起始值，或是需要在 package scope 中宣告變數時可以使用。 var a string var b int // 也可以簡寫成這樣 var ( c string d float64 ) func main (){ a = \"Hello\" b = 123 c = \"ian\" d = 3.5 fmt.Println(a,b,c,d) } ⚠️ 不建議把變數寫在全域變數中 ⚠️ $ go run . Hello 123 ian 3.5 ","date":"2022-03-21","objectID":"/go/:4:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"直接宣告並賦值 func main (){ var ( a string = \"Hello\" b int = 9999 ) fmt.Println(a,b) } $ go run . Hello 9999 ","date":"2022-03-21","objectID":"/go/:4:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"常見宣告錯誤 重複宣告變數 func main (){ name := \"ian\" name := \"pinyi\" } $ go run . # github.com/880831ian/go/test ./test.go:4:2: name declared but not used ./test.go:5:7: no new variables on left side of := 在 main 函式外賦值 var a int b := \"Hello\" func main (){ fmt.Println(a,b) } $ go run . # github.com/880831ian/go/test ./test.go:6:1: syntax error: non-declaration statement outside function body 我們可以在 main 函式外宣告變數，但無法在 main 函式外賦值 沒有宣告就使用變數 func main (){ a = 123 b = true fmt.Println(a,b) } $ go run . # github.com/880831ian/go/test ./test.go:6:2: undefined: a ./test.go:7:2: undefined: b ./test.go:8:14: undefined: a ./test.go:8:16: undefined: b ","date":"2022-03-21","objectID":"/go/:4:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 資料型態 我們在學習 Go 語言之前，要先了解一下基本的資料型態，可以簡單分為 字串、字符、整數、浮點數、布林值、映射 ","date":"2022-03-21","objectID":"/go/:5:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"字串 String 在 Go 語言中，字串必須用雙引號給匡起來，也可以使用反引號來宣告。用雙引號刮起來的字串不能包含換行，但可以包含跳脫字元，例如 \\n 、\\t 。由於反引號內包含的是原始字串，可以跨越多行，所以跳脫符號在原始字串中沒有任何含義。 func main() { var name = \"ian\" fmt.Printf(\"資料型態 name : %v(%T)\\n\", name,name) var address = `台中市太平區` fmt.Printf(\"資料型態 address : %v(%T)\\n\", address,address) } $ go run . 資料型態 name : ian(string) 資料型態 address : 台中市太平區(string) ","date":"2022-03-21","objectID":"/go/:5:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"字符 Character 字串中的每一個元素叫做字符，字符會使用單引號匡起來，像是 \"abc\" 這個字串，其中 'a'、'b'、'c' 就是字符，可以從字串元素中來獲得字符。 Go 語言的字符有以下兩種： 一種叫 byte 類型，可以叫做 uint8 類型，代表 ASCll 碼的一個字符。 另一種是 rune 類型，代表一個 UTF-8 字符，當需要處理中文、日文或是其他複合字符時，就會使用到 rune 類型。rune 類型等於 int32 類型。 func main (){ var a byte = 'A' var b rune = '嗨' fmt.Printf(\"%c %c\\n\",a,b) //%c 所表示的字符 fmt.Printf(\"%d(%T) %d(%T)\\n\",a,a,b,b) //%d 十進制表示,%T 輸出型態 fmt.Printf(\"%x %x\\n\",a,b) //%x 十六進制表示 fmt.Printf(\"%U %U\\n\",a,b) //%U 輸出格式為 Unicode 格式:U+hhhh的字串 } $ go run . A 嗨 65(uint8) 21992(int32) 41 55e8 U+0041 U+55E8 ","date":"2022-03-21","objectID":"/go/:5:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"整數 Integer 整數用於儲存整數。 Go 具有多種大小不一的內建整數型別，用來儲存有號數和無號數。 有號數 型別 大小 範圍 int 取決平台 取決平台 int 8 8 bits -128 到 127 int 16 16 bits -2^15 到 2^15-1 int 32 32 bits -2^31 到 2^31-1 int 64 64 bits -2^63 到 -2^63-1 無號數 型別 大小 範圍 uint 取決平台 取決平台 uint 8 8 bits 0 到 255 uint 16 16 bits 0 到 2^16-1 uint 32 32 bits 0 到 2^32-1 uint 64 64 bits 0 到 -2^64-1 int 、 uint 的型別大小取決於平台。在 32 位元系統上，它大小為 32 位元，64 位元系統上，它的大小為 64 位元。 使用整數值時，除非確定會用到的大小跟範圍才使用有號數及無號數，否則應該都使用 int 資料型別。 func main() { var myInt8 int8 = 97 var myInt = 1200 var myUint uint = 500 var myOctalNumber = 034 var myHexNumber = 0xFF fmt.Printf(\"%d, %d, %d, %#o, %#x\\n\", myInt8, myInt, myUint, myOctalNumber, myHexNumber) } $ go run . 97, 1200, 500, 034, 0xff 在 Go 中，也可以使用前綴 0 來宣告八進制數字，或是使用 0x 來宣告十六進制數字。 ","date":"2022-03-21","objectID":"/go/:5:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"浮點數 Float 浮點數型別用於儲存小數部分的數字。Go 有兩種浮點數型別： float32：在記憶體中佔用32位元，並以單精度浮點數格式儲存。 float64：在記憶體中佔用64位元，並以雙精度浮點數格式儲存。 浮點數的預設是 float64，除非初始化有為浮點數變數指定型別，否則編譯器將判定為 float64。 func main() { var a = 245.4664 var b float32 = 1452.34 fmt.Printf(\"%f(%T)\\n%f(%T)\\n\", a,a,b,b) } $ go run . 245.466400(float64) 1452.339966(float32) ","date":"2022-03-21","objectID":"/go/:5:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"布林值 Bool Go 提供了一種稱為 bool 的資料型別來儲存布林值。它有兩個可能的值：true 和 false。 func main() { var a = true var b bool = false fmt.Printf(\"%v(%T)\\n%v(%T)\\n\", a,a,b,b) } $ go run . true(bool) false(bool) 布林型別也可以使用運算子 \u0026\u0026 (與,and)、|| (和,or)、! (否定) func main() { var a = 4 \u003c= 7 var b = 10 != 10 var c = 10 \u003e 20 \u0026\u0026 5 == 5 var d = 2 * 2 == 4 || 10 / 3 == 3 fmt.Printf(\"%v\\n%v\\n%v\\n%v\\n\", a,b,c,d) } $ go run . true false false true ","date":"2022-03-21","objectID":"/go/:5:5","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"映射 Map 映射 (Map) 是 Go 內建的類型，是一種鍵值(key-value)的集合，可以透過 key 快速查詢並找到數據。 func main (){ var map3 = map[int]string{99 : \"Go\", 87 : \"Python\", 79 : \"Java\", 93: \"Html\"} fmt.Println(map3) fmt.Println(\"map3[99] =\",map3[99],\"map3[79] =\",map3[79]) map3[79] = \"PHP\" fmt.Println(\"修改數據後，map3[99] =\",map3[99],\"map3[79] =\",map3[79]) } map[79:Java 87:Python 93:Html 99:Go] map3[99] = Go map3[79] = Java 修改數據後，map3[99] = Go map3[79] = PHP ","date":"2022-03-21","objectID":"/go/:5:6","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"數字型別的運算 Go 提供了多種用於數字、浮點數型別執行運算的運算子 算術運算子：+、-、*、/、% 比較運算子：==、!=、\u003c、\u003e、\u003c=、\u003e= 位元運算子：\u0026、 |、 ^、 \u003c\u003c、\u003e\u003e 遞增和遞減運算子：++、-- 賦值運算子：+=、-=、*=、/=、%=、\u003c\u003c=、\u003e\u003e=、\u0026=、|=、^= import ( \"fmt\" \"math\" ) func main() { var a, b = 4, 5 var res1 = (a + b) * (a + b) / 2 a++ b += 10 var res2 = a ^ b var r = 3.5 var res3 = math.Pi * r * r fmt.Printf(\"res1 : %v, res2 : %v, res3 : %v\\n\", res1, res2, res3) } res1 : 40, res2 : 10, res3 : 38.48451000647496 ","date":"2022-03-21","objectID":"/go/:5:7","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"型別轉換 Go 有一個強型別系統，它不允許混合型別。舉例來說：不能把 int 變數加到 float64 變數中，也不能將 int 變數加到 int64 變數中。 func main() { var a int64 = 4 var b int = int(a) var c int = 500 fmt.Println(a, b,a+c) } $ go run . # command-line-arguments ./.:11:19: invalid operation: a + c (mismatched types int64 and int) 就會跳出錯誤說明別不同，無法直接做運算，那要怎麼辦呢！？ 使用型別轉換，將型別值轉成相同的 func main() { var a int64 = 4 var b int = int(a) var c int = 500 fmt.Println(a, b,int(a)+c) } $ go run . 4 4 504 一般將值 v 轉換為型別 T 的語法是 T(V) 。 ","date":"2022-03-21","objectID":"/go/:5:8","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 資料結構 ","date":"2022-03-21","objectID":"/go/:6:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"指標 Pointer 指標是程式語言中的資料結構及其物件或變數，用來表示或儲存記憶體位址，這個位址的值直接指向存在該位址物件的值。 Go 支持指標，指標的聲明方式為 *T，可以藉由變數名稱前面加 \u0026 來獲得變數的位址，由於 Go 支持 GC ，在 Go 語言中不支持指標的運算。 表示法 使用 \u0026 來獲得指標位址 使用 * 來獲得指標所指向的值 func main (){ var a int = 2 fmt.Println(\"a 位址 = \",\u0026a) fmt.Printf(\"a 的值 = %v\\n\",a) var pInt *int = \u0026a fmt.Printf(\"pInt = %v\\n\", pInt); fmt.Printf(\"pInt 位址 = %v\\n\",\u0026pInt); fmt.Printf(\"pInt 指向的值 = %v\\n\",*pInt); } $ go run . a 位址 = 0xc0000b2008 a 的值 = 2 pInt = 0xc0000b2008 pInt 位址 = 0xc0000ac020 pInt 指向的值 = 2 ","date":"2022-03-21","objectID":"/go/:6:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"陣列 Array 我們已經學會要怎麼宣告變數，以及如何使用變數來儲存值。但當我們今天想要儲存多個數值，使用原本的方式，需要創建許多變數才能儲存，因此有了陣列可以來儲存大量資料。 陣列 (Array) 是由同類型的元素集合所組成的資料結構，分配一塊連續的記憶體來儲存。利用元素的索引可以計算出該元素所對應的儲存位址。 func main (){ var a [2] float32 a [0] = 1.4 a [1] = 3.14 // 也可以寫成這樣 var b = [] int{10,20,99,333} fmt.Println(a,b) fmt.Println(len(a),len(b)) } $ go run . [1.4 3.14] [10 20 99 333] 2 4 上面有提到他會分配連續記憶體來儲存，我們來看看他是怎麼存的！ func main (){ a := [...]int{1, 2, 3} fmt.Printf(\"a 的記憶體分配位置 %p \\n\", \u0026a) fmt.Printf(\"陣列 a 的索引 0 記憶體分配位置 %p \\n\", \u0026a[0]) fmt.Printf(\"陣列 a 的索引 1 記憶體分配位置 %p \\n\", \u0026a[1]) fmt.Printf(\"陣列 a 的索引 2 記憶體分配位置 %p \\n\", \u0026a[2]) } $ go run . a 的記憶體分配位置 0xc0000180f0 陣列 a 的索引 0 記憶體分配位置 0xc0000180f0 陣列 a 的索引 1 記憶體分配位置 0xc0000180f8 陣列 a 的索引 2 記憶體分配位置 0xc000018100 ","date":"2022-03-21","objectID":"/go/:6:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"切片 Slice 前面提到陣列的使用，陣列使用上是實值類型以及陣列長度不可變的情況下，間接限制了使用場景。 切片 (slice) 是 Go 對陣列在進行一層的封裝，是一個擁有相同類型元素的可變長度序列，可以非常靈活運用，自動擴容，可以快速且方便的操作數據集合。 func main (){ a := [5]int{55, 75, 58, 60, 66} b := a[1:4] //基於 a 陣列創建切片，等於 b 包含 a[1],a[2],a[3] fmt.Printf(\"%v(%T)\\n\",b,b) fmt.Printf(\"len = %v\\n\",len(b)) fmt.Printf(\"cap = %v\\n\",cap(b)) } [75 58 60]([]int) len = 3 cap = 4 len(b) 表示可見元素有幾個(直接打印元素看到的元素個數)，而 cap(b) 表示所有元素有幾個。 [1:4] 代表從第二個元素開始 (0為第一個元素，1位第二的元素)，取到第4個元素 (下標為 4-1=3，下標3代表第四個元素) 使用 make 創建切片 func main (){ a := make([]int,5,10) //創建長度 5,容量 10 的切片 fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) } a = [0 0 0 0 0], len(a) = 5, cap(a) = 10 使用 make 創建長度5 ,容量 10 的切片 使用 append 來達成新增元素 func main (){ a := make([]int,2,2) //創建長度 5,容量 10 的切片 fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) fmt.Printf(\"指標為 %p\\n\", a) a = append(a, 10) fmt.Printf(\"a = %v, len(a) = %v, cap(a) = %v\\n\",a,len(a),cap(a)) fmt.Printf(\"擴容後指標 = %p 改變\\n\", a) } a = [0 0], len(a) = 2, cap(a) = 2 指標為 0xc000014080 a = [0 0 10], len(a) = 3, cap(a) = 4 擴容後指標 = 0xc000022080 改變 ","date":"2022-03-21","objectID":"/go/:6:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"結構 Struct 我們介紹的變數都是儲存單一的值或是多個相同型態的值，那如果要用變數表示較複雜的概念，像是紀錄一個人的名字、年齡或是身高時，由於這些是不同的資料型態，所以要記錄下來時，就必須使用不同的容器，這裡會介紹 Go 語言中的結構 Struct： 建立結構 type Student struct { Id int Name string Score float64 } func main() { student := Student{1, \"ian\", 89.4} fmt.Println(student) } $ go run . {1 ian 89.4} 我們先宣告一個名為 Student 的 struct 結構，裡面屬性有 Id 和 Name 以及 Score，再以此結構宣告一個變數 student 並填入屬性，以顯示不同資料型態的值。 ","date":"2022-03-21","objectID":"/go/:6:4","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 控制流程 ","date":"2022-03-21","objectID":"/go/:7:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"if 結構裡會有一個條件，這個條件是個布林值，如果為 true，則會執行括號裡的程式碼，相反的，如果為 false，則會直接跳過： func main (){ var x = 2 var y = 1 fmt.Println(\"x = \",x,\",y = \",y) if x==y { fmt.Printf(\"%v 等於 %v\\n\",x,y) } fmt.Printf(\"%v 不等於 %v\\n\",x,y) } $ go run . x = 2 ,y = 1 2 不等於 1 ","date":"2022-03-21","objectID":"/go/:7:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"switch switch 其目的是簡化 if 的條件，swtich 會檢查符合的條件，並且執行條件內的程式碼，如果都沒有符合，則會執行 default 內的程式碼： func main (){ x := 12 switch { case x \u003c 10: fmt.Printf(\"%v 小於 10\\n\",x) case x \u003c 20: fmt.Printf(\"%v 大於等於10, 小於 20\\n\",x) default: fmt.Printf(\"%v 大於 20\\n\",x) } } $ go run . 12 大於等於10, 小於 20 ","date":"2022-03-21","objectID":"/go/:7:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 迴圈 迴圈是每個程式語言必備的函式，藉以迴圈來達成反覆或是循環的動作。而 Go 語言的迴圈只有使用 for 迴圈來表達三種不同的迴圈 (for、while、loop)： func main (){ for i := 0 ; i \u003c= 10 ; i++ { fmt.Println(i) } } $ go run . 0 1 2 3 4 5 6 7 8 9 10 break 也可以使用 break，依條件需求讓迴圈提早跳出結束： func main (){ for i := 0 ; i \u003c= 5 ; i++ { if i \u003e 3 { break } fmt.Println(i) } } $ go run . 0 1 2 3 Continue 或是使用 continue 若符合條件，便會跳過到此迴圈，直接進入下個迭代： func main (){ for i := 1; i \u003c= 10; i++ { if i%2 == 0 { continue } fmt.Println(i) } } $ go run . 1 3 5 7 9 GoTo 使用 goto 可以無條件轉移到程式中指定的行 func main (){ fmt.Println(\"1\") fmt.Println(\"2\") goto labele1 fmt.Println(\"3\") labele1: fmt.Println(\"4\") fmt.Println(\"5\") fmt.Println(\"6\") } $ go run . 1 2 4 5 6 ","date":"2022-03-21","objectID":"/go/:8:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 方法 Method Go 語言不像 Python 有 class ，但還是有提供可以在某種型態上定義方法(method)，method 其實是作用在接收器 (receiver) 上的一種函式，接收器要是某一種型別的變數，所以其實 method 也算是一種特殊型別的函式。 type Vertex struct { x,y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.x * v.x + v.y * v.y) } func main() { v := Vertex{5,12} fmt.Println(v.Abs()) } $ go run . 13 一開始先宣告一個名為 Vertex 結構型態，裡面的屬性包含 ｘ、y (float64)，接著就是撰寫一個 method 了，這個 method 是以 Vertex 作為接收器， method 名稱是 Abs，最後回傳浮點數，接著 method 裡頭，即為對接收器的運算並回傳值。 我們來看看如果使用 function 要怎麼來達成 方法 (Method) vs 函式 (Function) type Vertex struct { x, y float64 } func Abs(v Vertex) float64{ return math.Sqrt(v.x * v.x + v.y * v.y) } func main () { v := Vertex{5,12} fmt.Println(Abs(v)) } $ go run . 13 ","date":"2022-03-21","objectID":"/go/:9:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Go 介面 Interface Interface 的概念有點像是藍圖，先定義某個方法的名稱 (function name)、會接收到的參數以及型別 (list of argument types)、會回傳的值與型別 (list of return types)。定義好藍圖之後，並不用去管實作的細節，實作的細節會由每個型別自行定義實作。 empty interface 沒有定義任何方法的 interface 稱作 empty interface，由於所有的 types 都能夠實作 empty interface，因此它的值會是 any type：(因為目前沒有被賦值，所以都會回傳 nil) type value interface{} func main() { var v value describe(v) // (\u003cnil\u003e, \u003cnil\u003e) v = 42 describe(v) //(42, int) v = \"hello\" describe(v) // (hello, string) } func describe(v value) { fmt.Printf(\"(%v, %T)\\n\", v, v) } $ go run . value is \u003cnil\u003e type is \u003cnil\u003e type Person interface { getFullName() string getSalary() int } type Employee struct { firstName string lastName string salary int } func (e Employee) getFullName() string { return e.firstName + \" \" + e.lastName } func (e Employee) getSalary() int { return e.salary } func main() { var p Person = Employee{\"ian\", \"Zhuang\", 2000} fmt.Printf(\"full name : %v ,Salary : %v\\n\", p.getFullName(),p.getSalary()) } $ go run . full name : ian Zhuang ,Salary : 2000 ","date":"2022-03-21","objectID":"/go/:10:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Goroutine 有人把 Go 比作 21 世紀的 C 語言，第一是因為 Go 語言設計簡單，第二，21 世紀最重要的就是並行程式設計，而 Go 從語言層面就支援了併發。 Goroutine 是 Go 語言實現併發的一種方式。 Goroutine 是一種非常輕量級的執行緒，它是Go語言併發設計的核心。執行 Goroutine 只需極少的記憶體，可同時執行成千上萬個併發的任務。 ","date":"2022-03-21","objectID":"/go/:11:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"單執行緒 我們先來看看一般的單執行緒 func say(s string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { say(\"world\") say(\"hello\") } $ go run . world world hello hello 在單執行緒下，每行程式碼都會依照順序執行。 單執行緒 (Go 的並發：Goroutine 與 Channel 介紹)\" 單執行緒 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:1","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"多執行緒 在多執行緒下，最多可以同時執行與 CPU 數相等的 Goroutine。要如何使用多執行緒，使用 goroutine 來執行多併發，只要使用 go 這個關鍵字來執行 func 就可以了 ! func say(s string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\"world\") say(\"hello\") } $ go run . hello world world hello 如此一來, say(\"world\") 會跑在另一個執行緒(Goroutine)上，使其並行執行。 多執行緒 (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:2","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"等待 多執行緒下，經常需要處理的是執行緒之間的狀態管理，其中一個經常發生的事情是等待。 例如A執行緒需要等B執行緒計算並取得資料後才能繼續往下執行，在這情況下等待就變得十分重要。我們會介紹三個等待的方式，並說明其缺點。 time.sleep：休眠指定時間 sync.WaitGroup：等待直到指定數量的 Done() 呼叫 Channel 阻塞： Channel 阻塞機制，使用接收時等待的特性避免執行緒繼續執行 time.sleep 使 Goroutine 休眠，讓其他的 Goroutine 在 main 結束前有時間執行完成。 func say(s string) { for i := 0; i \u003c 2; i++ { fmt.Println(s) } } func main() { go say(\"world\") go say(\"hello\") time.Sleep(5 * time.Second) } $ go run . world world hello hello 缺點：休息指定時間可能會比 Goroutine 需要執行的時間長或短，太長會耗費多餘的時間，太短會使其他 Goroutine 無法完成。 time.sleep (Go 的並發：Goroutine 與 Channel 介紹)\" time.sleep (Go 的並發：Goroutine 與 Channel 介紹) sync.WaitGroup func say(s string, wg *sync.WaitGroup) { defer wg.Done() for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { wg := new(sync.WaitGroup) wg.Add(2) go say(\"world\", wg) go say(\"hello\", wg) wg.Wait() } $ go run . hello world world hello 在程式碼尾端加上 wg.Wait()，需要讓他達成一些條件，才可以往後執行，而這個條件，就是收到 wg.Done() 的呼叫次數。而這個次數，即是 wg.Add(2) 裡的數字2。 優點：避免時間預估的錯誤 缺點：需要手動配置對應的數量 sync.WaitGroup (Go 的並發：Goroutine 與 Channel 介紹)\" sync.WaitGroup (Go 的並發：Goroutine 與 Channel 介紹) Channel 阻塞 Channel 原為 Goroutine 溝通時使用的，但因其阻塞的特性，使其可以當作等待 Goroutine 的方法。 func say(s string, c chan string) { for i := 0; i \u003c 2; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } c \u003c- \"FINISH\" } func main() { ch := make(chan string) go say(\"world\", ch) go say(\"hello\", ch) \u003c-ch \u003c-ch } $ go run . hello world hello world 兩個 Goroutine ( say(\"world\", ch) 、 say(\"hello\", ch) ) ，因此需要等待兩個 FINISH 推入 Channel 中才能結束 Main Goroutine。 優點：避免時間預估的錯誤、語法簡潔 Channel 阻塞 (Go 的並發：Goroutine 與 Channel 介紹)\" Channel 阻塞 (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:11:3","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"Channel Channel 有兩個強大的處理能力，等待以及變數共享。Channel 可以想成一條管線，這條管線可以推入數值，並且也可以將數值拉取出來。 因為 Channel 會等待至另一端完成推入/拉出的動作後才會繼續往下處理，這樣的特性使其可以在 Goroutines 間可以同步的處理資料或是剛剛提到的等待 Channel 基本操作 ch := make(chan int) //創建一個Channel ch ch \u003c- u //將值u傳送到 Channel ch裡 v := \u003c- ch //從Channel ch中接收數據 ，並且將其賦值給變數v close(ch) //關閉channel 多執行緒下的共享變數 在執行緒間使用同樣的變數時，最重要的是確保變數在當前的正確性，在沒有控制的情況下極有可能發生問題。 func main() { total := 0 for i := 0; i \u003c 1000; i++ { go func() { total++ }() } time.Sleep(time.Second) fmt.Println(total) } $ go run . 986 為什麼會明明是用for 跑 1000 累加，但最後只有 900 多呢？我們來看一下下面的例子 多執行緒下的共享變數 - 錯誤 (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒下的共享變數 - 錯誤 (Go 的並發：Goroutine 與 Channel 介紹) 假設目前加到28，在多執行緒的情況下： goroutine1 取值 28 做運算 goroutine2 有可能在 goroutine1 做 total++ 前就取 total 的值，因此有可能取到 28 這樣的情況下做兩次加法的結果會是 29 而非 30 在多個 goroutine 裡對同一個變數total做加法運算，在賦值時無法確保其為安全的而導致運算錯誤，此問題稱為 競爭危害 (Race condition)。 使用 Channel 來保證變數的安全性 func main() { total := 0 ch := make(chan int, 1) ch \u003c- total for i := 0; i \u003c 1000; i++ { go func() { ch \u003c- \u003c-ch + 1 }() } time.Sleep(time.Second) fmt.Println(\u003c-ch) } $ go run . 1000 goroutine1 拉出 total 後，Channel 中沒有資料了 因為 Channel 中沒有資料，因此造成 goroutine2 等待 goroutine1 計算完成後，將 total 推入 Channel goroutine2 等到 Channel 中有資料，拉出後結束等待，繼續做運算 多執行緒下的共享變數 - Channel (Go 的並發：Goroutine 與 Channel 介紹)\" 多執行緒下的共享變數 - Channel (Go 的並發：Goroutine 與 Channel 介紹) ","date":"2022-03-21","objectID":"/go/:12:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"參考資料 Go 官網 golang後端入門分享 從一知半解到略懂 Go modules 30天就Go(3)：操作指令及Hello World! Golang 基本型別、運算子和型別轉換 Go語言字符類型（byte和rune） golang初探 Go 的並發：Goroutine 與 Channel 介紹 ","date":"2022-03-21","objectID":"/go/:13:0","tags":["Go","實作","介紹"],"title":"Go 介紹","uri":"/go/"},{"categories":["codenotes"],"content":"什麼是 Docker ? Docker 是一種軟體平台，它可以快速建立、測試和部署應用程式。為什麼可以快速建立呢？因為 Docker 會將軟體封裝到名為『容器』的標準單位。其中會包含程式庫、系統工具、程式碼、執行軟體所需的所有項目。 剛剛有提到容器 (Container)，是一種虛擬化技術，它高效率虛擬化及易於遷移和擴展的特性，非常適合現代雲端的開發及佈署。那 Container 與傳統的虛擬機有什麼差別呢？我們來看看下面這張圖 Container 與 VM 的差異\" Container 與 VM 的差異 可以看到 Container 是以應用程式為單位，而 VM 則是以作業系統為單位。Container 是一個封裝了相依性資源與應用程式的執行環境 ; VM 則是一個配置好 CPU、RAM 與 Storage 的作業系統，為了更好的做區別，我把 Container、VM 兩個差別用表格來說明～ 區別比較 Container VM 單位 應用程式 作業系統 適用服務 多使用於微服務 使用較大型的服務 硬體資源 是以程式為單位，需要的硬體資源很少 VM 會先佔用 CPU、RAM 等等硬體資源，不管有沒有使用都會先佔用 造成衝突 Container 間是彼此隔離的，因此在同一台機器可以執行不同版本的服務 會因為版本不同造成環境衝突 系統支援數量 單機支援上千個容器 一般最多幾十個 優點 1 . Image 較小，通常都幾MB 2 . 啟動速度快，通常幾秒就可以生成一個 Container 3 . 更新較為容易，只需要利用新的 Image 重新啟動就會更新了 1 . 因為硬體層以上都虛擬化，因此安全性相對較高 2 . 系統選擇較多，在 VM 可以選擇不同的OS 3 . 不需要降低應用程式內服務的耦合性，不需要將程式內的服務個別拆開來部署 缺點 1 . 安全性較 VM 差，因為環境與硬體都與本機共用 2 . 在同一台機器中，每一個 Container 的 OS 都是相同的，無法一個為 Windows、一個為 Linux，還是依賴 Host OS 3 . Container 通常會切成微服務的方式作部署，在各元件中的網路連結會比較複雜 1 . Image 的大小通常 GB 以上，比 Container 大很多 2 . 啟動速度通常要花幾分鐘，因此服務重啟速度較慢 3 . 資源使用較多，因為不只程式本身，還要將一部分資源分給 VM 的作業系統 總結 更快速的交付和部署：對於開發和維運人員來說，最希望就是一次建立或設定，可以再任意地方正常運行。開發者可以使用一個標準的映像檔來建立一套開發容器，開發完成之後，維運人員可以直接使用這個容器來部署程式。Docker 容器很輕很快！容器的啟動時間都是幾秒中的事情，大量地節約開發、測試、部署的時間。 更有效率的虛擬化：Docker 容器的執行不需要額外的虛擬化支援，它是核心層級的虛擬化，因此可以實作更高的效能和效率。 更輕鬆的遷移和擴展：Docker 容器幾乎可以在任意的平台上執行，包括實體機器、虛擬機、公有雲、私有雲、個人電腦、伺服器等。 這種兼容性可以讓使用者把一個服務從一個平台直接遷移到另外一個。 更簡單的管理：使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分發和更新，從而實作自動化並且有效率的管理。 ","date":"2022-03-14","objectID":"/docker/:1:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 基本概念 映像檔 (Image) 容器 (Container) 倉庫 (Repository) 這三個是 Docker 最基本的組成，了解後就可以知道整個 Docker 的生命週期。 ","date":"2022-03-14","objectID":"/docker/:2:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"映像檔 (Image) Docker 映像檔是一個唯獨的模板。 例如：一個映像檔可在包含一個完整的 Linux 作業系統環境，裡面可以只安裝 Nginx 或使用者會使用到的其他應用程式。 我們會使用映像檔來建立 Docker 的容器 (Container) ，Docker 也提供很簡單的機制來建立映像檔或是更新現有的映像檔，也可以去下載別人已經做好的映像檔。 ","date":"2022-03-14","objectID":"/docker/:2:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"容器 (Container) Docker 是利用容器來執行應用程式。 每一個容器都是由映像檔所建立的的執行程式。它可以被啟動、開始、停止、刪除。且每一個容器都是相互隔離的，不會相互影響。 ","date":"2022-03-14","objectID":"/docker/:2:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"倉庫 (Repository) 倉庫是集中放置映像檔的所在地，倉庫分為公開倉庫 (Public) 和 私有倉庫 (Private) 兩種形式。最大的倉庫註冊伺服器當然是 Docker hub，存放數量龐大的映像檔供使用者下載，使用者也可以在本地網路內建立一個私有倉庫。可以將倉庫的概念理解成跟 Git 相似。 倉庫與倉庫註冊伺服器 (Registry) 的不同 倉庫註冊伺服器 (Registry) 裡面可以存放很多的倉庫，每一個倉庫又包含了很多的映像檔，每一個映像檔有不同的標籤 (tag) 。 舉個例子：Docker hub 是最大的倉庫註冊伺服器 (Registry) ，裡面又有很多不同的倉庫，像是 mariadb ，裡面又會包含很多的映像檔，以及不同的標籤 (tag)。 我們可以看到 Docker 的 Logo 是一隻鯨魚，背上揹了一堆貨櫃。鯨魚就代表倉庫註冊伺服器 (Registry)，背上的貨櫃就是每一個倉庫 (Repository)。 Docker Logo 介紹\" Docker Logo 介紹 ","date":"2022-03-14","objectID":"/docker/:2:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 實作 本章節會介紹 Docker 三大組件映像檔 (image)、容器 (Container)、倉庫 (Repository) 要如何實際操作，以及他們的關聯性是什麼～ ","date":"2022-03-14","objectID":"/docker/:3:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"映像檔 (Image) 本小節會介紹有關映像檔的內容，包括： 如何從倉庫取得映像檔 如何管理本地主機上的映像檔 映像檔實作 (Dockerfile) 如何從倉庫取得映像檔 我們可以先到 Docker hub 上面看看有什麼服務或程式想要下載來做使用 [ 詳細介紹會放到倉庫 (Repository) 章節]，找到想要的服務，我們可以下 docker pull {要下載的服務、程式名稱} ，我們這邊就先下載 Mysql 這個映像檔。 mysql $ docker pull mysql Using default tag: latest latest: Pulling from library/mysql 15115158dd02: Pull complete .... 省略 .... Digest: sha256:b17a66b49277a68066559416cf44a185cfee538d0e16b5624781019bc716c122 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest 由於我們下載的沒有加任何的 tag ，也就是版本，所以我們都是下載最新版 latest ，如果想要下載特定版本，可以在服務名稱後面加上 :{版本} ，就可以下載對應的版本囉！ 如果有標記 Official Image 就代表是官方釋出的映像檔 ~ 在穩定性以及安全上更有保障，所以大家可以優先下載歐！ Docker hub 下載 Image\" Docker hub 下載 Image 管理本地主機上的映像檔 查看映像檔 (images) 當我們下載好映像檔後，可以使用 docker images 來列出本機已下載的映像檔。 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE php latest d6229b88aa29 3 days ago 484MB mysql latest 826efd84393b 6 days ago 521MB nginx latest c919045c4c2b 13 days ago 142MB 我們來看看都列出哪些訊息吧！ REPOSITORY：來自於哪一個倉庫，像是 php、mysql、nginx。 TAG：映像檔的標籤，因為我們都下載最新版本所以是 latest。 IMAGE ID：它的唯一 ID 號碼。 CREATED：建立時間。 VIRTUAL SIZE：映像檔大小。 儲存映像檔 (save) 想要儲存映像檔，可以使用 docker save {映像檔名稱} \u003e {檔案名稱}.tar，來做儲存。 $ docker save mysql \u003e mysql.tar $ ls | grep 'mysql' mysql.tar 刪除映像檔 (rmi) 想要刪除映像檔，可以使用 docker rmi {映像檔名稱} 來做刪除。 $ docker rmi demo-image Untagged:demo-image:latest Deleted: sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37 想要同時刪除映像檔時，可以先用 docker images -aq 列出全部映像檔的 IMAGE ID，再一起刪除。 docker rmi -f $(docker images -aq) 注意！刪除映像檔(Image)時，要先用 docker rm {容器} 去刪除所有依賴這個映像檔的容器。 接著要怎麼建立自己的映像檔呢？我們要使用 Dockerfile 來建立映像檔。 映像檔實作 撰寫 Dockerfile 映像檔 Dockerfile 是一種文字格式的設定檔，可以透過 Dockerfile 快速建立自訂的映像檔，換句話說，Dockerfile 就像是建置 Docker Image 的腳本。 舉個例子：可以把自己想像成一位設計師，設計好房子的格局、擺飾等，畫好設計圖 (Dockerfile) 後，最後請師傅 (Docker) 依你的構思完成就可以了。 我們就來開始實作一個 Dockerfile 吧 ~ 我們先創建一個來放 Dockerfile 的資料夾，可以直接在路徑下建立出映像檔 mkdir demo-dockerfile cd demo-dockerfile/ Dockerfile 結構，大致可以分為四個部分 基礎映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時需執行的指令 我們有說過 Dockerfile 是一個文字格式的設定檔，所以我們用 vim 來編寫 Dockerfile。 vim Dockerfile # 基礎映像檔資訊 FROM nginx:latest # 維護者資訊 LABEL maintainer=\"880831ian@gmail.com\" # 映像檔操作指令 RUN apt-get update -y\\ \u0026\u0026 apt-get install nginx -y # 運行時容器提供服務的通道 EXPOSE 80 # 容器啟動時需執行的指令 CMD [\"nginx\",\"-g\",\"daemon off;\"] FROM nginx:latest 第一行為必要的指定基礎映像檔，這邊使用 nginx 作為基礎映像檔，我們用最新版本，所以是 latest。 LABEL maintainer=\"880831ian@gmail.com\" 維護者資訊想不也是不可以少的，這邊也可以輸入 Email 資訊，只是要注意的是此資訊會寫入產出映像檔的Author名稱屬性中。 RUN apt-get update -y\\ \u0026\u0026 apt-get install nginx -y 這邊是最重要的部分，想要在映像檔案上設定或安裝都需要將命令寫在這，格式必須依 RUN ，RUN 指令後面放 Linux 指令，如果指令太長可以使用\\來換行。 -y 是在安裝 Nginx，會同意所有進行中所出現的問題。 EXPOSE 80 設定運行時容器提供服務的通道。 CMD [\"nginx\",\"-g\",\"daemon off;\"] 最後就是啟動指定容器時預設執行的指令，格式是 CMD [“executable”,“param1”,“param2”]。 Docker 運行 Nginx 時為什麼要使用 daemon off; 因為 Docker 容器啟動時，默認會把容器內部第一個進程，作爲 docker 容器是否正常運行的依據，如果 docker 容器 pid = 1 到進程就掛了，docker 就會退出！ Docker 未執行自定義的 CMD 之前， Nginx 的 pid 是 1，執行到 CMD 之後，Nginx 就在後台運行，bash 或是 sh 的腳本就會變成 pid =1 。 所以一但執行完 CMD，Nginx 容器就會退出了，所以才需要加上 -g daemon off;。 在 Nginx 官方的 Docker Repository 也有說明，在 Complex configuration 內。 順便說一下使用 Dockerfile 的優點：1 . 可以進行 Git 版控，讓你管理或分享更方便 2 . 佔用容量小，因為只是純文字檔而已。 使用 Dockerfile 建立映像檔 我們已經撰寫完 Dockerfile 檔案了，接下來要執行來產生映像檔，我們要使用 docker build 來建立，我們一起來看看吧 docker build -t demo-image . 因為我們在 dockerfile 的目錄下，所以直接使用 “.” 來做建立動作，也可以使用 -f 來指定 dockerfile 的路徑位置。使用 -t 來設定映像檔的名稱，我們這邊取名叫 demo-image。 [+] Building 2.7s (7/7) FINISHED =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 44B 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [internal] load metadata for docker.io/library/nginx:latest 2.6s =\u003e [auth] library/ubuntu:pull token for registry-1.docker.io 0.0s =\u003e [1/2] FROM docker.io/library/nginx:latest@sha256:8ae9bafbb64f63a50caab98fd3a5e37b3eb837a3e0780b78e5218e63193961f 0.0s =\u003e CACHED [2/2] RUN apt-get update -y \u0026\u0026 apt-get install nginx -y 0.0s =\u003e exporting to image 0.0s =\u003e =\u003e exporting layers 0.0s =\u003e =\u003e writing image sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37 0.0s =\u003e =\u003e n","date":"2022-03-14","objectID":"/docker/:3:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"容器 (Container) 我們在介紹指令前，先來了解一下 Dockerfile、Docker Image、Docker Container 這三個的關係，可以先參考以下圖片 容器 Container 組成\" 容器 Container 組成 我們在啟動 Container 時，會有這三個部分組成，最底層是映像檔 (Image)，這一層主要是透過撰寫 Dockerfile 之後 build 出來的 Docker Image，就像我們前面說的它是一個唯獨的檔案。執行啟動了 Docker Container，就會加上第二層，就是需要先 Init Container 的設定，例如是 hostname、環境變數、網路連接等系統設定，最後最上層再加上一層讓使用者可以在此層去讀寫資料。 有關於容器 (Container) 的指令非常多，光是簡單的 run 就有很多參數，我們先列出比較常用且基本的 Container 指令～ Container 執行時的操作 執行容器 (run) 我們想要創建一個新的容器並運行，就可以使用 docker run，我們來看看他可以使用哪些參數吧！ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS 說明： 參數 描述 -d 後台運行容器 -i 命令互動模式，通常與 -t 同時使用 -t 為容器重新分配一個假裝的輸入終端，通常與 -i 同時使用 -p 指定容器與本機的Port ，格式是 主機 Port : 容器 Port –name=\"{名稱}\" 為容器設定名稱 –net=\"{網路類型}\" 指定容器的網路連接類型，支援 bridge/host/none/container 四種模式 –link=\"{其他容器}\" 添加連接到另一個容器 –volume,-v 將容器檔案路徑映射到本地端，格式是 本機路徑：容器路徑 我們啟動我們下載好的 Nginx 來試試看吧！ $ docker run -d -p 7777:80 --name=\"demo-nginx\" -v /Users/ian_zhuang/Desktop/data:/var/www/html nginx 31a4a4a56e3ef2fb75d538c4c9eea4914ac506a84a6ff97e1fbbb6c3213cc6b7 我們將 Nginx 容器在背景執行，且將預設的80 Port 與本機的7777 Port 綁在一起，讓我們在本機瀏覽7777 Port 會直接導向容器的80Port，設定容器的名字叫做 “demo-nginx\" ，我們 Nginx 容器的檔案路徑映射到本地端的桌面 data 資料夾，我們就可以在本機新增檔案同步到容器中。 顯示容器 (ps) 使用 docker ps 來檢查一下是否啟動成功 (ps 可以顯示映像檔的基本資訊，如果沒有加 -a 只會顯示執行中的容器) $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 31a4a4a56e3e demo-image \"nginx -g 'daemon of…\" About a minute ago Up About a minute 0.0.0.0:7777-\u003e80/tcp demo-nginx 接著我們測試是否有把桌面 data 資料夾掛到容器的路徑，我們先在 data 新增一個 hello.html ，裡面隨意輸入，瀏覽一下 http://127.0.0.1:7777/hello.html ，看看是否成功。 容器 Container -volume 測試\" 容器 Container -volume 測試 顯示容器紀錄 (logs) 想要看到我們執行 Container 的紀錄，可以使用 logs 指令來顯示。 $ docker logs demo-nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh ... 省略 ... 2022/03/15 09:27:51 [notice] 1#1: start worker process 33 2022/03/15 09:27:51 [notice] 1#1: start worker process 34 2022/03/15 09:27:51 [notice] 1#1: start worker process 35 刪除容器 (rm -f) 想要刪除不需要的 Container，可以使用 rm 指令來做刪除，-f 是強制刪除容器。 $ docker rm -f demo-nginx demo-nginx 進入容器 (exec) 想要進入 container 來查看資料或是修改檔案，可以使用 exec 來進入容器中。 $ docker exec -it demo-nginx /bin/bash root@31a4a4a56e3e:/# ls bin boot dev docker-entrypoint.d docker-entrypoint.sh etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@31a4a4a56e3e:/# cd usr/bin/ root@31a4a4a56e3e:/usr/bin# pwd /usr/bin 匯出檔案 (export) 我們前面有提到說，如果刪除了容器，以前寫入的資料也會不見，如果想要輸出資料，可以使用 export 將可讀可寫的那一層匯成檔案。 $ docker export demo-nginx \u003e demo-nginx.tar $ ls | grep 'demo' demo-nginx.tar save 跟 export 的區別 還記得我們在儲存映像檔的時候有介紹到 save 嗎，那他跟 export 的區別是什麼呢？我們可以理解成 save 是把 Docker Image 原始檔做儲存，export 是把修改 Docker Image 的內容都一併儲存。 匯入檔案 (import) 有匯出檔案，當然也有匯入檔案拉，可以使用 import 將我們匯出的檔案匯入 Docker Image 裡面。 $ cat ~/Desktop/demo-nginx.tar| docker import - import-nginx sha256:7106935f0bfbdbb84f9eb20edb8cdb2c53207f5e0963f6a4e89d8267e9d98c56 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE import-nginx latest 7106935f0bfb 19 seconds ago 140MB Container 的狀態 檢查容器狀態 (inspect) 想要查看容器的狀態數據，可以使用 inspect 來顯示。 [ { \"Id\": \"sha256:1f56acbcbe9ec613a37e26934a84d98bed73879059f424dc69754520086baa37\", \"RepoTags\": [ \"demo-image:latest\" ], \"RepoDigests\": [], \"Parent\": \"\", \"Comment\": \"buildkit.dockerfile.v0\", \"Created\": \"2022-03-15T03:02:26.8321887Z\", \"Container\": \"\", \"ContainerConfig\": { \"Hostname\": \"\", \"Domainname\": \"\", \"User\": \"\", .... 省略 .... 查看容器的CPU、記憶體及網路使用 (stats) 想要查看容器的CPU、記憶體及網路使用，可以使用 stats 來顯示。 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 31a4a4a56e3e demo-nginx 0.00% 5.797MiB / 1.939GiB 0.29% 6.29kB / 2.83kB 1.46MB / 20.5kB 5 ","date":"2022-03-14","objectID":"/docker/:3:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"倉庫 (Repository) 我們在映像檔的章節有使用 docker pull 來下載別人的映像檔來使用，那我們要如何把我們做好的上傳上去 Docker hub 呢！(由於 Docker hub 是公開平台，所以大家都可以自由的下載映像檔，所以是公司機密的映像檔，就要避免上傳歐！) $ docker login Authenticating with existing credentials... Login Succeeded 由於我有下載桌面版的 Docker ，所以登入時不需要再另外設定！ 我們在上傳到 Docker hub 之前，需要先修改 Image 的 tag ，格式 docker tag {Image Name} {DockerHub帳號}/{想要取的 Image Name} $ docker images | grep 'demo-image' demo-image latest 1f56acbcbe9e 24 hours ago 166MB $ docker tag demo-image 880831ian/demo-image $ docker images | grep 'demo-image' 880831ian/demo-image latest 1f56acbcbe9e 24 hours ago 166MB demo-image latest 1f56acbcbe9e 24 hours ago 166MB 接下來就使用 docker push，將映像檔上傳到 Docker hub 上！ $ docker push 880831ian/demo-image Using default tag: latest The push refers to repository [docker.io/880831ian/demo-image] 7722c88c8d69: Pushed 68a85fa9d77e: Mounted from library/ubuntu latest: digest: sha256:814caacaf3dad3eccb43dc9bcad635d0473bd5946295d40ca1ec23d13a5f6d0f size: 741 我們也登入 Docker hub 看一下，是不是真的上傳成功了～ 容器 Container -volume 測試\" 容器 Container -volume 測試 ","date":"2022-03-14","objectID":"/docker/:3:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker 進階 本章節會分成三個常用功能來說明 Volumes 介紹 Network 模式介紹和比較 Docker-compose 介紹與實作 ","date":"2022-03-14","objectID":"/docker/:4:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Volumes 介紹 我們在先前介紹 Container 時，也有說到，Container 會分成 Image 層、Init 層以及使用者可讀可寫層的這三層。當我們將 Container 刪除後，存放在 Docker Container 上的資料也會不見，雖然可以用 export 來儲存，但我們應該在根本上解決問題。 所以我們可以使用兩種方式來解決！ 在執行 docker run 指令時加入 -v 參數，將 Container 的檔案路徑映射到本地端的檔案路徑。 在撰寫 Dockerfile 時，加入 VOLUME 指令，可以將資料存放在實體主機上。使用這個方法還要搭配我們介紹 Container 的狀態 \u003e 檢查容器狀態 (inspect) ，來查詢本地端檔案的存放路徑在哪。 使用 -v 指令將容器映射到本地端 在使用 docker run 指令時，使用 -v 將容器檔案路徑映射到本地的檔案路徑。 $ docker run -it -v /Users/ian_zhuang/Desktop/data:/storage centos /bin/bash latest: Pulling from library/centos Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177 Status: Downloaded newer image for centos:latest [root@a99b41fba3ca /]# 我們在著面的 data 資料夾隨意新增檔案或是資料，再進入 Docker Container 內的 /storage (該檔案是因為使用 -v 而新增的資料夾) ，看看有沒有同步新增。 [root@a99b41fba3ca /]# cd storage [root@a99b41fba3ca storage]# pwd /storage [root@a99b41fba3ca storage]# ls 1.html 2.html 3.html Dockerfile VOLUME 使用 我們先打開上次的 Dockerfile 檔案，在基礎映像檔資訊的底下使用 VOLUME 指令，加入 storage 資料夾，再將 Image Build 起來，啟動 Container，在 /storage 裡面隨便新增資料，最後我們在用 docker inspect 指令來找映射在本地端的路徑。 在基礎映像檔資訊的底下使用 VOLUME 指令，加入 storage 資料夾 # 基礎映像檔資訊 FROM ubuntu:latest VOLUME [\"/storage\"] .... 省略 .... 建立映像檔 $ docker build -t demo-image:v2 . [+] Building 1.3s (6/6) FINISHED =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 44B 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [internal] load metadata for docker.io/library/ubuntu:latest 1.2s =\u003e [1/2] FROM docker.io/library/ubuntu:latest@sha256:8ae9bafbb64f63a50caab98fd3a5e37b3eb837a3e0780b78e5218e63193961f9 0.0s =\u003e CACHED [2/2] RUN apt-get update -y \u0026\u0026 apt-get install nginx -y 0.0s =\u003e exporting to image 0.0s =\u003e =\u003e exporting layers 0.0s =\u003e =\u003e writing image sha256:0618bb2685ecfe200d9df4a91380d482031352d0e00cbfdf70fcd063aa8654fa 0.0s =\u003e =\u003e naming to docker.io/library/demo-image:v2 啟動 Container，並在 /storage 內新增隨意資料 $ docker run -it demo-image:v2 /bin/bash root@4f8712562dfe:/# echo \"Hello ian\" \u003e /storage/helloworld.txt root@4f8712562dfe:/# ll /storage total 12 drwxr-xr-x 2 root root 4096 Mar 16 05:39 ./ drwxr-xr-x 1 root root 4096 Mar 16 05:38 ../ -rw-r--r-- 1 root root 10 Mar 16 05:39 helloworld.txt 使用 inspect 指令，來找到 Volume 在本地端映射的資料夾路徑，看看裡面有沒有我們在 Container 裡面新增的資料吧 $ docker inspect -f '{{.Mounts}}' 4f8712562dfe [{volume 4fe10ca3f...省略 /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data /storage local true }] $ docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh / # cd /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data /var/lib/docker/volumes/4fe10ca3f234633164d9b3c541893c68db1b4f98806525076a2edd5c1c7863c4/_data # ls helloworld.txt mac OS 找不到 /var/lib/docker/volumes 由於 macOS 下的 docker 實際是在 vm 裡又多加一層，所以沒辦法直接訪問 /var/lib/docker/volumes，必須先透過以下指令進入 VM 中。 docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh 詳細內容可以參考 Where is /var/lib/docker on Mac/OS X。 容器與容器之間資料共享 如何啟用容器與容器之間的資料共享，可以用以下方式 先啟動第一個容器指令如下 docker run -it -v /data --name=container1 centos /bin/bash [root@ a0307ce757ca /]# 另二個容器指令如下 docker run -it --volumes-from container1 --name=container2 centos /bin/bash [root@720d57983cd4 /]# --volumes-from 參數指定 container1 的資料會與 container2 做共享。 我們在第一個容器，進入 /data 資料夾，隨機輸入資料 [root@a0307ce757ca /]# cd /data/ [root@a0307ce757ca data]# echo \"ian~\" \u003e hello.txt 再來看一下第二個容器 /data 資料夾，是否有我們在容器(a0307ce757ca)產生的資料 [root@720d57983cd4 /]# cat /data/hello.txt ian~ ","date":"2022-03-14","objectID":"/docker/:4:1","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Network 模式和比較 在執行 docker run 其中一個參數是 --net ，他可以設定 Container 要使用哪一種的網路模式，以下分別說明這些網路模式 none：在執行 Container 時，網路功能是關閉的，所以無法與此 Container 連線。 container：使用相同的 Network Namespace ，假設 Container 1 的 IP 是 172.17.0.2，那 Container 2 的 IP 也是 172.17.0.2。 host：Container 的網路設定和實體主機使用相同的網路設定，所以 Container 裡面也可以修改實體機器的網路設定，因此使用此模式需要考慮網路安全性上的問題。 bridge：Docker 預設就是此網路模式，這個網路模式就像是 NAT 的網路模式，例如實體主機的 IP 是 192.168.1.10 它會對應到 Container 裡面的 172.17.0.2，在啟動 Docker 的服務時會有一個 docker0 的網路卡來做此網路的橋接。 overlay：Container 之間可以在不同的實體機器上做連線，例如 Ｈost 1 有一個 Container 1 ，然後 Host 2 有一個 Container 2，Container 1 可以直接使用 overlay 的網路模式和 Container 2 做網路連線。 macvlan：可以直接分配實體網卡的 MAC address 給特定的 Container，讓 Container 透過實體的網卡使用網路。 那我們就來實作每一個網路模式吧！ none 我們使用 docker run指令，在後面加入參數 --net=none ，我們建立 jonlabelle/network-tools (裡面有很多網路測試工具)。 $ docker run -it --net=none jonlabelle/network-tools [docker@network-tools]$ ifconfig lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 .... 省略 .... 可以看到我們使用 ifconfig 查詢，只有本地端的 127.0.0.1 IP，我們在使用 ping 來測試 google 網站吧 [docker@network-tools]$ ping www.google.com ping: www.google.com: Try again container 我們先啟動一個名為 container1 的容器 docker run --name container1 -it jonlabelle/network-tools 再開啟另一個 Terminal 來啟動 container2 的容器，並設定相同的 Network Namespace docker run --name container2 --net=container:container1 -it jonlabelle/network-tools 一樣使用 ifconfig 查詢，可以發現兩個容器的 IP 都是相同的 eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 .... 省略 .... host 在執行 docker run 指令時，在後面加入參數 --net=host ，來測試 host 模式 docker run --net=host -it jonlabelle/network-tools 可以看到 Container 的網路資訊和實體主機的網路資訊是相同的結果 [docker@network-tools]$ ifconfig br-36a27cab1817 Link encap:Ethernet HWaddr 02:42:20:DF:DB:FD inet addr:172.20.0.1 Bcast:172.20.255.255 Mask:255.255.0.0 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 .... 省略 .... host 網路模式\" host 網路模式 bridge 在執行 docker run 指令時，在後面加入參數 --net=bridge ，來測試 bridge 模式 docker run --net=bridge -it jonlabelle/network-tools docker 會新增一個虛擬網卡作為容器網路對外的出口，預設名稱為 docker0，docker0 會跟本機的對外網卡(圖中的 eth0 )相連，藉此取得對外連線的能力，也因為每一個容器都會使用一個 veth device 與 docker0 相連，所以也具備對外連線的能力。 bridge 網路模式\" bridge 網路模式 overlay 下圖是說明 Host1 實體主機裡面有 Container1，然後 Host2 實體主機裡面有 Container2，可以透過 Docker overlay 模式將 Container1 和 Container2 連接做溝通。另外還需要一個 Consol 來存連線的資料庫，在使用 overlay 時要先在 Docker 做設定，這樣才能存放 overlay 網路模式的連線資訊。 overlay 網路模式\" overlay 網路模式 macvlan macvlan 的原理就是在本機的網卡上虛擬出很多個子網卡，通過不同的 MAC 位置在數據鏈路層進行網路資料的轉發。 macvlan 網路模式\" macvlan 網路模式 ","date":"2022-03-14","objectID":"/docker/:4:2","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"Docker-compose 我們在執行多個容器時，需要重複的下 run 指令來執行，以及容器與容器之間要做關聯也要記得每一個之間要怎麼連結，會變得很麻煩且不易管理，所以有了 docker-compose 可以將多個容器組合起來，變成一個強大的功能。 只要寫一個 docker-compose.yml 把所有會使用到的 Docker image 以及每一個容器之間的關聯或是網路的設定都寫上去，最後再使用 docker-compose up 指令，就可以把所有的容器都執行起來囉！ 我們就直接來實作我們這次的標題，要使用 docker-compose 來整合 PHP MySQL Nginx 環境。 我們先開啟一個資料夾，取名叫 docker-compose ，來放置我們的 docker-compose 檔案 接著新增 docker-compose.yml 檔案，要準備來撰寫我們的設定檔囉！ 由於內容有點長，所以我分段說明，(這邊有放已經寫好的檔案歐) 檔案目錄 . ├── Docker-compose.yml ├── docker-volume │ └── html │ ├── index.php │ └── info.php ├── nginx │ ├── Dockerfile │ └── default.conf └── php └── Dockerfile version:\"3.8\"services:...省略 .... 可以看到一開頭，會先寫版本，這邊代表的是會使用 3.8 版本的設定檔，詳細版本對照可以參考 Compose file versions and upgrading services 可以設定用來啟動多的容器，裡面我們總共放了三個容器，分別是 nginx、php、mysql 。 那我們來看看 nginx 裡面放了什麼吧！我會依照程式碼往下說明，有不清楚的可以底下留言！ nginx nginx:build:./nginx/container_name:nginxports:- 7777:80volumes:- ./docker-volume/log/:/var/log/nginx/ nginx 的 build 就是要執行這個 nginx 容器的映像檔，還記得我們也可以使用 Dockerfile 來撰寫映像檔案嗎！? 由於我們還要設定其他內容，所以特別另外拉一個 nginx 資料夾來放置，裡面放了兩個檔案，分別是 Dockerfile、default.conf。 Dockerfile 檔案裡面會使用 nginx 版本 1.20 ，並將 default.conf 複製到容器的 /etc/nginx/conf.d/default.conf 來取代設定。 以及我們使用 ports 將容器80 Port 指向本機 7777 Port ，格式是 本機 Port : 容器 Port， 再使用 volumes 來設定我們 nginx 容器 log 資料夾映射到本機的 ./docker-volume/log/ 資料夾。 php php:build:./php/container_name:phpexpose:- 9000volumes:- ./docker-volume/html/:/var/www/html/ php 的 build 是要執行這個 php 容器的映像檔，由於我們還要設定其他內容，所以特別另外拉一個 php 資料夾來放置 Dokcerfile。 Dockerfile 檔案裡面會使用 php 版本 7.4-fpm，並且在容器執行 docker-php-ext-install、mysqli。 並將 Port 9000 發佈於本機，再使用 volumes 來設定 /var/www/html 網站根目錄映射到本機的 ./docker-volume/html/ 資料夾。 mysql mysql:image:mysql:8.0.28container_name:mysqlvolumes:- ./docker-volume/mysql/:/var/lib/mysqlenvironment:MYSQL_ROOT_PASSWORD:secretMYSQL_DATABASE:mydbMYSQL_USER:myuserMYSQL_PASSWORD:password mysql 使用的映像檔是 mysql 版本是 8.0.28，我們為了要保留資料庫的資料，所以將容器的 /var/lib/mysql 映射到本地端 ./docker-volume/mysql 資料夾。 最後的環境變數，設定 root 帳號的登入密碼，以及要使用的資料庫、使用者的帳號、使用者的密碼。 最後在上面的 (這邊有放已經寫好的檔案歐) 裡面還有多一個 docker-volume/html 的資料夾，就是我們剛剛映射到本地端的資料夾，資料夾內已經放有連線測試的檔案，輸入網址 http://127.0.0.1:7777/index.php，如果開啟後有顯示下方畫面，就代表我們成功用 docker-compose 將 PHP MySQL Nginx 整合再一起囉！ 測試是否成功用 docker-compose 整合 PHP MySQL Nginx\" 測試是否成功用 docker-compose 整合 PHP MySQL Nginx ","date":"2022-03-14","objectID":"/docker/:4:3","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"參考資料 Docker 官網 什麼是 Docker？ Docker－－從入門到實踐 Dockerfile 建立自訂映像檔 — 架起網站快速又簡單（一） 用30天來介紹和使用 Docker Docker 網路簡介 Docker-compose Giving static IP in network mode : bridge ","date":"2022-03-14","objectID":"/docker/:5:0","tags":["Docker","容器","虛擬化","實作","介紹"],"title":"Docker 介紹 (如何使用 Docker-compose 建置 PHP+MySQl+Nginx 環境)","uri":"/docker/"},{"categories":["codenotes"],"content":"本篇是 Laravel 介紹 的進階篇，由於有些說明介紹會沿用上一篇的內容，建議要先瀏覽過上一篇呦～ (可以從這裡下載最後程式碼！) ","date":"2022-03-08","objectID":"/laravel-advanced/:0:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"Laravel 內建會員系統 Laravel 這個框架，很方便的地方就是，他可以將我們常用的帳號登入註冊等功能內建在 Laravel 框架內，那我們來看一下要怎麼使用吧。(本篇 Laravel Framework：5.4.36) 它的配置文件在 config/auth.php ，其中包含了用於調整認證服務行為或是標注選項配置等。 要怎麼開始呢!? 先使用 artisan 指令產生我們要的檔案以及路由吧！ $ php artisan make:auth 主要會產生 new file: app/Http/Controllers/HomeController.php new file: resources/views/auth/login.blade.php new file: resources/views/auth/passwords/email.blade.php new file: resources/views/auth/passwords/reset.blade.php new file: resources/views/auth/register.blade.php new file: resources/views/home.blade.php new file: resources/views/layouts/app.blade.php modified: routes/web.php 其中 routes/web.php 多了： Auth::routes(); Route::get('/home', 'HomeController@index')-\u003ename('home'); views 底下放的就是顯示的畫面，所以現在可以瀏覽 登入頁面：http://127.0.0.1:8000/login 註冊頁面：http://127.0.0.1:8000/register 其他像是 controller 或是 migration 都已經內建在裡面了，稍後實作會講到！ ","date":"2022-03-08","objectID":"/laravel-advanced/:1:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"實作 Migration 我們照上一篇的流程，由於 route 已經設定好，所以我們先來設定 migration ， 檔案就放在 database/migrations 底下的 {日期時間}_create_users_table.php ，我們來看一下預設的資料表有哪些欄位吧! public function up() { Schema::create('users', function (Blueprint $table) { $table-\u003eincrements('id'); $table-\u003estring('name'); $table-\u003estring('email')-\u003eunique(); $table-\u003estring('password'); $table-\u003erememberToken(); $table-\u003etimestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('users'); } 簡單看一下，他會建立一個名叫 users 的資料表，欄位分別有自動累加(id)、字串(name)、唯一字串(email)、字串(密碼)、rememberToken()、timestamps()。 那我們這次想要做的事，不使用 email 做登入，改成使用 username來當作登入驗證，所以我們把 name、email的欄位改成 public function up() { Schema::create('users', function (Blueprint $table) { $table-\u003eincrements('id'); $table-\u003estring('username')-\u003eunique(); $table-\u003estring('password'); $table-\u003erememberToken(); $table-\u003etimestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('users'); } 設定 username 欄位為唯一值，移除掉 email ，再加入一個 api_token 用於後續的 RESTful API 驗證。 使用 php artisan migrate 將 users 這個 table 給建起來。 因為我們修改 name、email 改成 username 這個欄位，所以我們也要修改一下 views 顯示的畫面，由於是簡單的 HTML 這邊就不再多描述，直接放上修改後的程式碼。 View Login.blade \u003cdiv class=\"form-group{{ $errors-\u003ehas('username') ? ' has-error' : '' }}\"\u003e \u003clabel for=\"username\" class=\"col-md-4 control-label\"\u003eUsername\u003c/label\u003e \u003cdiv class=\"col-md-6\"\u003e \u003cinput id=\"username\" type=\"text\" class=\"form-control\" name=\"username\" value=\"{{ old('username') }}\" required autofocus\u003e @if ($errors-\u003ehas('username')) \u003cspan class=\"help-block\"\u003e \u003cstrong\u003e{{ $errors-\u003efirst('username') }}\u003c/strong\u003e \u003c/span\u003e @endif \u003c/div\u003e \u003c/div\u003e Register.blade \u003cdiv class=\"form-group{{ $errors-\u003ehas('username') ? ' has-error' : '' }}\"\u003e \u003clabel for=\"username\" class=\"col-md-4 control-label\"\u003eUsername\u003c/label\u003e \u003cdiv class=\"col-md-6\"\u003e \u003cinput id=\"username\" type=\"text\" class=\"form-control\" name=\"username\" value=\"{{ old('username') }}\" required\u003e @if ($errors-\u003ehas('username')) \u003cspan class=\"help-block\"\u003e \u003cstrong\u003e{{ $errors-\u003efirst('username') }}\u003c/strong\u003e \u003c/span\u003e @endif \u003c/div\u003e \u003c/div\u003e Model 接下來到 app 底下找到 User.php 檔案，由於筆者習慣將 model 放到專屬的資料夾，不要讓他在 app 裡面流浪，所以會建立一個 Models 的資料夾，來存放所有的 models ，那移動原本的 model 有些有使用到它的路徑都要做修改，這邊以 User 檔案為示範。(因為後續會說到怎麼驗證登入 API ，所以上一篇的 Message model 也要記得修改歐！) 因為我們移動後，原本的路徑是 App 要改成 App\\Models，會影響到的程式有以下幾個 (附上片段程式碼) config/auth.php 約在70行左右 'providers' =\u003e [ 'users' =\u003e [ 'driver' =\u003e 'eloquent', 'model' =\u003e App\\Models\\User::class, //修改片段 ], config/services.php 約在33行左右 'stripe' =\u003e [ 'model' =\u003e App\\Models\\User::class, //修改片段 'key' =\u003e env('STRIPE_KEY'), 'secret' =\u003e env('STRIPE_SECRET'), ], database/factories/UserFactory.php 約在15行左右 $factory-\u003edefine(App\\Models\\User::class, function (Faker\\Generator $faker) { //修改片段 static $password; return [ 'name' =\u003e $faker-\u003ename, 'email' =\u003e $faker-\u003eunique()-\u003esafeEmail, 'password' =\u003e $password ?: $password = bcrypt('secret'), 'remember_token' =\u003e str_random(10), ]; }); app/Http/Controllers/Auth/RegisterController.php 約在5行左右 use App\\Models\\User; 都修改好了，我們就繼續來修改 User 這個 model ，將原本的 name、email ，修改成以下 \u003c?php namespace App\\Models; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ 'username', 'password', ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ 'password', 'remember_token', ]; } 裡面有一個是 fillable 跟 hiddem ，順便解釋一下這兩個是在做什麼 fillable：當使用者輸入這些 attribute 以外的參數(資料表的欄位)，就會發生錯誤。 hidden：想要限制能出現在陣列或是JSON 格式的屬性資料，比如密碼欄位等等，不想要顯示，只需要把該欄位加入 hidden。 再加碼一個 guarded：這個屬性與 fillable 相反，當使用者輸入該參數的值，就會被擋掉。以下這個例子是允許任何的 input 資料，但十分建議不要這樣。 protected $guarded = []; Controller 接下來是要修改我們的 controller，主要需要修改的有兩個，檔案在 app\\Http\\Auth 底下的 registerController 、 loginController 兩個檔案，我們先來修改 registerController 註冊功能，看一下原本的程式碼在做什麼事情。 RegisterController 原本程式碼 protected function validator(array $data) { return Validator::make($data, [ 'name' =\u003e 'requ","date":"2022-03-08","objectID":"/laravel-advanced/:1:1","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"驗證 RESTful API 是否登入 本篇會使用到上一篇的 RESTful API 留言板來進行修改，所以有興趣的朋友，可以先去看玩上一篇 Laravel 介紹 歐～ 接下來也會同時使用 Repository 設計模式來修改程式碼，那 Repository 設計模式是什麼呢，讓我先來介紹。 Repository 設計模式 還記得我們上一次，把所有的邏輯以及資料庫的處理的都放在 Controller 裡面嗎！如果只是單一個小專案，還可以這樣做沒關係，但專案越來越大，會使用的功能也越來越多，會造成 Controller 檔案肥大且難以維護，基於 SOLID 原則，我們應該要使用 Repository 設計模式來補助 Controller，將相關的資料庫邏輯放在不同的 Repository，方便中大型的專案做維護。 小知識 SOLID：簡單來說就是物件導向設定上為了讓軟體維護、開發變得更容易的五個準則的縮寫。 Single Responsibility Principle (SRP) 單一職責原則 Open-Closed Principle (OCP) 開放封閉原則 Liskov Substitution Principle (LSP) 里氏替換原則 Interface Segregation Principle (ISP) 介面隔離原則 Dependency Inversion Principle(DIP) 依賴反轉原則 SOLID目的也就是讓你程式碼達成低耦合、高內聚、降低程式碼壞味道，透過分離與clean code來提高可讀性會讓你的程式碼等同於設計文件，所以在修改或新增過程中降低產生Bug的機率，也可以較快的找到與解決出問題的地方，可以有效的減少技術債。 (資料來源：我該學會SOLID嗎?) 不太清楚沒關係，我們會慢慢介紹到！那我們先來看看這次要修改什麼呢！？ 我想要在使用 API 時，去檢查有沒有登入，才會進行動作，舉個例子，我們希望在新增留言、修改留言以及刪除留言都需要登入，且是由本人操作才算成功。 Migration 在此之前，我們先來修改一下上次的 migration {日期時間}_create_message_table.php 檔案吧 public function up() { Schema::create('message', function (Blueprint $table) { $table-\u003eincrements('id'); //留言板編號 $table-\u003einteger('user_id')-\u003eunsigned(); //留言者ID $table-\u003eforeign('user_id')-\u003ereferences('id')-\u003eon('users'); $table-\u003estring('content', 20); //留言板內容 $table-\u003einteger('version')-\u003edefault(0); $table-\u003etimestamps(); //留言板建立以及編輯的時間 $table-\u003esoftDeletes(); //軟刪除時間 }); } 可以看到我們將資料庫的名稱從 messsages 改為 message ，後續程式部分也都會修改，大家要在注意一下 ～ 我們這次加入了留言者 ID (使用外鍵連接 users 的 id)、按讚者 ID (使用外鍵連接 users 的 id)、留言板樂觀鎖、softDeletes軟刪除的欄位(軟刪除後續會提到)，並且因為我們同樣的資料不要重複儲存，所以刪除 name 要查詢就使用 join 來做查詢。 我們還希望可以多一個來存放是誰按讚的的資料表。所以一樣使用 migration 新增一個 {日期時間}_create_like_table.php 檔案 public function up() { Schema::create('like', function (Blueprint $table) { $table-\u003ebigIncrements('id'); //按讚紀錄編號 $table-\u003einteger('message_id')-\u003eunsigned()-\u003enullable(); //文章編號 $table-\u003eforeign('message_id')-\u003ereferences('id')-\u003eon('message'); $table-\u003einteger('user_id')-\u003eunsigned()-\u003enullable(); //帳號編號 $table-\u003eforeign('user_id')-\u003ereferences('id')-\u003eon('users'); $table-\u003edateTime('created_at'); //按讚紀錄建立時間 $table-\u003esoftDeletes(); //軟刪除時間 }); } 會存放文章的編號並且使用外鍵連接 message 的 id，以及按讚者的 ID 也使用外鍵連接 users 的 id。 列出本次會使用的功能以及對應的方法、是否需要登入、登入後其他人是否可以操作 功能 方法 是否需要登入 登入後其他人是否可以操作 查詢全部留言 getAllMessage 否 不需登入 查詢{id}留言 getMessage 否 不需登入 新增留言 createMessage 是 否 修改{id}留言 updateMessage 是 否 按讚{id}留言 likeMessage 是 可以 刪除{id}留言 deleteMessage 是 否 登入 API 我們上面介紹有使用到 Laravel 內建的登入 LoginController 來進行登入，但通常我們在使用時，都會另外再多一個登入用的 API ，那我們來看一下要怎麼設計吧！ 我們先使用 php artisan make:controller LoginController 新增一個登入的 API，他會產生在 app/Http/Controllers/ 目錄下 namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Validator; use Illuminate\\Support\\Facades\\Auth; class LoginController extends Controller { public function login(Request $request) { $rules = [ 'username' =\u003e 'required', 'password' =\u003e 'required' ]; $validator = Validator::make($request-\u003eall(), $rules); if ($validator-\u003efails()) { return response()-\u003ejson([\"message\" =\u003e \"格式錯誤\"], 400); } if (!Auth::attempt([ 'username' =\u003e $request-\u003eusername, 'password' =\u003e $request-\u003epassword ])) { return response()-\u003ejson([\"message\" =\u003e \"登入失敗\"], 401); } return response()-\u003ejson([\"message\" =\u003e \"登入成功\"], 200); } public function logout() { Auth::logout(); return response()-\u003ejson([\"message\" =\u003e \"登出成功\"], 200); } } 這邊的 Login 會先驗證格式是否正確，在使用 Auth:attempt 來檢查是否有註冊過，並且回傳相對應的訊息， Logout 就使用 Auth::logout 即可。 好了後我們先到 routes/api.php 新增登入跟登出 API 的路徑 Route::post('login', 'LoginController@login'); Route::post('logout', 'LoginController@logout'); 我們接下來設定 Middleware ，什麼是 Middleware 呢！？ Middleware Middleware 中文翻譯是中介軟體，是指從發出請求 (Request)之後，到接收回應(Response)這段來回的途徑上， 用來處理特定用途的程式，比較常用的 Middleware 有身份認證 (Identity) 、路由(Routing) 等，再舉個例子 某天早上你去圖書館看書， 下午去公園畫畫， 晚上去KTV 唱歌， 等到要準備回家的時候發現學生證不見了， 你會去哪裡找? (假設學生證就掉在這3個地方) 對於記憶不好的人來說，會按照 KTV \u003e 公園 \u003e 圖書館的路線去尋找。 假設在公園找到學生證，就不會再去圖書館了，由於這條路是死巷，所以只能返回走去KTV的路，這個就是 Middleware 的運作原理。 所以我們需要再請求時，先檢查是否有登入，才可以去執行需要權限的功能。 我們可以使用內建的 Auth::check 來檢查是否有登入，我們接著看要怎麼做吧！ 先下指令生成一個放置登入驗證權限的 Middleware ，我把它取名為 ApiAuth $ php artisan make:middleware ApiAuth Middleware creat","date":"2022-03-08","objectID":"/laravel-advanced/:1:2","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"Postman 測試 那我們一樣來看一下 Postman 的測試，這邊只顯示需要登入才能使用的 API。 登入 新增留言 成功\" 新增留言 成功 我們把帳號密碼放到 Body 來傳送，如果帳號密碼正確，就會顯示登入成功，並且在 Cookie 裡面的 laravel_session，可以用來判斷是否登入，以及登入的人是誰。 新增留言 - 成功 新增留言 成功\" 新增留言 成功 新增留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 會顯示新增紀錄成功以及回應 201 Created 新增留言 - 失敗 新增留言 失敗\" 新增留言 失敗 新增留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，所以會顯示用戶需要認證以及回應 401 Unauthorized 修改留言 - 成功 修改留言 成功\" 修改留言 成功 修改留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示修改成功以及回應 200 OK 修改留言 - 失敗 - 沒有登入 修改留言 失敗\" 修改留言 失敗 修改留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 修改留言 - 失敗 - 權限不足 修改留言 失敗\" 修改留言 失敗 修改留言失敗，雖然 有登入，但存在 Cookie 裡面的 laravel_session 不是當初的留言者 ，會顯示權限不正確以及回應 403 Forbidden 按讚留言 - 成功 修改留言 成功\" 修改留言 成功 按讚留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示按讚成功以及回應 200 OK 按讚留言 - 失敗 - 沒有登入 修改留言 失敗\" 修改留言 失敗 按讚留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 刪除留言 - 成功 刪除留言 成功\" 刪除留言 成功 刪除留言成功，因為 有登入，所以可以從 Cookie 裡面的 laravel_session 來驗證是否登入 ，不會顯示訊息但會回應 204 No Content 刪除留言 - 失敗 - 沒有登入 刪除留言 失敗\" 刪除留言 失敗 刪除留言失敗，因為 沒有登入，無法從 Cookie 裡面的 laravel_session 來驗證是否登入 ，會顯示用戶需要認證以及回應 401 Unauthorized 刪除留言 - 失敗 - 權限不足 刪除留言 失敗\" 刪除留言 失敗 刪除留言失敗，雖然 有輸入正確的 token ，但不是當初的留言者 ，會顯示權限不正確以及回應 403 Forbidden ","date":"2022-03-08","objectID":"/laravel-advanced/:1:3","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"參考資料 Laravel Auth 自定義user 模型目錄結構 user ( Model ) Laravel Form Request Validation laravel Validation 驗證格式 ","date":"2022-03-08","objectID":"/laravel-advanced/:2:0","tags":["PHP","框架","Laravel","RESTful API","Repository","實作","介紹"],"title":"Laravel 進階 (內建會員系統、驗證 RESTful API 是否登入、使用 Repository 設計模式)","uri":"/laravel-advanced/"},{"categories":["codenotes"],"content":"什麼是 Redis ? Redis 全名是 Remote Dictionary Server ，是快速的開源記憶體鍵值資料庫 (keys-value database)。 由於 Redis 的回應時間極短，低於一毫秒，可以讓遊戲、金融服務、醫療保健等即時應用服務每秒處理幾百萬個請求。 ","date":"2022-03-08","objectID":"/redis/:1:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"Redis 的優勢 效能 所有的 Redis 資料都是存放在記憶體中，進而實現低延遲和高傳輸量的資料存取。 彈性的資料結構 一般的鍵值資料庫提供的資料結構有限，而 Redis 提供多樣化的資料結構來滿足服務的需求，包含字串(Strings)、哈希(Hashes)、列表(Lists)、集合(Sets)、有序集合(Zset)。(後續會有詳細介紹) 簡單易用 Redis 可以用更少、更精簡的指令來取代傳統複雜的程式碼，可以存取應用程式的資料。並支援 Java、Python、PHP、C/C++、C#、JavaScript、Node.js、Ruby、R、GO。 複寫和持久性 Redis 採主要-複本架構，支援非同步複寫，可以將資料複寫到多個複本伺服器。不但可以提升讀取效能(因為請求可分割到多部伺服器)，還可以再主服務器發生故障時快速恢復。至於持久性，Redis 支援時間點備份，會將資料複製到磁碟中。 ","date":"2022-03-08","objectID":"/redis/:1:1","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"實際操作 ","date":"2022-03-08","objectID":"/redis/:2:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"安裝 Redis 使用 Homebrew 來安裝 Redis (Mac OS：11.6) $ brew install redis 安裝好用 -v 檢查版本 $ redis-server -v Redis server v=6.2.6 sha=00000000:0 malloc=libc bits=64 build=c6f3693d1aced7d9 $ redis-cli -v redis-cli 6.2.6 一個是 Server、另一個是 Cli，所以在稍後測試時，需要開啟兩個 Terminal 來執行歐！ ","date":"2022-03-08","objectID":"/redis/:2:1","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"執行 Redis Server $ redis-server 39403:C 08 Mar 2022 11:13:17.500 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 39403:C 08 Mar 2022 11:13:17.500 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=39403, just started 39403:C 08 Mar 2022 11:13:17.500 39403:M 08 Mar 2022 11:13:17.501 * Increased maximum number of open files to 10032 (it was originally set to 256). 39403:M 08 Mar 2022 11:13:17.501 * monotonic clock: POSIX clock_gettime _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 6.2.6 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 39403 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | https://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 39403:M 08 Mar 2022 11:13:17.503 # Server initialized 39403:M 08 Mar 2022 11:13:17.503 * Ready to accept connections 如果出現上面符號，就代表 Server 已經啟動，接下來再開另一個 Terminal 來執行 Cli。 Cli 開啟後，在下一個 ping 指令，該指令用於檢測 redis 服務是否啟動，正常會顯示 pong。 $ redis-cli 127.0.0.1:6379\u003e ping PONG 接下來，我們都會在 Cli 視窗做測試，會詳細介紹每一個資料型態以及其適合情境。 redis 圖形化工具 後續會使用 Cli 畫面來做示範，但也有不錯的圖形化工具可以用於 redis 上 AnotherRedisDesktopManager 大家可以去試用看看~ ","date":"2022-03-08","objectID":"/redis/:2:2","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"資料型態 字串 (Strings) set、get 這是最基本的型態，可以存放 binary, string, integer, float資料，一個 Strings 的欄位，最高可儲存 512 Megabytes，這裡會用到的指令是 set、get ，分別用來儲存以及讀取字串，我們來看一下範例吧。 127.0.0.1:6379\u003e set string hello-world OK 127.0.0.1:6379\u003e get string \"hello-world\" 我們先用 set 將 hello-world 字串存到 string 這個 key，再用 get 顯示 string 裡面的 value。 incr、decr Redis 還有一些方便的指令，如果存入的 value 是 integer 型態，就可以使用 incr 、decr ，來累加與累減。分別代表累加，像是我們的 ++ ，以及累減，像是我們的 - -。 127.0.0.1:6379\u003e set num 10 OK 127.0.0.1:6379\u003e incr num (integer) 11 127.0.0.1:6379\u003e incr num (integer) 12 127.0.0.1:6379\u003e decr num (integer) 11 127.0.0.1:6379\u003e decr num (integer) 10 append 如果 key 已經存在並且它是字串，可以使用 append 指令，會從字串最後面附加進去，如果不存在，則會直接建立一個，並把值存進去。 127.0.0.1:6379\u003e exists str (integer) 0 127.0.0.1:6379\u003e append str \"Hello\" (integer) 5 127.0.0.1:6379\u003e append str \" World~\" (integer) 12 127.0.0.1:6379\u003e get str \"Hello World~\" getrange 可以輸入字串的開始位元與結束位元，會依照你輸入的去顯示字串。我把它理解成是陣列的 key 與 value 的關係。 127.0.0.1:6379\u003e set a \"This is a string\" OK 127.0.0.1:6379\u003e getrange a 0 3 \"This\" 127.0.0.1:6379\u003e getrange a -3 -1 \"ing\" 127.0.0.1:6379\u003e getrange a 0 -1 \"This is a string\" 127.0.0.1:6379\u003e getrange a 10 100 \"string\" mset 我們也可以設定的時候，把要設定的值都一起設定，只需要使用 mset 就可以達成。 127.0.0.1:6379\u003e mset 1 1 2 2 OK 127.0.0.1:6379\u003e get 1 \"1\" 127.0.0.1:6379\u003e get 2 \"2\" 127.0.0.1:6379\u003e get 3 (nil) 如果用 get 顯示資料，若沒有對應的 key ，會顯示 (nil)。 字串型態適合場景 字串(strings) 型態適合用於圖片快取 （使用binary）、累計次數、觀看累計次數 String 適用場景圖\" String 適用場景圖 哈希 (Hashes) 可以把他想像成二維陣列，應該會比較好理解，我網路上找了一張圖，應該會比較清楚！ Hashes 示意圖 (Redis 基本資料形態)\" Hashes 示意圖 (Redis 基本資料形態) Hashes 是用來存放一組相同性質的資料，這些資料 Hashes 或是物件的某一屬性，與 String 較為不同的是他可以取回單一個欄位資料，但 String 必須取回所有資料，單一個 Key 可以存放2^32 - 1的資料欄位， 他的資料型態有像是，一個 user001 裡面是一個 Hashes，Hashes 裡面又會存放 name、phone、gender ，我們來實際操作看看。 hset、hget 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hget student name \"ian\" 127.0.0.1:6379\u003e hget student phone \"0980123456\" 127.0.0.1:6379\u003e hget student gender \"M\" Hashes 的話要使用 hset、hget 來對 Hashes 做儲存以及讀取。 hgetall 想要一次顯示 Hashes 裡面的 key 跟 value ，可以使用 hgetall 來顯示全部資料。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"phone\" 4) \"0980123456\" 5) \"gender\" 6) \"M\" hkeys 想要單獨顯示 Hashes 裡面的 key ，可以使用 hkeys 來顯示。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hkeys student 1) \"name\" 2) \"phone\" 3) \"gender\" hvals 想要單獨顯示 Hashes 裡面的 value ，可以使用 hvals 來顯示。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hvals student 1) \"ian\" 2) \"0980123456\" 3) \"M\" hlen 想要顯示 Hashes 裡面的 key 長度，可以使用 hlen 來顯示。 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"gender\" 4) \"M\" 127.0.0.1:6379\u003e hlen student (integer) 2 hincrby 想要增加 Hashes 裡面的 value 整數，可以使用 hincrby 來新增。 127.0.0.1:6379\u003e hset test a 10 b 20 (integer) 2 127.0.0.1:6379\u003e hincrby test a 2 (integer) 12 hdel 想要刪除 Hashes 裡面的 key，可以使用 hdel 來刪除。 127.0.0.1:6379\u003e hset student name ian phone 0980123456 gender M (integer) 3 127.0.0.1:6379\u003e hdel student phone (integer) 1 127.0.0.1:6379\u003e hgetall student 1) \"name\" 2) \"ian\" 3) \"gender\" 4) \"M\" 哈希型態適合場景 哈希(Hashes) 型態適合用於每次只需要取用一部分的資料 Hashes 適用場景圖\" Hashes 適用場景圖 列表 (Lists) lpush、lrange Lists 資料型態可以想像成程式語言中的Array物件。Lists 單一個Key可以存放2^32 - 1，這邊會使用到 lpush、lrange 來對 Lists 做儲存以及讀取。 127.0.0.1:6379\u003e lpush list2 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lrange list2 0 10 1) \"e\" 2) \"d\" 3) \"c\" 4) \"b\" 5) \"b\" 6) \"a\" 7) \"a\" rpush 除了從隊伍頭放入資料，也可以用 rpush 從隊伍尾放入資料，如果使用 lrange 來顯示方向也會相反歐。 127.0.0.1:6379\u003e rpush list3 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lrange list3 0 10 1) \"a\" 2) \"a\" 3) \"b\" 4) \"b\" 5) \"c\" 6) \"d\" 7) \"e\" lpop、rpop 也可以使用 lpop、rpop 分別從隊伍頭或尾彈出一筆資料。 127.0.0.1:6379\u003e rpush list3 a a b b c d e (integer) 7 127.0.0.1:6379\u003e lpop list3 \"a\" 127.0.0.1:6379\u003e rpop list3 \"e\" lset 可以使用 lset 來設定指定位置的資料。 127.0.0.1:6379\u003e lrange list3 0 2 1) \"a\" 2) \"b\" 3) \"c\" 127.0.0.1:6379\u003e lset list3 1 w OK 127.0.0.1:6379\u003e lrange list3 0 2 1) \"a\" 2) \"w\" 3) \"c\" 列表型態適合場景 列表(Lists) 型態適合用於文章列表或者資料分頁展示的應用 Lists 適用場景圖\" Lists 適","date":"2022-03-08","objectID":"/redis/:2:3","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"發布訂閱 (PUB/SUB) Redis 發布訂閱 (pub/sub) 是一種消息通信模式，發送者 (pub) 發送消息，訂閱者 (sub) 接收消息。 Redis 客戶端可以使用 subscribe 來訂閱任意數量的頻道。 下面這張圖是頻道1，以及訂閱這個頻道的三個用戶端分別是客戶端2、客戶端7、客戶端5 Subscribe 示意圖\" Subscribe 示意圖 當我們有新消息通過 publish 指令發送給頻道1 ，這個消息就會被發送給有訂閱頻道1的三個客戶端。 Publish 示意圖\" Publish 示意圖 我們來模擬一下吧 ! 先開兩個 Terminal 來執行 redis-cli 一個當作發送(pub)，另一個當作接收(sub)。 我們先用第一個 Terminal 訂閱一個頻道 channel_1 127.0.0.1:6379\u003e subscribe channel_1 Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"channel_1\" 3) (integer) 1 開啟另一個 Terminal 發送訊息到 channel_1 127.0.0.1:6379\u003e publish channel_1 \"Hello World~\" (integer) 1 127.0.0.1:6379\u003e publish channel_1 \"ian~\" (integer) 1 127.0.0.1:6379\u003e publish channel_1 \"test~\" (integer) 1 這時候再切換回來第一個 Terminal ，就可以看到他接收到我們傳送的訊息 127.0.0.1:6379\u003e subscribe channel_1 Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"channel_1\" 3) (integer) 1 1) \"message\" 2) \"channel_1\" 3) \"Hello World~\" 1) \"message\" 2) \"channel_1\" 3) \"ian~\" 1) \"message\" 2) \"channel_1\" 3) \"test~\" ","date":"2022-03-08","objectID":"/redis/:2:4","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"參考資料 Redis 官網 Redis Redis 基本資料形態 Redis 發布訂閱 ","date":"2022-03-08","objectID":"/redis/:3:0","tags":["Redis"],"title":"Redis 介紹","uri":"/redis/"},{"categories":["codenotes"],"content":"每當我們在建立資料表時，都必須先決定我們要用的資料型態，然而在輸入文字存入資料時，你都用哪一種資料型態呢？ ","date":"2022-03-04","objectID":"/char-varchar/:0:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"文字資料型態 主要有這三點，那我會分別來介紹，最後附上一個表格來整理一下今天所講的。 char varchar text ","date":"2022-03-04","objectID":"/char-varchar/:1:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"char char 的長度是不可變動的，每一條資料佔用等長的字節空間，適合用在身分證號碼、手機號碼等。 ","date":"2022-03-04","objectID":"/char-varchar/:1:1","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"varchar varchar 的長度是可以變動的，可以設定最大長度，就適合用於在長度可變的屬性。 ","date":"2022-03-04","objectID":"/char-varchar/:1:2","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"text text 的長度不需要設定，當我們不知道屬性的長度時，就適合用 text。 ","date":"2022-03-04","objectID":"/char-varchar/:1:3","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"可變跟不可變的差異 疑~ 什麼是可變，什麼是不可變長度呀 ? 簡單來說，我們現在定義一個 char[10] 以及 varchar[10]，現在我們存入的資料是 “pinyi” 5字元的字串， 由於 char 是不可變長度，所佔的長度依舊是 10 ，那如果是 varchar 可變長度，除了字元所佔的5格，後面的 5 個空格會自動消失，varchar 會自動把長度變成 5 。 取資料時，char 型別要用 trim() 來去除多餘的空白，而 varchar 不需要。 ","date":"2022-03-04","objectID":"/char-varchar/:1:4","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"查詢速度比較 如果我們來依照查詢速度來比較，想也不用想，一定是 char 第一名，因為他有固定的數量，比起 varchar 第二名可變長度還可以更快進行查詢，當然沒有長度限制的 text 一定是最慢。 ","date":"2022-03-04","objectID":"/char-varchar/:1:5","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"儲存方式 char 的儲存方式是，對於英文字元 (ASCII) 佔用 1 位元組，對於中文佔用 2 位元組 ; varchar 的儲存方式是，對每個英文字元 (ASCII) 佔用 2 位元組，中文也佔用 2 位元組 ; ","date":"2022-03-04","objectID":"/char-varchar/:1:6","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"比較差異表格 字串資料型態 char varchar text 長度狀態 不可變 可變 不需要設定 查詢速度 第一 第二 第三 英文所佔用位元組 1 Byte 2 Byte Ｘ 中文所佔用位元組 2 Byte 2 Byte Ｘ 最大長度 1 \u003c= M \u003c= 255 L \u003c= M or 1 \u003c= M \u003c= 255 L \u003c2^16 ","date":"2022-03-04","objectID":"/char-varchar/:1:7","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"參考資料 面試官：你們資料庫選擇varchar和char的原則到底什麼？ SQL Server 資料型態 char varchar nchar nvarchar MySQL性能優化之char、varchar、text的區別 ","date":"2022-03-04","objectID":"/char-varchar/:2:0","tags":["資料型態"],"title":"面試官常問的 MySQL 資料型態差別 char varchar text","uri":"/char-varchar/"},{"categories":["codenotes"],"content":"本文章會介紹什麼是 Laravel ，以及它有什麼特別之處，可以讓它在2015年被評為最受歡迎的 PHP 框架第一名，並說明為什麼要使用框架，最後實作一個留言板功能搭配 RESTful API 來實現 CRUD。 就像是 Laravel 官網的大標題，『 The PHP Framework for Web Artisans 為網頁藝術家創造的 PHP 框架 』，那再了解 Laravel 之前，先來介紹一下框架是什麼： ","date":"2022-03-02","objectID":"/laravel/:0:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"框架是什麼 框架 (Framework) 是一個被設計用來完成特定任務的規範，程式開發人員必須遵從這個規則來開發。 目前大多數的框架都是參考 MVC 架構的概念來做設計，原因是在早期開發網頁時，都是直接將 HTML 以及 PHP 混合再一起的方式來編寫，雖然開發上很方便，但在後面維護或是新增功能上，會十分不便利，例如：單純要修改網站畫面的元件時，還需要從混雜的程式碼中找到要修改的元件，也很容易不小心修改到其他的功能。 ","date":"2022-03-02","objectID":"/laravel/:1:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"MVC 於是有人想到把這些各自的任務區分開來，MVC 架構分別代表的是 M (Model) : 屬於資料的部分，可能是商用邏輯或是資料庫的存取。 V (View)：屬於顯示的部分，像是 HTML、CSS 等 C (Controllor)：會針對請求做出回應或是處理，例如從 Model 取出資料，並顯示在 View 上面 MVC 架構 一起走向MVC(上)\" MVC 架構 一起走向MVC(上) ","date":"2022-03-02","objectID":"/laravel/:1:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 框架 Laravel 是基於上面所說的 MVC 架構打造的框架，並且設計出許多可以讓開發者更有效率的工具。 Artisan：提供許多指令，讓你可以使用這些指令，來快速完成許多的任務 (有列出部分指令於 Artisan 相關指令)。 Routing 路由：管理網址與頁面的路徑指定，辨識傳入的 request 傳送至對應的 Controller，回傳指定的 View。 Blade 模板引擎 (View)：模板解析工具， 是 Laravel 所使用的模板引擎，Blade 會將 PHP 及 HTML 完整分離的工具。 Auth 認證：透過 Laravel 預設提供的認證讓 Controller 快速解決經常會用到的驗證需求，像是：使用者註冊、使用者認證、重置密碼的 e-mail 連結、重置密碼邏輯等。 Eloquent ORM 物件關聯對映 (Model)：Laravel 預設的 ORM，將資料庫的欄位映射成物件 (Ｍodel 模型)，只需要用 PHP 的語法，不需要撰寫 SQL 指令就可以用物件的方式讀取欄位資訊以及與資料庫的互動。 Migration 資料庫遷移：聽起來很像是更換資料庫，但他其實算是一種資料庫的版本控制，可以讓團隊在修改資料庫結構的同時，保持彼此的進度ㄧ致，通常會結合Schema 結構生成器一起使用，可以簡單管理資料庫結構。 小知識 ORM：英文叫 Object Relational Mapping，翻譯成中文為物件關聯對映。在網站開發結構中，是在資料庫和Model 資料容器兩者之間，簡單來說，它是可以讓開發者更簡單、安全的方式從資料庫讀取資料，因為 ORM 的特性是可以透過物件導向程式語言去操作資料庫。 優點 安全性：可以避免 SQL injection，遇到奇怪的值，會自動擋掉。 簡化性：可以將原本 SQL Select * From users 等指令透過物件導向程式語言去操作資料庫。 通用性：因為 ORM 是程式語言和資料庫之間的關係，就算有要轉換資料庫，也比較不會遇到要修改程式的狀況。 缺點 效能：為了要達成方便性，通常都會犧牲到效能的問題，因為等於多了『把程式語言轉譯成SQL語言』這項工作。 學習曲線高：對於初學者來說，ORM 需要融合 SQL 語言以及程式語言兩種不同的概念以及語法，會比單純學 SQL 語法還較複雜。 複雜查詢維護性低：有些 SQL 語法 ORM 沒有支援，所以導致有些情況還是需要導入原生 SQL 寫法。 (資料來源：資料庫設計概念 - ORM) ","date":"2022-03-02","objectID":"/laravel/:2:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"PHP 常見框架對比 雖然本次介紹的主題是 Laravel 但我們也簡單介紹一下其他的框架優點，以及附上表格讓大家可以更清楚。 差別 Laravel Symfony CodeIgniter CakePHP Zend 2 許可 License MIT MIT BSD BSD MIT 人氣排名 Popularity (2022-03 Google 搜尋熱門程度) 第一名 第二名 第三名 第四名 第五名 表現 慢 慢 快 慢 慢 模板 Blade Twig PHP 內建 PHP 資料庫 MySQL PostgreSQL SQLite SQL Server MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle MySQL PostgreSQL SQLite SQL Server Oracle 物件關係對映 有 Doctrine 沒有內建 有 Doctrine 測試 PHPUnit PHPUnit 內建 PHPUnit PHPUnit ","date":"2022-03-02","objectID":"/laravel/:3:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 該框架可能是Web 開發人員中最受歡迎的框架。Laravel 是一個免費的開源PHP 框架，適用於Web 應用程序開發，且適用於移動應用程序場。(上面有介紹過，這邊就簡化) Laravel 框架優點 易於學習 無縫數據遷移 在 PHP 社群中很受歡迎 支持 MVC 架構 大量學習素材 (文件、圖檔、影片教程) 模板引擎 簡單的單元測試 ","date":"2022-03-02","objectID":"/laravel/:3:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Symfony 該框架是一個廣泛的PHP MVC 框架，目前Symfony 已經成為一個可靠和成熟的平台框架。 Symfony 非常穩定、文檔齊全、性能卓越。這些特點使Symfony 成為開發大型企業項目的完美選擇。 使 Symfony 成為 PHP 框架中獨一無二的特性之一是它的可重用 PHP 組件。使用可重用組件，開發時間減少了許多模塊，如表單創建、對象配置、模板等。 可以直接從舊組件構建，節約了大量成本。Symfony 易於在大多數平台上安裝和配置，並且可以獨立於數據庫引擎。它具有高度的靈活性，可以與 Drupal 等大型項目集成 Symfony 框架優點 官方長期技術支持 內置測試功能 豐富的框架內置功能 官方培訓課程和認證 ","date":"2022-03-02","objectID":"/laravel/:3:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"CodeIgniter 該框架可能是最適合開發動態網站的PHP 框架。它是一個非常簡單的輕量級PHP 框架。 它的大小只有2 MB 左右（包括文檔）。因此，CodeIgniter 本身俱有最小的佔用空間，它允許Web 開發人員添加第三方插件來開發更複雜的功能。 CodeIgniter 還提供了幾個預構建的模塊，用於為Web 開發創建健壯的、可重用的組件。由於設置過程簡單，這個PHP 框架非常適合初學者。 CodeIgniter 框架優點 MVC 架構 Top-Notch 錯誤處理 提供卓越的性能 包中提供了幾種工具 內置安全工具 優秀的文檔 ","date":"2022-03-02","objectID":"/laravel/:3:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"CakePHP 該框架對個人是完全免費，並提供付費的商業用途。它將幫助您開發功能豐富且視覺上令人印象深刻的網站。 CakePHP 起初是一個簡單而優雅的工具包，在過去的15 年裡它變得更加強大。由於它的CRUD（創建、讀取、更新和刪除）框架，CakePHP 是最容易學習的框架。 使用CakePHP 部署Web 網站是\"小菜一碟\"，只需要一個Web 服務器和CakePHP 框架的副本。 CakePHP 框架優點 插件和組件的簡易擴展 適當的類繼承 零配置 現代框架 支持AJAX 快速構建 內置驗證 ","date":"2022-03-02","objectID":"/laravel/:3:4","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Zend 2 該框架是一個完整的面向對象的PHP 框架。這個PHP 框架是可定制的，對於需要添加項目特定功能的開發人員來說，這是一個好處。 Zend 構建於敏捷方法之上，可幫助開發人員為大型客戶創建、高質量的Web 應用程序的框架。它非常適合複雜的企業級項目，Zend 主要關注安全性、性能和可擴展性。 Zend 框架主要受大型IT 企業和銀行等金融機構的青睞。 Zend 2 框架優點 MVC 組件 卓越的前端技術支持工具 大型開發者社區 簡單的雲API 支持第三方組件 數據加密 支持AJAX 會話管理 ","date":"2022-03-02","objectID":"/laravel/:3:5","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"實作 Laravel 官網 我是參考 Laravel 官方網站 的文件來進行實作，也可以參考台灣的 Laravel.tw 來操作歐！ ","date":"2022-03-02","objectID":"/laravel/:4:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"環境設定 要安裝 Laravel 框架有一些系統的要求，要先安裝 PHP ，請參考PHP 官網的安裝教學 安裝完後可以使用來檢查是否安裝成功 $ php --version PHP 7.1.33 (cli) (built: Jan 20 2022 04:04:37) ( NTS ) Copyright (c) 1997-2018 The PHP Group 再安裝 Composer ，請參考 Composer 官網的安裝教學 $ composer --version Composer version 2.2.7 都安裝好後，我們就要來安裝 Laravel 框架囉，根據 Laravel 官網安裝步驟，先用 Composer 來安裝 $ composer global require \"laravel/installer\" 安裝後一樣先來檢查是否安裝成功 $ laravel --version zsh: command not found: laravel 發現 zsh 找不到 laravel 這個命令，那我們看一下官網怎麼說 ( zsh 是我所使用的 bash ，這邊會依照安裝環境而有所不同) Make sure to place the $HOME/.composer/vendor/bin directory (or the equivalent directory for your OS) in your $PATH so the laravel executable can be located by your system. 代表我們要將 Laravel 的目錄，放到 $PATH ，系統才可以使用 laravel 來執行檔案。 以 macOS 來說， Laravel installer 的目錄都會放在 $HOME/.composer/vendor/bin ，我們在根目錄建立一個 .bash_profile 的檔案來放置我們的 $PATH。 export PATH=\"$HOME/.composer/vendor/bin:$PATH\" 輸入上面的 PATH ，記得儲存離開後要用這個指令來更新一下檔案 $ source .bash_profile 我們再次檢查是否安裝好 Laravel $ laravel --version Laravel Installer 2.3.0 因為我們後續會使用到資料庫的功能，所以也可以先把他安裝好 ＭySQL 官網的安裝教學 $ mysql -V mysql Ver 8.0.28 for macos11.6 on x86_64 (Homebrew) 本次實作の版本配置 macOS 11.6 PHP 7.1.33 MySQL 8.0.28 Composer 2.2.7 Laravel Installer 2.3.0 Laravel Framework 5.4.36 ","date":"2022-03-02","objectID":"/laravel/:4:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"新增專案 安裝成功後，就可以開始來使用 Laravel 框架自動生成檔案囉！要怎麼做呢？就接著看下去吧 可以使用 Laravel 來新增專案 $ laravel new 專案名稱 也可以透過 composer 指令 (可以指定框架版本，那我們這次使用的是5.4版本) $ composer create-project --prefer-dist laravel/laravel 專案名稱 \"5.4.*\" 完成後就進入該專案目錄底下，接著可以執行該指令來檢查框架版本 $ php artisan -V Laravel Framework 5.4.36 小提醒 Laravel 框架可使用的的版本，取決於你的 PHP 版本，所以要找相對應的歐！使用 Laravel 5.4 跟 PHP 8.1 ，他會說 PHP 版本太新，無法安裝。 ","date":"2022-03-02","objectID":"/laravel/:4:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Laravel 資料夾與檔案介紹 我們可以看到這個專案目錄下，Laravel 幫我們生成了許多資料夾以及檔案，接著來簡單說明每一個資料夾與檔案的功能與用途吧 app：主要放置 controller 的地方，提供網站的應用處理流程，包括處理用戶的行為和資料 Model 上的改變等事件之類別方法，提供給 view 來呼叫。透過 Laravel 之架構也可透過 controller 輕易建構 RESTful API。 bootstrap：內含之 app.php 為將此框架初始化及建構起來之程式。 config：內含此專案網站之環境設定、資料庫設定等設定程式。 database：放置資料庫設定 (Model)。 public：放置網站入口，透過 index.php 導入 route 之設定首頁 resources：放置 view 的資源，用以呈現網站頁面 routes：放置所有專案 route 的設定，其中較常用之 web.php 做為主要頁面導向及與 controller 的溝通，而 api.php 則作為專案提供 api 的設定。 storage：主要放置些程式生成的檔案如頁面樣板 (Blade templates)、系統記錄 (logs)、file caches、file based sessions 等資料。 tests：放置測試用的案例 (Test Case)。 vendor：放置透過 composer 下載管理的套件。 artisan：可於專案中透過 php artisan 執行 Laravel 設計好的基本操作行為，如建立 controller 等動作。 composer.json：管理專案使用套件，詳細用法見 composer 官方說明。 composer.lock：鎖定專案使用套件版號。 package.json：管理 npm 套件，主要提供給前端使用。 phpunit.xml：phpunit 測試設定檔，可規範執行單元測試之範圍，做批量測試。 webpack.mix.js：build 設定檔，幫助我們將 resources 中之 js 及 sass 等前端設定檔 compile 成 js、css 等檔案並 deploy 到 public 中供頁面使用。 ","date":"2022-03-02","objectID":"/laravel/:4:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"建立第一個 Laravel 網頁 文章參考來源 下面教學流程是參考ReccaChao Laravel 6.0 初體驗！怎麼用最新的 laravel 架網站！ 的文章下去學習以及介紹，在學習過程中再加上自己的理解以及不同範例的筆記來分享給大家，大家也可以先去瀏覽大大的文章，再回來呦XD 我們經過千辛萬苦，將 Laravel 給安裝好，也設定好它所需的環境參數，打開 IED 準備開始學習如何建立第一個 Laravel 網頁吧！ 在開始說明前，還要先下一個指令。在介紹 Laravel 專案下的資料夾以及檔案中，其中一個 “Artisan”，是 Laravel 專用的指令工具，可以幫我們處理很多事情。 像是我們現在要啟動內建的伺服器來瀏覽我們的網站，這時我們要下 $ poser global requirephp artisan serve Laravel development server started: \u003chttp://127.0.0.1:8000\u003e [Thu Mar 3 15:13:07 2022] 127.0.0.1:52345 [200]: /favicon.ico 這個伺服器會在這個終端機下被建立，屬於這個專案的伺服器，如果想要關閉，可以使用 Ctrl + C 來關閉。 小提醒 由於此伺服器是專屬於該專案的伺服器，所以下指令時，也要在該專案的目錄下歐！ 如果想要使用特定的 Port ，可以在後面加入此參數，就可以依照設定的 Port 來當作我們伺服器的位子囉！(預設是8000 Port) $ php artisan serve --port=7777 Laravel development server started: \u003chttp://127.0.0.1:7777\u003e [Thu Mar 3 15:45:23 2022] 127.0.0.1:54206 [200]: /favicon.ico 維護模式 當我們想要修改系統或是資料庫的欄位時，就可以將該網站設定成維修模式。Laravel 讓這個工作變得很容易，只需要用以下兩個指令來控制 啟動維護模式 $ php artisan down --message=\"Upgrading Database\" --retry=60 還可以設定一些參數， --message 是用來顯示或紀錄客製化訊息， --retry 用來當作HTTP head 的 Retry-After 的值 Laravel 維護模式顯示頁面\" Laravel 維護模式顯示頁面 關閉維護模式 $ php artisan up 維護模式顯示模板 維護模式顯示的預設模板放置在 resources/views/errors/503.blade.php。你可以自由的根據需求修改。 Routes 路由 我們要來建立我的第一個網頁，網頁的其中一個關鍵就是路徑。那我們網站的路徑，在 Laravel 裡面，都放置在 routes/ 裡面，打開後可以看到4個檔案有 web.php：這個和我們現在要說明的路徑有關，我們在瀏覽器打的網址，前面是 domain name，那在 domain 之後的字串，會在我們這個檔案裡面來定義哪些字串要導向哪一個流程或是檔案，範例 url:{domain}/hello-world。 api.php：我們在做前後端分離的專案時會使用這個檔案，與 web.php 功能差不多，預設用來管理 API 的路徑。 channels.php：和 Broadcast 有關係，這個是 Laravel 的廣播功能，不太常使用，所以先跳過，之後有碰到再來說明。 console.php：這個和我們指令有關，像是我們上面介紹的 php artisan ，這個檔案就是和這個部分有關。 web.php 那我們就先來針對 web.php 來做介紹，我們剛剛使用指令開啟的伺服器網址是 http://127.0.0.1:8000，使用瀏覽器進入後，可以看到下面這個 Laravel 預設的頁面(此為 Laravel 5.4版本，新版的好像不太一樣) Laravel 預設首頁\" Laravel 預設首頁 那我們開啟 routes/web.php 檔案中，可以看到下面這一段預設的路由 Route::get('/', function () { return view('welcome'); }); 這段的意思就是代表，如果我們網址沒有輸入其他的目錄，就會顯示 welcome 這個網頁，那 welcome 這個顯示的畫面，就放在 resources/view 底下名為 welcome.blade.php 的檔案中，打開來看就是簡單的 HTML。 那現在我們了解路由的含義，現在換我們來實作一個看看，首先我們希望網址列輸入 https://127.0.0.1:8000/hello-world 可以出現 hello world 的字樣，那我們可以到 web.php 中，新增下面這個路由 Route::get('/hello-world', function () { return view('hello-world'); }); 再到到 resources/view 新增 hello-world.blade.php 檔案，簡單輸入 HTML 格式，如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e hello ~ pinyi \u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 使用瀏覽器在網址列輸入 http://127.0.0.1/hello-world ，就可以看到顯示 hello ~ pinyi 的字樣囉～ 除了回傳網頁來做顯示以外，也可以單獨回傳字串，並帶入參數歐，我們來試試看要怎麼做。 首先我們先將路由修改成下方，讓我們在 hello-world 後面可以輸入我們的名稱，並且顯示在畫面上 Route::get('/hello-world/{name}', function ($name) { return 'hello ~ ' . $name; }); 我們在網址列輸入 http://127.0.0.1/hello-world/pinyi 就會顯示 hello ~ pinyi ，很神奇吧，只要在括號中 {} 輸入你要的參數，並且後面的 function 也要帶入參數，就可以將資料給帶進去了 ! api.php 我們可以看到 api.php 檔案也是使用 Route 來運作，如下 Route::middleware('auth:api')-\u003eget('/user', function (Request $request) { return $request-\u003euser(); }); middleware 就是一種過濾或是防火牆的概念，這個我們後續會再說明。 我們也在此新增一個跟上面一樣的 hello-world，如下 Route::get('/hello-world', function () { return 'Hello World ~'; }); 在 api.php 比較特別的部分是需要在字串前面加入 api ，因為 api.php 就是預設讓我們來放 api 的地方，如範例 url:{domain}/api/hello-world，那就會回傳 hello world ~ View Blade 模板引擎 我們已經知道要怎麼透過路由，讓使用者輸入網址後，根據網址指向想要呈現的畫面，那我們的畫面要怎麼呈現呢 !? 上面有使用簡單的 HTML 來做說明，那本章節就來介紹怎麼修改我們的前端輸出吧。 Layout 我們在設計網頁時，通常都會使用樣板，讓網頁相同的地方只做一次就可以顯示，不需要每一個頁面都重複寫相同的程式碼，只需要在想要顯示的地方來顯示各自的內容就好 如果聽不太懂，我以我的 Blog 來舉例，紅色框框，在每一頁都會顯示，我們可以把他寫成一個檔案，就不需要每頁都重複去寫，藍色框框，會依照每一頁的內容來做顯示。 PinYi 小天地\" PinYi 小天地 那我們可以透過 Laravel 的 Blade Engine 輕鬆地達到這件事情，首先，到 resources/views/ 目錄下建立一個叫 layouts 的資料夾。這個資料夾之後會讓我們來放不同的模板 在 layouts 下建立一個 header.blade.php 檔案，內容如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e測試網站，我是標題\u003c/h1\u003e \u003cdiv class=\"container\"\u003e @yield('content') \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 可以看到我們","date":"2022-03-02","objectID":"/laravel/:4:4","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"RESTful API 實現 CRUD 接下來，就來到我們本次的重點，要使用 Laravel 來開發出留言板功能，搭配使用 RESTful API 來實現 CRUD 老樣子，我們先來設定我們的 route 路由，這次實作的是留言板，所以我們希望網址是 http://127.0.0.1:8000/api/messages，因為這次是 API，先到 routes/api.php 底下來設定 \u003c?php use Illuminate\\Http\\Request; /* |-------------------------------------------------------------------------- | API Routes |-------------------------------------------------------------------------- | | Here is where you can register API routes for your application. These | routes are loaded by the RouteServiceProvider within a group which | is assigned the \"api\" middleware group. Enjoy building your API! | */ Route::get('messages', 'MessageController@getAllMessages'); // 查詢全部留言 Route::get('messages/{id}', 'MessageController@getMessages'); // 查詢 {id} 留言 Route::post('messages', 'MessageController@createMessages'); // 新增留言 Route::put('messages/{id}', 'MessageController@updateMessages'); // 修改 {id} 留言 Route::delete('messages/{id}', 'MessageController@deleteMessages'); //刪除 {id} 留言 已經忘記的，可以先回到 Controller 控制器 複習一下上面的路由是什麼意思。 接下來，我們使用 建立屬於自己的 migration 來生成我們本次要使用的資料表，再來新增一個與 Eloquent Model 相同的物件，選擇我們要的資料表 \u003c?php namespace App; use Illuminate\\Database\\Eloquent\\Model; class Message extends Model { protected $table = 'Messages'; protected $fillable = [ 'name','content','created_at','updated_at' ]; } 都好了我們來撰寫我們的 controller，我會依照每一個功能(CRUD)來做說明，要記得加入剛剛的 model use App\\Message;。 查詢全部留言 class MessageController extends Controller { // 查詢全部留言 public function getAllMessages() { $messages = Message::get(['id','name','content','created_at','updated_at'])-\u003etoJson(JSON_PRETTY_PRINT); return response($messages, 200); } } 會依照 model 選擇的資料表來做查詢，只顯示 id、name、content 、created_at 、updated_at 五個欄位，並把他用 JSON 表示，最後用 response() 來回應 status code。 查詢{id}留言 class MessageController extends Controller { // 查詢{id}留言 public function getMessages($id) { if (Message::where('id',$id)-\u003eexists()) { $messages = Message::where('id',$id)-\u003eget(['id','name','content','created_at','updated_at'])-\u003etoJson(JSON_PRETTY_PRINT); return response($messages, 200); } else { return response()-\u003ejson([\"messages\" =\u003e \"找不到訊息\"], 404); } } } 先判斷輸入的 id 是否存在，如果存在才顯示 id、name、content 、created_at 、updated_at 五個欄位，並把他用 JSON 表示，最後用 response() 來回應 status code，如果不存在，直接用 JSON 表示 response() 404錯誤訊息。 新增留言 class MessageController extends Controller { // 查詢{id}留言 public function createMessages(Request $request) { if (strlen($request-\u003econtent)\u003c20){ $messages = new Message; $messages-\u003ename = $request-\u003ename; $messages-\u003econtent = $request-\u003econtent; $messages-\u003eupdated_at = NULL; $messages-\u003esave(); return response()-\u003ejson([\"messages\" =\u003e \"新增紀錄成功\"], 201); } if (strlen($request-\u003econtent)\u003e20){ return response()-\u003ejson([\"messages\" =\u003e \"內容長度超過20個字元\"], 400); } } } 我們希望輸入的內容不要超過20的字，所以我們先用 strlen() 來判斷輸入長度，如果小於20，就將 request 輸入的名字及內容輸入，用 save() 來儲存，並把他用 JSON 表示，最後用 response() 來回應 status code，如果小於20，直接用 JSON 表示 response() 400錯誤訊息。 修改留言 class MessageController extends Controller { // 修改{id}留言 public function updateMessages(Request $request,$id) { if (Message::where('id',$id)-\u003eexists() \u0026\u0026 Message::where('version',0)-\u003elockForUpdate() ) { if (strlen($request-\u003econtent)\u003c20){ $messages = Message::find($id); $messages-\u003ename = is_null($request-\u003ename) ? $messages-\u003ename : $request-\u003ename; $messages-\u003econtent = is_null($request-\u003econtent) ? $messages-\u003econtent : $request-\u003econtent; $messages-\u003eversion = '1'; $messages-\u003esave(); return response()-\u003ejson([\"message\" =\u003e \"修改成功\"],200); } if (strlen($request-\u003econtent)\u003e20){ return response()-\u003ejson([\"messages\" =\u003e \"內容長度超過20個字元\"], 400); } } else { return response()-\u003ejson([\"message\" =\u003e \"找不到訊息\"],404); } } 先判斷輸入的 id 是否存在以及是否有被上鎖，在判斷輸入的長度，如果小於20，再判斷是否有輸入，有就將 request 輸入的值輸入，用 save() 來儲存，並把他用 JSON 表示，最後用 response() 來回應 status code，如果小於20，直接用 JSON 表示 response() 400錯誤訊息。 刪除留言 class MessageController extends Controller { // 刪除{id}留言 public function deleteMessages($id) { if (Message::where('id',$id)-\u003eexists()) { $messages = Message::find($id); $messages-\u003edelete(); return response()-\u003ejson([\"message\" =\u003e \"刪除成功,沒有返回任何內容\"],204); ","date":"2022-03-02","objectID":"/laravel/:4:5","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"測試 寫完程式後，除了自己一個一個去測試，也可以寫成程式來測試是否有錯誤。會在此談到測試，是因為自動測試變得簡單也是 Laravel 這個框架的一個重要特性。 那我先來說明一下什麼是自動測試 簡單來說，常見的測試，就是我們在完成新功能後，會一個一個實際去測試我們寫的功能，是不是跟我們預想的那樣子運行。 一開始網站還小，功能不多時，還可以應付。但當網站越來越龐大，功能越來越多後，或是要使用不同權限帳號來檢查所有功能，會很辛苦的。 幸好，我們可以用自動測試的程式來解決這些瑣事！ 如果我們每次為每個功能撰寫程式時，都寫另一段小程式來測試這個功能。 隨著時間過去，需求的改變，雖然功能越來越多，但是相對應的，測試這些功能的程式也會越來越多，並且不管這個功能是多久之前開發的，每個功能都有相對應的測試。 ","date":"2022-03-02","objectID":"/laravel/:5:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"如何運行自動測試 在 PHP 的世界，自動測試通常使用 PHPUnit 這個工具。然後 Laravel 在安裝時，也自動幫我們安裝這個工具了～ Laravel 幫我們把 PHPUnit 安裝在 vendor/ 裡面，我們來看看要怎麼使用它吧！使用的指令如下 $ vendor/phpunit/phpunit/phpunit PHPUnit 5.7.27 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 146 ms, Memory: 10.00MB OK (2 tests, 2 assertions) 奇怪，我們什麼都還沒做，為什麼會有兩個程式已經通過測試了，是因為 Laravel 預設兩個檔案來當測試的案例，分別位於 tests/Feature/ExampleTest.php 以及 tests/Unit/ExampleTest.php (單元測試)，我這邊就簡單說明 Feature/ExampleTest.php 這個測試程式做哪些事情 \u003c?php namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; use Illuminate\\Foundation\\Testing\\DatabaseMigrations; use Illuminate\\Foundation\\Testing\\DatabaseTransactions; class ExampleTest extends TestCase { /** * A basic test example. * * @return void */ public function testBasicTest() { $response = $this-\u003eget('/'); $response-\u003eassertStatus(200); } } 這個 Feature/ExampleTest.php 的 testBasicTest() 會檢查如果連線到 / ，HTTP Status 有沒有回傳 200 (成功連線)，這個測試功能就是在檢查首頁是否存在 ～ ","date":"2022-03-02","objectID":"/laravel/:5:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"實作測試程式 大概了解原理後，一樣我們來實作看看，那我們先來輸入指令，產生一個測試程式 $ php artisan make:test HelloWorldTest Test created successfully. Laravel 會自動幫我們在 tests/Feature 底下新增了 HelloWorldTest.php 檔案，內容如下(框架版本5.4) \u003c?php namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; use Illuminate\\Foundation\\Testing\\DatabaseMigrations; use Illuminate\\Foundation\\Testing\\DatabaseTransactions; class HelloWorldTest extends TestCase { /** * A basic test example. * * @return void */ public function testExample() { $this-\u003eassertTrue(true); } } 我們測試的項目是想要連線到 hello-world/ 目錄，HTTP Status 會回傳 200 ，以及網站內要看到『 hello world ~ 』的文字，我們將他預設的 testExample() 的內容改成 public function testExample() { $response = $this-\u003eget('/hello-world'); // 如果連線 hello-world/，HTTP Status 應該要顯示 200 $response-\u003eassertStatus(200); //連線到網頁內，應該要可以看到「『 hello world ~』文字 $response-\u003eassertSee('hello world ~'); } 來運作一下吧，一樣使用同樣的指令來做測試，順便讓大家看一下測試錯誤的錯誤訊息吧！ $ vendor/phpunit/phpunit/phpunit PHPUnit 5.7.27 by Sebastian Bergmann and contributors. .F. 3 / 3 (100%) Time: 200 ms, Memory: 10.00MB There was 1 failure: 1) Tests\\Feature\\HelloWorldTest::testExample Expected status code 200 but received 404. Failed asserting that false is true. FAILURES! Tests: 3, Assertions: 3, Failures: 1. 我故意在 routes 下沒有放 hello-world/ 路徑，所以返回顯示 404 ，而不是 200 ，因此，就可以知道要怎麼去修改程式囉 ! ","date":"2022-03-02","objectID":"/laravel/:5:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Artisan 相關指令 ","date":"2022-03-02","objectID":"/laravel/:6:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Controller php artisan make:controller {檔案名稱}Controller //建立一個 Controller ","date":"2022-03-02","objectID":"/laravel/:6:1","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Migration php artisan make:seeder //產生seeder檔案 php artisan make:factory //產生factory 檔案 php artisan make:migration //產生migration 檔案 php artisan migrate //將這次的migration讀入資料庫建立架構 php artisan migrate:rollback //推回上一次的migration php artisan migrate:reset //推回全數的migration php artisan migrate:refresh //推回所有遷移並且再執行一次 php artisan migrate --seed //將這次的migration讀入資料庫建立架構並且也跑seeder php artisan migrate:refresh --seed //推回所有遷移並且再執行一次以及seeder php artisan db:seed //單純跑資料的seeder 填充資料 ","date":"2022-03-02","objectID":"/laravel/:6:2","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"Test php artisan make:test {檔案名稱} //測試程式 想必大家到這步驟已經對 Laravel 不陌生了，已經熟悉上面的教學介紹後，可以再去學習下一篇 Laravel 進階，會有如何使用內建會員系統，以及如何判斷 RESTful API 是否登入等進階實作ㄡ～ ","date":"2022-03-02","objectID":"/laravel/:6:3","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"參考資料 PHP與Laravel簡介 比較 PHP 網頁框架 Laravel 從入門到放棄 (一) – 透過 composer 架設 laravel 網站 PHP Laravel 安裝教學 資料庫設計概念 - ORM Laravel 6.0 初體驗！怎麼用最新的 laravel 架網站！ Laravel Route(路由) ","date":"2022-03-02","objectID":"/laravel/:7:0","tags":["PHP","框架","Laravel","RESTful API","實作","介紹"],"title":"Laravel 介紹 (使用 Laravel 從零到有開發出一個留言板功能並搭配 RESTful API 來實現 CRUD) ","uri":"/laravel/"},{"categories":["codenotes"],"content":"由於網路上文章幾乎都是使用 Apache 來實作第一個 PHP RESTful API，也比較沒有中文的介紹，剛好這次也還在學習，所以把學習的紀錄分享給大家，這次會搭配實作留言板來說明，那本次教學內容採用的是 macOS 11.6 Nginx 1.21.6 PHP 8.1.2 無框架 無物件導向 來做教學以及示範，那我們先來簡單了解一下什麼是RESTful API： ","date":"2022-02-24","objectID":"/php-restful-api/:0:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"什麼是RESTful API ","date":"2022-02-24","objectID":"/php-restful-api/:1:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"定義 REST ，指得是一組架構約束條件和原則，符合 REST 設計風格的Web API 稱為 RESTful API，主要以下面三點為定義 直觀簡單的資源網址 URL 比如：http://example.com/resources 對資源的操作：Web 服務在該資源上所支持的請求方法，比如：POST、GET、PUT、PATCH、DELETE 傳輸的資源：Web 服務接受與返回的類型，比如：JSON、XML 分別說明每一項定義 直觀簡單的資源網址 URL RESTful API URL 結構 (Best Practices for RESTful API Design)\" RESTful API URL 結構 (Best Practices for RESTful API Design) 可以看到這張圖後面的 Endpoint，分別代表應用服務 (Application context) 、 版本 (Version)、 資源(Resource)、 參數(Parameter) 。 應用服務：可以取名 api 或是 restful-api 。 版本：可以對 API 進行版本控制，可以有升級的服務，也不會對現有的 API 造成影響。 資源：要使用名詞而非動詞來命名，且建議使用複數 壞的命名(以我們要實作的留言板查詢、新增、修改、刪除示範) 查詢 /selectmessage 新增 /createmessage 修改 /updatemessage 刪除 /deletemessage 好的命名 查詢 GET =\u003e /messages (回傳所有留言) 新增 POST =\u003e /messages (新增留言) 修改 PUT =\u003e /messages/1 (修改單筆留言全部資料) 修改 PATCH =\u003e /messages/1 (修改單筆留言有更動資料) 刪除 DELETE =\u003e /messages/1 (刪除單筆留言) 對資源的操作 RESTful API 傳送時，會依照我們所定的 HTTP Request Method 請求方法，那主要有以下 5 種的 Method GET : 此方法只能向指定的資源要求取得資料，並不會更動內部的資料 POST：向指定的資源要求新增資料 PUT：向指定的資源要求修改資料內容 PATCH：向指定的資源要求修改部分資料內容 DELETE：向指定的資源要求刪除資料內容 傳輸的資源 剛剛是客戶端對伺服器的請求，那我們也要針對他的請求給予對應的回應 Response ，那回應的格式有 JSON 、XML ，但都以 JSON 較為普遍，所以我們後續實作也會以 JSON 作為我們的 Response 。 回應的格式內容會依照文件所自訂，但基本上都會回傳狀態碼 http status code ，下面就用表格的方式來說明常用的狀態碼、以及狀態碼對應的意思跟我們在 RESTful API 使用的場景。 狀態碼 名稱 說明 RESRful API 使用場景 200 OK 請求成功 GET、PUT 方法，取得資料 201 Created 新的資源已建立 POST 方法，新增資料 204 No Content 沒有返回任何內容 DELETE 方法，刪除資料 400 Bad Request 請求不正確 401 Unauthorized 用戶需要認證 403 Forbidden 禁止訪問，與401 不同的是，用戶已經認證，但沒有權限 404 Not Found 沒有找到指定的資源 GET、PUT、DELETE 方法，該資料不存在 500 Internal Server Error 伺服器發生錯誤 ( 參考RESTful Web API 設計指南 ) ","date":"2022-02-24","objectID":"/php-restful-api/:1:1","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"為什麼要使用 RESTful API REST 使用所有標準 HTTP 協議方法 - GET、POST、PUT、DELETE、PATCH ，以及更具體的 URL 。 REST 將客戶端與伺服器之間的操作分開 - 他允許開發人員使用它們希望使用的任何前端技術，包含像是 AngularJS、Bootstrap、VUE、Ember、ReactJS、CycleJS、ExtJS、PHP、.NET 等等，極大提高了可移植性。 REST 針對 web 進行了優化 - 因為它依賴 HTTP 協議。此外，由於它的主要數據格式是 JSON，它基本上兼容所有互聯網瀏覽器。 ","date":"2022-02-24","objectID":"/php-restful-api/:1:2","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"RESTful API 安全性 我們在設計 API 時，要確保 RESTful API 的安全性，像是 PUT 、 DELETE 更新刪除這類型的操作並不安全，沒有權限認證下任何人都可以使用來操作，總不可能讓陌生人去更動我們的資料吧？因此安全性沒有做足夠容易成為駭客攻擊的對象。 要怎麼做比較安全？ 例如我們的留言板：登入後(帳號密碼) \u003e 伺服器驗證成功並取的一組的 API token \u003e 就可以使用這組 token 來訪問 API 資源，也就知道是誰去對這筆資料進行操作 ","date":"2022-02-24","objectID":"/php-restful-api/:1:3","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"實作開始 ","date":"2022-02-24","objectID":"/php-restful-api/:2:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"1. 修改 Nginx.conf 我們這邊就直接對架設好的 Nginx 設定檔來修改，如果不清楚要怎麼架設的，這方面網路上蠻多文章，如果還是不清楚，可以留言告訴我，我在另外寫一篇文章來介紹環境安裝。 為什麼要先修改 conf 呢？修改的目的就是要讓原本網址 http://localhost/api/index.php?messages=all 變成 http://localhost/api/messages 來實現我們在介紹時所說的直觀簡單的資源網址，我說明一下上面網址的關係， http://localhost 是因為我們本地端運行，如果已經上線的，那就是你自己的網址， /api 是我來放這支 api 的目錄，他位於網頁的根目錄下方(詳細的配置下方會附上)， index.php 是我來放這支 api 的網頁，後面的 messages 是我們這次的資源，後面可以接我想要處理的參數 那要怎麼達成讓網址變成我們想要呈現的直觀簡單的網址呢，這時候我們就要使用 Nginx.conf 來做設定，網路上的文章比較多的是 apache 的 htaccess，我一開始還以為 Nginx 也可以使用 htaccess ，試了半天才知道，在 Nginx 要改用 Nginx.conf 來設定，那我下方會附上我原本的 .htaccess 以及轉換後的 conf，那接下來我一步一步來介紹 線上轉換工具 網路上蠻多工具可以線上轉換，我推薦可以用 Apache htaccess to Nginx converter Apache .htaccess 檔案 RewriteRule ^/api/messages$ /api/index.php?messages=all [nc,qsa] RewriteRule ^/api/messages/(\\d+)$ /api/index.php?messages=$1 [nc,qsa] 這是我會修改部分的 Nginx.conf ，可以看到最後兩條 location，這邊就是我們轉換過來的設定 Nginx.conf 檔案(片段) server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm index.php; } location = /api/messages { rewrite ^(.*)$ /api/index.php?messages=all; } location /api { rewrite ^/api/messages/(\\d+)$ /api/index.php?messages=$1; } 他的意思代表的我們網址路徑是在 /api/messages ，我們讓原本 /api/index.php?messages 這段變成 /api/messages/ 的設定，設定好記得先下 sh sudo nginx -t 指令來檢查一下Nginx.conf檔案是不是都正確，再用 sh sudo nginx -s reload 指令重新啟動 Nginx (是否成功，後面會帶到如何做測試，就繼續一起往下看吧！) CREATETABLE`messages`(`id`intNOTNULL,`name`varchar(20)CHARACTERSETutf8mb4COLLATEutf8mb4_unicode_ciNOTNULL,`message`textCHARACTERSETutf8mb4COLLATEutf8mb4_unicode_ciNOTNULL,`sendtime`datetimeNOTNULL,`version`intDEFAULTNULL)ENGINE=InnoDBDEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci; ","date":"2022-02-24","objectID":"/php-restful-api/:2:1","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"參考資料 PHP實現RESTful風格的API實例 [XAMPP][PHP] 製作Restful API Best Practices for RESTful API Design RESTful API與MVC名詞介紹 ","date":"2022-02-24","objectID":"/php-restful-api/:3:0","tags":["PHP","RESTful API","Nginx","實作","介紹"],"title":"如何在 Nginx 下實作第一個 PHP 留言板 RESTful API","uri":"/php-restful-api/"},{"categories":["codenotes"],"content":"1. PHP 是什麼 PHP 全名是超文本前處理器(Hypertext Preprocessor)，是一種開源的通用電腦手稿語言 根據W3Techs的報告，截至2021年9月，有78.9%網站都是使用PHP，像是著名的 FaceBook、Tesla、Slack、WordPress stackshare 是分享開發工具的網站，可以看到不少公司也是使用PHP來進行開發的 其優點是 是開源、免費的 是跨平台的開發語言，Linux、Windows、macOS也可以使用 能開發：動態網站、爬蟲程式、WordPress 外掛佈景主題 也可以結合多種的資料庫，例如：Mysql、Mariadb、Oracle 過去使用 PHP 開發網頁程式，就是有什麼寫什麼，程式邏輯和網頁顯示混在一起，雖然開發方便但會造成高維護成本，和難以擴充功能 物件導向程式設計 函數式編程 事件驅動程式開發 PHP 有各式各樣的 Web Framework： Laravel - 最受歡迎的PHP Web Framewrok Codelgniter - 最新版的Codelgniter4 只有 1.4 MB，小而強 ","date":"2022-02-22","objectID":"/php/:1:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"php-cli vs php-fpm CGI CGI 是一種協定，為了保障 web server 傳過來的資料是標準格式 如果請求 index.html ，web server 會先去找這個文件，在丟給瀏覽器，但這個僅限靜態文件而已 如果請求 index.php ，就需要去找 php 的解析器來處理，那處理中一定會傳遞一些資料，像是 post 或是 url 還有 http header等，CGI 就是規定要傳哪些資料、以及怎麼樣的格式 FastCGI 是用來提高 CGI 處理性能用的 PHP-cli vs PHP-fpm PHP-cli 可以直接在命令列使用php命令來處理或顯示 php檔案，因為他內建了一個 HTTP 伺服器，可以提供 HTTP 服務 PHP-fpm 是一個多進程架構的 FastCGI 服務，內建了 PHP 的解析器，配合Nginx來使用 ","date":"2022-02-22","objectID":"/php/:1:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"2. PHP 基本語法 ","date":"2022-02-22","objectID":"/php/:2:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"標籤 PHP 程式可以放置在檔案中的任何位置，其檔案副檔名是.php， PHP的標籤是開頭 \u003c ?php 以及 ? \u003e 結尾 \u003c?php [ 程式碼 ] ?\u003e PHP 不分大小寫，例如 if、else、while、echo，函數等，但變數有區分大小寫 $color = 'blue'; echo \"My car is \" . $color . \"\u003cbr\u003e\"; ECHo \"My car is \" . $cOLOr . \"\u003cbr\u003e\"; eCHo \"My car is \" . $COLOR . \"\u003cbr\u003e\"; My car is blue My pen is My dog is ","date":"2022-02-22","objectID":"/php/:2:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"註解 PHP 程式中可以使用註解功能，註解後該段程式不會被執行 PHP 單行註解 // 註解的用意是可以告訴自己或是閱讀該程式的人該行程式碼的用意或想法 PHP 多行註解 /* 註解的用意是可以告訴自己或是閱讀該程式的人該行程式碼的用意或想法 echo \"My car is \" . $color . \"\u003cbr\u003e\"; ECHo \"My car is \" . $cOLOr . \"\u003cbr\u003e\"; eCHo \"My car is \" . $COLOR . \"\u003cbr\u003e\"; */ ","date":"2022-02-22","objectID":"/php/:2:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"變數 PHP 程式中可以使用變數功能，變數是儲存訊息的容器，變數以\" $ “符號開頭，後面是變數名稱 PHP 變數規則 變數名必須以字母或是下底線開頭，不可以用數字開頭 變數名只包含字母數字或是下底線(A-z、0-9、_) 變數名區分大小寫 ($age 跟 $AGE 是兩個不同的變數) $color = 'blue'; $items = 'Toy'; $num1 = '13'; $num2 = '18'; echo \"I have \" . $num1+$num2 . \" \" . $color . \" \" . $items; I have 31 blue Toy ","date":"2022-02-22","objectID":"/php/:2:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"變數作用區 PHP 變數有不同的作用區(local、global、static) local 函式中的變數具有local scope，只能用於該函式中使用 \u003c?php function myTest() { $x = 5; // local scope echo \"\u003cp\u003eVariable x inside function is: $x\u003c/p\u003e\"; } myTest(); // using x outside the function will generate an error echo \"\u003cp\u003eVariable x outside function is: $x\u003c/p\u003e\"; ?\u003e Variable x inside function is: 5 Variable x outside function is: global 函式外部的變數具有global scope，只能用於該函式外部使用 \u003c?php $x = 5; // global scope function myTest() { // using x inside this function will generate an error echo \"\u003cp\u003eVariable x inside function is: $x\u003c/p\u003e\"; } myTest(); echo \"\u003cp\u003eVariable x outside function is: $x\u003c/p\u003e\"; ?\u003e Variable x inside function is: Variable x outside function is: 5 想要在函式中，用外部的變數，就在函式內用global 來定義變數 \u003c?php $x = 5; $y = 10; function myTest() { global $x, $y; $y = $x + $y; } myTest(); echo $y; // outputs 15 ?\u003e 15 static 正常函式執行完，變數值都會被刪除，想要保留值可以加 static \u003c?php function myTest() { static $x = 0; echo $x; $x++; } myTest(); myTest(); myTest(); ?\u003e 012 ","date":"2022-02-22","objectID":"/php/:2:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"顯示 PHP 程式中可以用 echo 以及 print 來顯示資訊 PHP echo / print 顯示 \u003c?php $txt1 = \"學習PHP\"; $txt2 = \"Ian_Zhuang\"; $x = 5; $y = 4; echo \"\u003ch2\u003e\" . $txt1 . \"\u003c/h2\u003e\"; echo $txt2 . \" 在 \" . $txt1 . \"\u003cbr\u003e\"; echo $x + $y; print \"\u003ch2\u003e\" . $txt1 . \"\u003c/h2\u003e\"; print $txt2 . \" 在 \" . $txt1 . \"\u003cbr\u003e\"; print $x + $y; ?\u003e 學習PHP Ian_Zhuang 在 學習PHP 9 學習PHP Ian_Zhuang 在 學習PHP 9 ","date":"2022-02-22","objectID":"/php/:2:5","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"資料型態 變數可以儲存不同型態的資料，以下是 PHP 支持的資料型態 小提示 可以用var_dump() 函數來查看資料的型態以及值 字串 (String) 整數 (Integer) 浮點數 (Float) 布林 (Boolean) 陣列 (Array) 物件 (Object) 空值 (NULL) 字串 (String) 字串可以是引號內的任何文本，可以使用單引號或雙引號來表示 \u003c?php $x = \"Hello world!\"; $y = 'Hello world!'; echo $x; echo \"\u003cbr\u003e\"; echo $y; ?\u003e Hello world! Hello world! 整數 (Integer) 整數有幾點規則： 必須至少有一個數字 不能有小數點 可以是正數也可以是負數 可以指定不同的進制表示法 其範圍介於 -2,147,483,648 和 2,147,483,647 之間的非十進制數 \u003c?php $x = 5985; var_dump($x); ?\u003e int 5985 浮點數 (Float) 浮點數是帶小數點的數字或指數形式的數字 \u003c?php $x = 10.365; var_dump($x); ?\u003e float 10.365 布林 (Boolean) 布爾值表示兩種可能的狀態：TRUE 或 FALSE \u003c?php $x = true; $y = false; var_dump($x); ?\u003e boolean true 陣列 (Array) 陣列可以將多個值存在一個變數中 \u003c?php $x = 10.365; var_dump($x); ?\u003e array (size=3) 0 =\u003e string 'Apple' (length=5) 1 =\u003e string '小米' (length=6) 2 =\u003e string 'Sony' (length=4) 物件 (Object) 在討論物件前，要先知道類別(Class)與物件(Object)的關係 類別 (Class) ：可以比喻為房屋的設計藍圖，是為了讓大家了解房屋的結構與形狀。 物件 (Object) ：可以比喻為真的房屋，物件是類別的實體化 為了要蓋好一棟房子有房子的設計藍圖(類別)還不夠，還需要蓋房子的材料，而材料就是所謂的資料(data)。 類別定義結構和行為用來產生物件，當多個物件是由同一 個類別產生出來時，每個物件都是一個獨立個體。 建立類別語法很簡單，只需要使用 Class 來定義一個類別 \u003c?php class MyClass { // 在大括號裡面宣告類別的屬性與方法 } $obj = new MyClass; //使用 new 來實體化類別並將他存入變數中 var_dump($obj); //查看類別內容 ?\u003e object(MyClass)[1] 我們在替 MyClass 加入屬性，用 public 決定屬性的可視性 \u003c?php class MyClass { public $prop = \"I'm a class Property\"; } $obj = new MyClass; echo $obj-\u003eprop; ?\u003e I'm a class Property 因為有很多物件實例化都來自同一個類別，如果沒有指定被實體化的物件，程式碼會無法判斷，所以要用 -\u003e 在 PHP 的物件中，來存取物件的屬性和方法。 定義類別(Class)的方法(Methods)，方法(Methods)是類別裡面的函式(Functions)，物件可以藉由執行這些方法來更動每個物件的行為。 \u003c?php class MyClass { public $prop = \"I'm a class Property!\"; public function set($newval) { $this-\u003eprop = $newval; } public function get() { return $this-\u003eprop . \"\u003cbr /\u003e\"; } } $obj = new MyClass; echo $obj-\u003eget(); //得到屬性的值。 $obj-\u003eset(\"I'm a new Property value!\"); //設定新的屬性的值。 echo $obj-\u003eget(); ?\u003e I'm a class Property! I'm a new Property value! 物件導向允許物件透過$this來參考自己。物件使用$this就如同直接使用物件名稱來指定物件，同等於MyClass-\u003eprop1。 空值 (NULL) Null 是一種特殊的數據類型，它只能有一個值：NULL 如果創建的變量沒有值，則會自動為其分配 NULL \u003c?php $x = \"Hello world!\"; $x = null; var_dump($x); ?\u003e null ","date":"2022-02-22","objectID":"/php/:2:6","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"運算符號 PHP 將運算符號分為以下幾組 算術運算符 賦值運算符 比較運算符 邏輯運算符 字符串運算符 算術運算符 \u003c?php $x = 3; $y = 6; echo $x + $y; // 輸出 x + y ，3 + 6 ，顯示 9 echo $x - $y; // 輸出 x - y ，3 - 6 ，顯示 -3 echo $x * $y; // 輸出 x * y ，3 * 6 ，顯示 18 echo $x / $y; // 輸出 x / y ，3 / 6 ，顯示 0.5 echo $x % $y; // 輸出 x % y ，3 % 6 ，顯示 3 echo $x ** $y; // 輸出 x ^ y ，3 ^ 6 ，顯示 729 ?\u003e 賦值運算符 \u003c?php $x = 3; $y = 6; echo $x += $y; //輸出 x = x + y ， 9 = 3 + 6 ，輸出 9 $x = 3; $y = 6; echo $x -= $y; //輸出 x = x - y ， -3 = 3 - 6 ，輸出 -3 $x = 3; $y = 6; echo $x *= $y; //輸出 x = x * y ， 18 = 3 * 6 ，輸出 18 $x = 3; $y = 6; echo $x /= $y; //輸出 x = x / y ， 0.5 = 3 / 6 ，輸出 0.5 $x = 3; $y = 6; echo $x %= $y; //輸出 x = x % y ， 3 = 3 % 6 ，輸出 3 ?\u003e 比較運算符 \u003c?php $x = 3; $y = 6; $z = \"6\"; var_dump($x == $y); // 判斷 x 等於 y (值)，3 不等於6 ，回傳 false var_dump($x === $z); // 判斷 x 等於 z (型態and值)，數字不等於字串 ，回傳 false var_dump($x != $y); // 判斷 x 不等於 y (值)，3不等於6 ，回傳 true var_dump($x \u003c\u003e $y); // 判斷 x 不等於 y (型態)，數字不等於字串 ，回傳 true var_dump($x \u003e $y); // 判斷 x 大於 y ，3沒有大於6 ，回傳 false var_dump($x \u003c $y); // 判斷 x 小於 y ，3小於6 ，回傳 true var_dump($x \u003e= $y); // 判斷 x 大於等於 y ，3沒有大於等於6 ，回傳 false var_dump($x \u003c= $y); // 判斷 x 小於等於 y ，3小於等於6 ，回傳 true var_dump($x \u003c=\u003e $y); // 判斷 x y 的關係 ，如果 x 大於 y ，回傳 1 ; 如果 x 小於 y ，就回傳 -1 ; 如果 x 等於 y ，就回傳 0 ?\u003e 邏輯運算符 \u003c?php $x = 3; $y = 6; if ($x == 3 and $y == 6){ echo \"And\"; } // 判斷 x 等於 3 且 y 等於 6 (兩者都要true) if ($x == 3 or $y == 9){ echo \"Or\"; } // 判斷 x 等於 3 或 y 等於 9 (擇一true) if ($x == 3 \u0026\u0026 $y == 6){ echo \"And\"; } // 判斷 x 等於 3 且 y 等於 6 (兩者都要true) if ($x == 3 || $y == 9){ echo \"Or\"; } // 判斷 x 等於 3 或 y 等於 9 (擇一true) if ($x == 3 xor $y == 9){ echo \"Xor\"; } // 判斷 x 等於 3 或 y 等於 9 (任一者為true，但只能一者為true) if ($x != 4){ echo \"Not\"; } // 判斷 x 不等於 4 ?\u003e ","date":"2022-02-22","objectID":"/php/:2:7","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"條件判斷 條件語句用於根據不同的條件下的操作 if if…else if…elseif…else switch if 如果條件為真，就執行代碼 案例：如果現在時間(hour)小於20，就輸出 Have a good day ! \u003c?php $t = date(\"H\"); if ($t \u003c \"20\") { echo \"Have a good day!\"; }s ?\u003e 輸出 Have a good day! if-else 如果條件為真，就執行該程式碼，如果條件為假，就執行另一個程式碼 案例：如果現在時間(hour)小於20，就輸出 Have a good day! ，超過時間，就輸出 Have a good night! \u003c?php $t = date(\"H\"); if ($t \u003c \"20\") { echo \"Have a good day!\"; } else { echo \"Have a good night!\"; } ?\u003e if-elseif-else 針對兩個以上的條件判斷，如果條件為真，就執行該程式碼，如果條件為假，就執行另一個程式碼 案例：如果現在時間(hour)小於10，就輸出 Have a good morning! ，如果時間小於20，輸出Have a good day!，否則，就輸出 Have a good night! \u003c?php $t = date(\"H\"); if ($t \u003c \"10\") { echo \"Have a good morning!\"; } elseif ($t \u003c 20) { echo \"Have a good day!\"; } else { echo \"Have a good night!\"; } ?\u003e switch 根據不同的條件來執行不同的操作 \u003c?php $weather = '下雨天'; switch($weather) { case '晴天': echo \"今天天氣是『 $weather』\"; break; case '陰天': echo \"今天天氣是『 $weather』\"; break; case '下雨天': echo \"今天天氣是『 $weather』\"; break; default: echo \"世界末日\"; break; } ?\u003e ","date":"2022-02-22","objectID":"/php/:2:8","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"迴圈 想要相同程式碼反覆執行一定的次數 while do…while for foreach while 只要指定條件為真，就會循環通過該程式碼 \u003c?php $x = 1; while($x \u003c= 3) { echo \"The number is: $x\u003cbr\u003e\"; $x++; } ?\u003e 輸出 The number is: 1 The number is: 2 The number is: 3 do…while 先執行一次do，再檢查指定條件是否為真，是的話就會循環通過該程式碼 \u003c?php $x = 1; do { echo \"The number is: $x\u003cbr\u003e\"; $x++; } while ($x \u003c= 5); ?\u003e 輸出 The number is: 6 因為do…while的條件會在執行循環程式碼後才檢查，所以do…while 至少會循環一次該程式碼。 for 假如預先知道需要循環幾次，就可以使用for，可以設定程式碼在循環中的次數。 \u003c?php for ($x = 0; $x \u003c= 10; $x++) { echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 2 The number is: 3 The number is: 4 The number is: 5 The number is: 6 The number is: 7 The number is: 8 The number is: 9 The number is: 10 foreach 此循環適用於陣列，可以用來顯示陣列的key跟value \u003c?php $age = array(\"Peter\"=\u003e\"35\", \"Ben\"=\u003e\"37\", \"Joe\"=\u003e\"43\"); foreach($age as $x =\u003e $val) { echo \"$x= $val\u003cbr\u003e\"; } ?\u003e 輸出 Peter = 35 Ben = 37 Joe = 43 break 想要在迴圈執行中跳出，可以使用break 指令，來跳出循環。 \u003c?php for ($x = 0; $x \u003c 10; $x++) { if ($x == 4) { break; } echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 2 The number is: 3 continue continue 與 break 是相對的指令。break 中斷目前執行的迴圈，continue 則是回到迴圈的開頭，執行「下一次」迴圈。 \u003c?php for ($x = 0; $x \u003c 5; $x++) { if ($x == 2) { continue; } echo \"The number is: $x\u003cbr\u003e\"; } ?\u003e 輸出 The number is: 0 The number is: 1 The number is: 3 The number is: 4 ","date":"2022-02-22","objectID":"/php/:2:9","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"函式 PHP除了內建的函式外，還可以創建自己的函式 注意：函式名稱必須以字母或下底線開頭。不區分大小寫。 \u003c?php function writeMsg() { echo \"Hello world!\"; } writeMsg(); // call the function ?\u003e 輸出 Hello world! 也可以在函式裡面放入任意數量的參數，只需要用逗號分開 \u003c?php function familyName($fname, $year) { echo \"$fnameBorn in $year\u003cbr\u003e\"; } familyName(\"Hege\", \"1975\"); familyName(\"Stale\", \"1978\"); familyName(\"Kai Jim\", \"1983\"); ?\u003e 輸出 Hege Born in 1975 Stale Born in 1978 Kai Jim Born in 1983 ","date":"2022-02-22","objectID":"/php/:2:10","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"3. PHP 常用函式 ","date":"2022-02-22","objectID":"/php/:3:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"日期和時間 可以透過輸入參數，顯示想要的日期 d - 代表月份中的某天（01 到 31） m - 代表一個月（01 到 12） Y - 代表年份（四位數） l（小寫“L”）— 代表星期幾 \u003c?php echo \"Today is \" . date(\"Y/m/d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"Y.m.d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"Y-m-d\") . \"\u003cbr\u003e\"; echo \"Today is \" . date(\"l\"); ?\u003e 輸出 Today is 2022/02/22 Today is 2022.02.22 Today is 2022-02-22 Today is Tuesday 可以透過輸入參數，顯示想要的時間 H - 一個小時的 24 小時格式（00 到 23） h - 小時的 12 小時格式，前面補零（01 到 12） i - 前面補零的分鐘（00 到 59） s - 前面補零的秒數（00 到 59） a - 小寫的 Ante meridiem 和 Post meridiem（am 或 pm） \u003c?php date_default_timezone_set(\"Asia/Taipei\"); echo \"The time is \" . date(\"h:i:sa\"); ?\u003e 輸出 The time is 12:12:10am 可以使用 strtotime()，顯示想要的日期 \u003c?php $d=strtotime(\"tomorrow\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; $d=strtotime(\"next Saturday\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; $d=strtotime(\"+3 Months\"); echo date(\"Y-m-d h:i:sa\", $d) . \"\u003cbr\u003e\"; ?\u003e 輸出 2022-02-23 12:00:00am 2022-02-26 12:00:00am 2022-05-22 04:21:41am ","date":"2022-02-22","objectID":"/php/:3:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"json 可以使用 json_encode()，將陣列存為 JSON 格式，也可以用 json_decode()，將JSON格式變成陣列 \u003c?php $age = array(\"Peter\"=\u003e'35', \"Ben\"=\u003e'45', \"Ian\"=\u003e'22'); echo $enjson = json_encode($age); var_dump(json_decode($enjson,true)); ?\u003e 輸出 {\"Peter\":\"35\",\"Ben\":\"45\",\"Ian\":\"22\"} array (size=3) 'Peter' =\u003e string '35' (length=2) 'Ben' =\u003e string '45' (length=2) 'Ian' =\u003e string '22' (length=2) ","date":"2022-02-22","objectID":"/php/:3:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"min/max 可以使用 min()，來找到參數列表裡面的最小值，也可以 max()，來找到參數列表裡面的最大值 \u003c?php echo(min(0, 150, 30, 20, -8, -200)); echo '\u003cbr\u003e'; echo(max(0, 150, 30, 20, -8, -200)); ?\u003e 輸出 -200 150 ","date":"2022-02-22","objectID":"/php/:3:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"abs 可以使用 abs()，將參數值變成絕對值 \u003c?php echo(abs(-6.7)); ?\u003e 輸出 6.7 ","date":"2022-02-22","objectID":"/php/:3:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"round 可以使用 round()，將浮點數四捨五入到最接近的整數 \u003c?php echo(round(0.60)); echo '\u003cbr\u003e'; echo(round(0.49)); ?\u003e 輸出 1 0 ","date":"2022-02-22","objectID":"/php/:3:5","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"rand 可以使用 rand()，會隨機產生一個亂數，也可以設定最大值與最小值的範圍來隨機產生亂數 \u003c?php echo(round(0,100)); ?\u003e 輸出 88 ","date":"2022-02-22","objectID":"/php/:3:6","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"4. PHP 表單 ","date":"2022-02-22","objectID":"/php/:4:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"GET vs POST 舉個例子，如果 HTTP 代表現在我們現實生活中寄信的機制，那麼信封的撰寫格式就是 HTTP。我們可以將信封外的內容稱為 http-header，信封內的書信稱為 message-body。 假設 GET 表示信封內不得裝信件的寄送方式，像是明信片一樣，你可以把要傳遞的資訊寫在信封(http-header)上。而 POST 就是信封內有裝信件的寄送方式，不但信封可以寫東西，信封內 (message-body) 還可以放你想要寄送的資料或檔案。 因為使用 GET 的方法來傳送表單訊息對每個人都是可見的(所有的變數名稱與值都會顯示在 URL)，所以絕對不要使用 GET 來傳送密碼或是一些敏感訊息。 PHP 可以用 $_GET 和 $_POST 來收集表單數據 ","date":"2022-02-22","objectID":"/php/:4:1","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"GET 我們先模擬 $_GET ，先建立一個 index.html 的檔案程式碼如下 HTML 表單 (GET) \u003chtml\u003e \u003cbody\u003e \u003cform action=\"welcome_get.php\" method=\"get\"\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e E-mail: \u003cinput type=\"text\" name=\"email\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 再建立一個 welcome.php 的檔案程式碼如下 PHP ($_GET) \u003chtml\u003e \u003cbody\u003e Welcome \u003c?php echo $_GET[\"name\"]; ?\u003e\u003cbr\u003e Your email address is: \u003c?php echo $_GET[\"email\"]; ?\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-02-22","objectID":"/php/:4:2","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"POST 我們先模擬 $_POST ，先建立一個 index.html 的檔案程式碼如下 HTML 表單 (POST) \u003chtml\u003e \u003cbody\u003e \u003cform action=\"welcome_get.php\" method=\"post\"\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e E-mail: \u003cinput type=\"text\" name=\"email\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 再建立一個 welcome.php 的檔案程式碼如下 PHP ($_POST) \u003chtml\u003e \u003cbody\u003e Welcome \u003c?php echo $_POST[\"name\"]; ?\u003e\u003cbr\u003e Your email address is: \u003c?php echo $_POST[\"email\"]; ?\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-02-22","objectID":"/php/:4:3","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"資料驗證 密碼：需為8碼至20碼，且並包含特殊符號、大小寫英文字母、數字至少各1碼 \u003c?php $password = '@aaaa5aI'; if(preg_match('/(?=.*[@#$%^\u0026+=])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[@#$%^\u0026+=a-zA-Z0-9]{8,20}$/', $password)){ echo '密碼『',$password,'』正確。'; } else{ echo '密碼『',$password,'』不正確(需符合8至20碼，且包含特殊符號、大小寫英文、數字各一碼)。'; } ?\u003e 輸出 密碼『@aaaa5ai』不正確(需符合8至20碼，且包含特殊符號、大小寫英文、數字各一碼)。 密碼『@aaaa5aI』正確。 手機電話：需為10碼，且開頭為09接後8碼的數字 \u003c?php $phone = '0912345678'; if(preg_match('/^09[0-9]{8}$/', $password)){ echo '手機電話『',$phone,'』正確。'; } else{ echo '手機電話『',$phone,'』不正確(需為10碼，且符合開頭為09後接8碼的數字)。'; } ?\u003e 輸出 手機電話『0212345678』不正確(需為10碼，且符合開頭為09後接8碼的數字)。 手機電話『0912345678』正確。 信箱 \u003c?php $email = '123@gmail.com'; if(filter_var(\"$email\", FILTER_VALIDATE_EMAIL)) { echo '信箱『',$email,'』正確。'; } else{ echo '信箱『',$email,'』不正確。'; } ?\u003e 輸出 信箱『123@gmailcom』不正確。 信箱『123@gmail.com』正確。 ","date":"2022-02-22","objectID":"/php/:4:4","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"5. PHP RESTful REST ，指得是一組架構約束條件和原則，符合 REST 設計風格的Web API 稱為 RESTful API，主要以下面三點為定義 直觀簡單的資源網址URL 比如：http://example.com/resources 傳輸的資源：Web 服務接受與返回的類型，比如：JSON、XML 對資源的操作：Web 服務在該資源上所支持的請求方法，比如：POST、GET、PUT、PATCH、DELETE 加油 還有一篇可以一起學習 詳細可以參考另一篇文章 如何在 Nginx 下實作第一個 PHP 留言板 RESTful API 裡面有更詳細的介紹 ","date":"2022-02-22","objectID":"/php/:5:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["codenotes"],"content":"6. 資料來源 PHP 是什麼，架設網站最適合的程式語言 PHP 新手指南：3分鐘快速認識PHP PHP 教程 PHP基礎語法(一)：Hello world與基本資料型態 PHP-物件導向(OOP)介紹 秒懂PHP的FastCGI跟PHP-FPM有什麼關係 ","date":"2022-02-22","objectID":"/php/:6:0","tags":["PHP","PHP 基礎語法","PHP 常用函式","PHP 表單","介紹"],"title":"PHP 介紹","uri":"/php/"},{"categories":["youtube"],"content":"在過年要準備收假前，來一趟高級的露營，與很久不見的好友，一起泡溫泉、喝酒、吃烤肉、聊天， 還有甚麼事情，比這件事還更快樂的呢 ! 相關連結 過年自製MV(因版權，無法上傳YT)：Instagram 設備/剪輯/BGM 設備： 主攝影：GoPro 8 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Eternal Sunshine by LiQWYD \u0026 Luke Bergs https://soundcloud.com/liqwyd https://soundcloud.com/bergscloud Creative Commons — Attribution-ShareAlike 3.0 Unported — CC BY-SA 3.0 Free Download / Stream: https://bit.ly/3opx8U6 Music promoted by Audio Library https://youtu.be/Uzdp8rV2Nmc 相關連結 影片🎬：下方請收看 👇 ","date":"2022-02-20","objectID":"/lofi-land/:0:0","tags":["露營","朋友","旅遊","YouTube"],"title":"【自然圈豪華露營Lo fi Land】花好月圓人團圓VLOG","uri":"/lofi-land/"},{"categories":["codenotes"],"content":"PWA 全名是 Progressive Web App，也就是漸進式的網站應用程式，逐步的將網站漸進優化為具備 APP 的優點，其有以下幾點特性。 ","date":"2022-02-19","objectID":"/pwa/:0:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"介紹 PWA 全名是 Progressive Web App，也就是漸進式的網站應用程式，逐步的將網站漸進優化為具備 APP 的優點，其有以下幾點特性。 Progressive 漸進式，提供每一位用戶做基本的瀏覽。 Responsive 響應式的用戶介面，可以在不同裝置下作最佳化的顯示。 Connectivity independent 不依賴網路連接，透過 service workers 可以在低頻寬甚至是離線的環境下瀏覽網站。 App-like 讓網站可以具有像 APP 般的瀏覽速度等優點，提供更佳的用戶體驗。 Fresh 藉由 service worker 自動更新網站內容。 Installable 可以藉由 Add To Home，如同 App，會新增一個 icon，可以直接將網站加到手機桌面上做切換使用，不需要再透過 App Store 下載安裝。 詳細可參考官方網站 ","date":"2022-02-19","objectID":"/pwa/:1:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"實際安裝 範例下載位置 先下載 https://nas.pin-yi.me/sharing/nElXqbqyt (放置小弟NAS雲端上) 內有兩個檔案，分別是manifest.json、service-worker.js，以下各別做介紹 ","date":"2022-02-19","objectID":"/pwa/:2:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"manifest.json (簡易介紹，詳細可參考官方文件) { \"background_color\": \"#fff\", \"display\": \"standalone\", \"orientation\":\"portrait\", \"theme_color\": \"#fff\", \"short_name\": \"縮短名稱\", \"name\": \"名稱\", \"description\": \"說明\", \"lang\": \"zh-TW\", \"icons\": [ { \"src\": \"images/logo/logo180.ico\", \"sizes\": \"180x180\", \"type\": \"image/png\" }, { \"src\": \"images/logo/logo48.ico\", \"sizes\": \"48x48\", \"type\": \"image/png\" } ], \"start_url\": \"./index.php\" } background_color 背景顏色 定義 Web 應用程式預期的背景顏色，這能在 Web 應用程式的啟動和載入內容之間創建平順的過場。 \"background_color\": \"#fff\" display 背景顏色 定義開發者喜好的 Web 應用程式顯示模式。 \"display\": \"standalone\" 顯示模式 描述 fullscreen 所有可用的顯示區域都被填充並且不顯示使用者代理 chrome 。 standalone 這看起來和感覺上就像是獨立應用程式一樣，包括有不同的執行視窗、有圖示的應用程式啟動器 … 等等。 在這模式下，使用者代理將不包含控制導覽列，但能包含其他的 UI 元素，像是狀態列。 minimal-ui 這看起來和感覺上就像是獨立應用程式一樣，但將有控制導覽列 UI 元素的最小設置，元素會因瀏覽器而不同。 browser 預設值。 應用程式如常規般地被開啟於瀏覽器分頁或新視窗，依瀏覽器與平台而不同。 orientation 螢幕顯示方向 定義預設的顯示方向，通常應用在 GAME 裡，可能會需要強制設定方向。 \"orientation\": \"portrait\" theme_color 網站佈景顏色 設定網站每個頁面的主題顏色，例如改變 URL 的顏色。 \"theme_color\": \"#fff\" short_name 縮短名稱 定義 Web 應用程式的縮短名稱。 \"short_name\": \"縮短名稱\" name 名稱 定義 Web 應用程式的名稱。 \"name\": \"名稱\" name 名稱 定義 Web 應用程式的名稱。 \"name\": \"名稱\" description 說明 提供一段描述來形容這個 Web 應用程式的作用是什麼。 \"description\": \"說明\" lang 語言 定義 Web 應用程式的語言。 \"lang\": \"zh-TW\" icons 圖示 應用程式圖示的物件。 \"icons\": [ { \"src\": \"images/logo/logo180.ico\", \"sizes\": \"180x180\", \"type\": \"image/png\" }, { \"src\": \"images/logo/logo48.ico\", \"sizes\": \"48x48\", \"type\": \"image/png\" } ] start_url 開始網址 定義 Web 應用程式的開始位置。 \"start_url\": \"./index.php\" service-worker.js // 當service worker在「安裝階段」時會觸發此事件 self.addEventListener('install', function(event) { console.log('[Service Worker] Installing Service Worker ...', event); }); // 當service worker在「激活階段」時會觸發此事件 self.addEventListener('activate', function(event) { console.log('[Service Worker] Activating Service Worker ...', event); return self.clients.claim(); // 加上這行是為了確保service worker被正確載入和激活，不加也行 }); self.addEventListener('fetch', function(event) { console.log('[Service Worker] Fetch something ...', event); event.respondWith(fetch(event.request)); }); let deferredPrompt; self.addEventListener('beforeinstallprompt', function(event) { console.log('beforeinstallprompt fired'); event.preventDefault(); // 取消預設的直接跳出通知設定 deferredPrompt = event; // 將監聽到的install banner事件傳到deferredPrompt變數 return false; }); if(deferredPrompt) { // 確定我們有「攔截」到chrome所發出的install banner事件 deferredPrompt.prompt(); // 決定要跳出通知 // 根據用戶的選擇進行不同處理，這邊我指印出log結果 deferredPrompt.userChoice.then(function(choiceResult) { console.log(choiceResult.outcome); if(choiceResult.outcome === 'dismissed'){ console.log('User cancelled installation'); }else{ console.log('User added to home screen'); } }); deferredPrompt = null; // 一旦用戶允許加入後，之後就不會再出現通知 } ","date":"2022-02-19","objectID":"/pwa/:2:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"使用方式 先將 manifest.json 上述資料改為自己想要的設定，將manifest.json、service-worker.js 放置網頁根目錄，並開啟想要支援的網頁，以下使用小弟我個人頁面來做示範。 先至編輯器內將manifest.json放到head內 \u003clink rel=\"manifest\" href=\"./manifest.json\"\u003e 範例頁面\" 範例頁面 於程式最後新增以下 \u003cscript\u003e if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('./service-worker.js') .then(function() { console.log(\"Service Worker Registered, Cheers to PWA Fire!\"); }); } ); } \u003c/script\u003e 範例頁面\" 範例頁面 提醒 manifest.json、service-worker.js　依據自己放置位置做更改😀 ","date":"2022-02-19","objectID":"/pwa/:3:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"如何使用 ","date":"2022-02-19","objectID":"/pwa/:4:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"IOS 手機：Iphone 12 Pro (IOS 14.5) 瀏覽器：Safari 先瀏覽範例網站小弟個人頁面。 點選下方中間分享圖示，選擇加入主畫面，按下新增，就會出現在手機主畫面，打開後，就會發現操作跟APP相同。 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:4:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"ANDROID 手機：OnePlus 8T (ANDROID 11) 瀏覽器：Chrome 先瀏覽範例網站小弟個人頁面。 安裝應用程式至手機，經過下載，就會出現在手機主畫面，打開後，就會發現操作跟APP相同。 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:4:2","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"成功畫面 範例頁面\" 範例頁面 ","date":"2022-02-19","objectID":"/pwa/:5:0","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["codenotes"],"content":"其他說明 以上為備份筆記 資料來源: https://ithelp.ithome.com.tw/articles/10186584 https://ithelp.ithome.com.tw/articles/10188514 ","date":"2022-02-19","objectID":"/pwa/:5:1","tags":["PWA","設定教學"],"title":"PWA(Progressive Web App) 介紹與實際安裝","uri":"/pwa/"},{"categories":["Network"],"content":"TCP 與 UDP 都是常見的網路通訊協定，這兩種協定能確保網際網路資料傳輸的快速以及完整性，它們的運作方式不太一樣，TCP 較為可靠，UDP 較為快速。 我們來慢慢分析兩種不同的網路通訊協定，有什麼特別之處!? ","date":"2022-02-18","objectID":"/tcp-udp-difference/:0:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"TCP 是什麼 TCP 是 (通訊控制協定) 也是網際網路上最常用的協定，這種協定較為可靠，其運作方法如下： TCP為每個封包分配一個唯一辨識碼和一個序號，這些號碼可以讓接收端識別封包的完整性以及封包順序。 當接收端收到封包後。如果順序正確，會向發送端傳送一個確認信號，以確定接收端有收到封包。 發送端收到確認信號後才會傳輸下一個封包。 如果封包遺失或是發送順序錯誤，接收端不會傳輸任何資訊，這代表發送端需要重新發送封包。 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:1:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"UDP 是什麼 UDP 不需要唯一識別碼和序號就可以完成相同工作，這種協定已串流方式傳輸資料，也因為發送端不會回傳確認信號，會不斷發送封包給接收端。UDP因為沒有確認，也不在乎封包是否遺失，所以很容易出錯，但因為不會檢查，所以傳輸速度比TCP更快。串流軟體、網路遊戲等都是使用此協定。 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:2:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["Network"],"content":"TCP vs. UDP 比較表 比較 TCP UDP 可靠性 可靠 不可靠 速度 慢 快 傳輸方式 封包依照順序傳輸 封包以串流方式傳輸 是否檢查錯誤與修正 有 無 適用服務內容 網站瀏覽、電子郵件、檔案瀏覽、要求可靠的傳輸服務 即時服務、線上遊戲、線上直播 ","date":"2022-02-18","objectID":"/tcp-udp-difference/:3:0","tags":["TCP","UDP","網路"],"title":"TCP和UDP的差異","uri":"/tcp-udp-difference/"},{"categories":["codenotes"],"content":"什麼是 Git ? 不管是不是工程師，只要常常需要使用電腦工作，每天一定都會新增、修改、刪除許多檔案，我們看到這張圖： 很多人的電腦裡面都有這樣的內容\" 很多人的電腦裡面都有這樣的內容 這張圖是一個菜鳥工程師在整理檔案時的方法，因為每一天都會對這份檔案做不同的處理，但為了保留以前的版本，所以也不會刪除舊的檔案，只好用日期或是版本來做分類，時間越久，檔案就累積越多，假如不小心刪除，也找不回來紀錄，也不清楚不同檔案的差異，所以有了Git這項工具。 Git 為分散式版本控制系統，是為了更好管理Linux內核而開發的。 Git 的優點：免費開源、速度快、檔案體積小、分散式系統。 Git 的缺點：指令繁雜，但可以透過GUI工具解決。 Git 會紀錄哪些資料：更動前 vs 更動後的程式碼、修改者、修改時間、修改原因（修改者需要自行撰寫 commit message）。 我們也常常聽到 GitHub or GitLab 那跟 Git 是一樣的東西嗎？ Ans：GitHub(GitLab) 是基於Web的平台，結合了Git的版本控制功能，為開發團隊提供了儲存、分享、發布和合作開發項目的中心化雲存儲的場所。 ","date":"2022-02-10","objectID":"/git/:1:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"Git 操作指令 Git 的操作指令繁多，包含環境類、查看類、提交類、分支類、遠端類、合併類、還原類等等，所以才有了 Git GUI 工具，筆者很推薦 Gitkraken，雖然需要付費，但真的很方便，畫面也很乾淨簡潔。如果是學生的話，還可以使用 GitHub Student Developer Pack 免費使用歐！ Git GUI 工具 (Gitkraken)\" Git GUI 工具 (Gitkraken) 接下來我們會依照環境類、查看類、提交類、分支類、遠端類、合併類、還原類依序下去介紹～ ","date":"2022-02-10","objectID":"/git/:2:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"環境類 使用每一個程式或工具，必須先把它安裝到自己電腦上對吧！但因為大家使用的系統都不一樣，所以這邊就不列出要怎麼進行安裝，可以參考 Git 安裝教學 當我們安裝好後，我們就可以一起進入 Git 的世界囉！ init 首先，找一個你要開始進行版本控制 (Git) 的資料夾， 使用： $ git init 要記得要到版本控制的資料夾目錄下才使用這個指令歐！ 使用完後，會看到跑出下面這些文字： Git init\" Git init 此外資料夾內也會多一個隱藏檔案 .git ，他是用來存放 git 的紀錄，所以不要亂刪除歐： $ tree -a -d . └── .git ├── hooks ├── info ├── objects │ ├── info │ └── pack └── refs ├── heads └── tags 回到剛剛圖片，它說明默認會使用 master 這個來作為初始分支，並記得要使用 git config 來做設定，那 git config 是要做什麼用的呢！？ config 在推送Commit的時候，會顯示使用者名稱以及電子郵件，所以要先在推送前設定好，這時就使用： $ git config --global user.name \"your name\" $ git config --global user.email \"your email\" 分別設定使用者名稱以及電子郵件，這樣共同使用版本控制的人，才分的出來誰是誰！ (若只要在單個專案下設定使用者名稱及電子郵件，就不需要設定 –global 參數) ","date":"2022-02-10","objectID":"/git/:2:1","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"查看類 我們剛剛已經設定好 config ，如果想查看檔案的git狀態，就使用： $ git status 指令，可以查看現在資料夾內有哪些檔案還沒加入版本控制，或是已經加入但還沒Commit成新版本。 Git status\" Git status ","date":"2022-02-10","objectID":"/git/:2:2","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["codenotes"],"content":"參考資料 什麼是 Git？為什麼要學習它？ Git：基本概念介紹與指令 [Git] 初始設定 連猴子都能懂的Git入門指南 Git教學】分支合併: merge 與 rebase 差異 ","date":"2022-02-10","objectID":"/git/:3:0","tags":["Git","操作指令","介紹"],"title":"Git 介紹","uri":"/git/"},{"categories":["youtube"],"content":"網路上流傳著一個說法，說台灣人一生必做的3大事情 登玉山 泳渡日月潭 單車環島 內文 雖然我這輩子應該不會想單車環島 但機車環島是我好久以前的一個夢想 大一時，剛學會騎車，很喜歡到處跑， 曾約了一群朋友要在大二時去環島， 可惜當時沒有時間去完成， 這次在退伍後工作前的空閒時間出發， 途中有藍天白雲，也有狂風暴雨，而且後者居多🥲 讓我看到台灣不一樣的景色 也算是送給我工作前的一份大禮🎁 旅遊各景點 景點代補上 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 8 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Be Myself by Nettson https://soundcloud.com/nettson Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/nettson-be-myself Music promoted by Audio Library https://youtu.be/bP17he7J85E Pineapple by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/2Xn3lAL Music promoted by Audio Library https://youtu.be/YxnWhkiLuHo Hold On by Spiring https://soundcloud.com/user-57630131 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/2VnhRHG Music promoted by Audio Library https://youtu.be/6UhZbct8UFs Our Time by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3ybRL96 Music promoted by Audio Library https://youtu.be/ASnMczLNZtg Santa Monica by Roa https://soundcloud.com/roa_music1031 Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3AeTLOp Music promoted by Audio Library https://youtu.be/gzsiVYVH5hQ 相關連結 環島行程🏍：Google Map 環島影片🎬：下方請收看 👇 ","date":"2022-01-31","objectID":"/surround-island/:0:0","tags":["環島","機車","旅遊","YouTube"],"title":"【 四極點機車環島】台灣人一定要去一次的旅行，巧遇保育類動物穿山甲","uri":"/surround-island/"},{"categories":["youtube"],"content":"旅遊各景點 0:10 山姆先生咖啡館 0:30 馬太鞍濕地生態園區 1:16 紅瓦屋 1:48 光復糖廠 2:08 立川漁場 2:50 林田山林業文化園區 3:20 玉里麵 3:43 六十石山 4:57 金剛大道 5:44 七星潭 6:09 七星柴魚博物館 6:34 廟口紅茶 7:09 台開心農場 7:43 東大門夜市 8:25 太魯閣牌樓 8:49 燕子口步道 9:38 清水斷崖 10:21 清水斷崖獨木舟 12:18 野人火鍋 12:38 布洛灣山月吊橋 13:45 白楊步道水濂洞 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Scandinavianz - Love Me Jay Someday - Mind Travel Never A Goodbye 相關連結 影片🎬：下方請收看 👇 ","date":"2022-01-19","objectID":"/hualien-part3/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"好想再滑一次獨木舟 【Part 3】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part3/"},{"categories":["youtube"],"content":"我們的視野都是向前平視，何不試試用上帝視角來看花蓮海岸的美 旅遊各景點 0:12 雲山水夢幻湖 2:07 055龍蝦海鮮餐廳 2:45 花蓮路上 2:59 撒固兒步道 3:52 家咖哩總店 4:23 海崖谷露營休閒營區 6:01 海邊日出 7:14 親不知子斷崖 8:27 口福海鮮餐廳 8:43 北回歸線 9:15 石梯坪遊憩風景區 10:17 石門洞 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Poolside — LiQWYD [Audio Library Release] Never A Goodbye 相關連結 影片🎬：下方請收看 👇 ","date":"2022-01-16","objectID":"/hualien-part2/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"空拍帶你看花蓮 【Part 2】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part2/"},{"categories":["experience"],"content":"告訴你履歷製作的小技巧，以及什麼是千萬別做的地雷","date":"2022-01-14","objectID":"/resume/","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"在寫履歷之前，我們先設想一下，你這份履歷是要給誰看的呢? 像是HR、獵頭公司、跨部門同部門的同事嗎? 所以履歷的呈現方式，以及能不能讓他讀得懂很重要，你要把自己想成是個面試官，從面試官的角度去想，你希望看到那些內容 ","date":"2022-01-14","objectID":"/resume/:0:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"履歷的基本技巧 基本資料不用寫太多，不需要把從哪裡出生，家裡有幾個人通通寫出來，只需要簡單的名字、電話、地址等基本資料。 需要有明顯的內容分類，主要以四大為主，基本資料、工作經驗、最高學歷、相關技能。 履歷最好是不要超過一頁，除非是需要放作品集或是一些補充資訊，不管是有多少年的工作經驗，要想辦法把精華濃縮在這一頁中（將最重要以及最近期的工作經驗放到這一頁中，其他的相關經驗可以在面試時補充）最最最主要是要勾起面試官對你的好奇心。 如果是學生，剛出社會沒有任何的工作經驗，可以將學生時期所做的專案或是相關的課程放進履歷中。其中學生時期如果有實習經驗，更為重要，因為很多人就是沒有工作經驗，所以必須靠實習的經驗來加強你的履歷（真的沒有任何相關的工作經驗，可以將社團當任的那些職位，做了哪些事情，在其中達到了那些目標）。 要客制化自己的履歷，有時候會同時申請不同公司或是不同部門，要針對該公司該職位去客制化履歷。 例如面試的公司A是強調要獨立思考的，那在履歷中就可以寫自己所做的案子，B公司要的是團隊合作能力，那就可以在履歷中寫自己在團隊中扮演甚麼腳色，一起達到那些目標。 不要在履歷上寫到你的弱點，雖然面試時不能夠說謊去不承認你不會的東西，但是履歷就是一個包裝，履歷是給面試官的第一印象，你要把最完美的自己呈現出來。 在履歷表上，不要只說自己很會怎麼樣或是做過哪個案子，要把你做這個案子中，你做了那些改變，為公司或這麼案子帶來哪些好的影響，最好用數據化來量化你的成效（提升了多少的效率、幫公司省下多少錢），通常案子都是一個團體一起做，但是你只要強調你做出的貢獻。 要用實體的例子來證明自己的長處 可能會負責那些事情 會遇到那些困難 需要提供那些能力 這份工作需要的價值觀以及目標 ","date":"2022-01-14","objectID":"/resume/:1:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"履歷的地雷 不要放任何與職缺需要的專業能力無關的內容 如果是新鮮人，沒任何的工作經歷，也不要把參加活動的頭銜當作擁有的工作能力 要記得 要表現心目中那個好的自己，而且是最真實的自己 ! ","date":"2022-01-14","objectID":"/resume/:2:0","tags":["履歷","求職"],"title":"履歷到底要怎麼寫比較好?","uri":"/resume/"},{"categories":["experience"],"content":"為什麼每次都會緊張到說不出話來?常被問的7個問題","date":"2022-01-14","objectID":"/interview/","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"自我介紹先放線頭，可以幫助面試官找到話題，以持續後面的面試 對徵才方的公司需要了解，且知道面試的職缺內容 不要只在乎自己能夠拿到甚麼，而是要說出自己對於這份工作可以付出多少的價值 ","date":"2022-01-14","objectID":"/interview/:0:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"履歷的基本技巧 面試後，必須自己提出問題，不僅僅只是單一方向的回答問題，也可以對問題提出討論或是感興趣的事(至少準備3個問題以上，且不要被問的問題框架給限制住了，可以先詢問問題的邊界在哪) 這個職位為甚麼而開，前一位同事是因為甚麼原因而離開的，想要知道自己適不適合，切記要使用禮貌性的問法 自我介紹目的是 : 1. 你能替公司解決甚麼問題 2. 你能替公司帶來甚麼價值 成功 我過去怎麼樣 擅長的事情 強項 我的最大強項是 令我感到自豪的 形式 要怎麼把你的技能，應用在你應徵的職位上 我在找的是 背下來，並重複練習，就會越來越習慣跟熟練 ","date":"2022-01-14","objectID":"/interview/:1:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"常見問題 面試者前往公司面試前，應事先準備以下幾點常見問題 答案盡量真實、切記說謊，避免日後產生更大的爭議。 請簡單自我介紹 不管面試官是否認真看過履歷，都沒有直接面對面的說明還來的直接，自我介紹通常是面試時，遇到的第一個問題。介紹時需簡短且着重自身專長以及工作經歷的描述上，一般而言，公司不會想知道你家庭背景，家裡有誰，只要提及自己是甚麼學校或科系，以及有甚麼特殊表現即可。 簡單說明前一份工作是做甚麼的、隸屬於甚麼部們、甚麼職稱，主要負責工作有那些、舉體表現以及相關成就如何，且使用數字化去量化它，不要只打執行主管交辦任務之類的答案。 如果是社會新鮮人，沒有工作經驗，可以放上在學校的專題成就或是參與社團經驗有甚麼讓你比較印象深刻，且與該工作內容性質有關。 自我介紹除了說明你自己的經歷外，也是一個最好行銷自己的方式，面試官可以從你自我介紹中更了解你，形成對你的第一印象，如果第一印象打壞了就很難救了，也不要講的漏洞百出，或是誇大其辭。 也建議大家要準備不同時間版本的自我介紹，一分鐘、三分鐘、五分鐘，先對鏡子練習，或找朋友協助，讓你習慣的這樣的感覺，在面試時，能夠發揮百分之百的你自己。 你的離職原因？ 為何想來我們公司？ 你的期望待遇是多少？ 你的優點是甚麼 你的弱點是甚麼 五年後的你在做甚麼 在所有候選人裡，我們為甚麼要僱用你 怎樣的狀況下你會選擇投入一家公司？怎樣的狀況下你會選擇離開？ 你還有什麼問題要問的？ 可以詢問這份履歷有沒有甚麼資訊不足，或是可以更好的地方 ","date":"2022-01-14","objectID":"/interview/:2:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"面試緊張恐懼要怎麼克服 面試時一定會遇到恐懼，其中以四種恐懼為主 個人形象的困擾：我們大多數人會不喜歡自己的聲音，不喜歡自己的身材，總會有些事情，讓我們不夠有自信，有時候，這就是我們內心的小劇場，我們要如何面對這種恐懼呢？ 可以先從衣著上提升，不管是視訊面試，還是現場面試，穿著體面的衣服，不要上半身正裝，下半身穿運動褲，當你把每件事情都做到100%，就可以投射出你的自信，修剪你的頭髮、擦亮你的皮鞋、確保你的個人衛生。 害怕說錯話：主管問你事情，你卻支支吾吾的，不知道該說甚麼，說錯話就會在心裡想：「我的天，我不應該這樣說的」，我們要如何面對這種恐懼呢？ 多練習，因為大部分的問題都是一樣的，當你知道問題，就應該要做好準備，可以讓親朋好友來協助你，讓他們多問幾次這些問題，從不同的角度，不管是面試的一開始，或是面試中和面試後，直到你可以不用思考就可以回答這些問題。腦中已經有個小腳本了，記得要把這些都寫出來，也不需要怕會不自然，就像是舞台上的表演者、或是在在演講的演講者，並不是他們都不需要排演。 害怕得不到這份工作：害怕自己失去這次機會，我們要如何面對這種恐懼呢？ 在去面試前，先靜下來，閉上眼睛，想像一下，你走進去面試場地或是加入線上聊天室中，大家面對你的微笑，試著想像成功，因為正面的期望，會帶來正面的效果。在腦中幻想的那些負面情緒，對你的表現沒有任何的幫助。 害怕別人的看法：作為一個人類，會很在乎大多數人或別人是怎麼看待我的，這是很正常的事情，我們要如何面對這種恐懼呢？ 你要把事情都先安排好，以防萬一發生，你可以有一個Plan B，但如果這是你的一切，你很難不緊張。可以先多找幾間要面試的公司，雖然那並不一定是你最想要的，但你知道，如果真的不幸搞砸了你最想要去的那一間，還有其他備案，將這種自信表現出來，你就可以很冷靜，表現出最真實的你自己。 ","date":"2022-01-14","objectID":"/interview/:3:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["experience"],"content":"資料來源 如何在面試中充滿自信 這樣回答保證錄取！破解面試官最愛問的 7 個問題 ","date":"2022-01-14","objectID":"/interview/:4:0","tags":["面試","求職"],"title":"面試該怎麼準備?","uri":"/interview/"},{"categories":["codenotes"],"content":".Net Core 是微軟新世代開發技術，不但實施了.NET跨平台開發與執行，同時也將框架大改造。 ","date":"2022-01-03","objectID":"/asp.net-core/:0:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"介紹 .Net Core 是微軟新世代開發技術，不但實施了.NET跨平台開發與執行，同時也將框架大改造。 優勢 跨平台 (可運行於Windows、Mac OSX、Ubuntu Liunx ) 是第一款Microsoft有跨平台能力的Ｗeb 開發框架，並支援雲端。 跨架構一致性（在x64、x86、ARM、ARM64不同處理器架構執行，仍然保持相同） 彈性部署（主機可用IIS、Apache、Docker）。 一種用於MVC和Web API的統一編程模型。 開放原始碼（使用MIS和Apache2授權的開放原始碼）。 單元測試（可測試性），並可模組化。 ","date":"2022-01-03","objectID":"/asp.net-core/:1:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"比較.NET Core / ASP.NET Code / ASP.NET Core MVC 比較 .NET Core ASP.NET Code ASP.NET Core MVC 代表 .NET Framework ASP.NET ASP.NET MVC 說明 平台框架，最廣泛的技術意義 網頁技術 ASP.NET Core 網頁技術中的MVC開發框架 ","date":"2022-01-03","objectID":"/asp.net-core/:2:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 是一種設計的樣式，代表Model、View、Controller 三個部分 Model 負責處理邏輯及資料面 (資料庫存取) View負責處理UI介面（HTML、Javescript、CSS） Controller負責接收Request請求、協調Model、View、將回應結果給使用者 該分工好處是可以達到關注點分離（SoC）、較好的分層架構、降低複雜度，往後方便對程式進行維護。 ","date":"2022-01-03","objectID":"/asp.net-core/:3:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"ASP.NET Core MVC? 是支援MVC設計的框架。 ","date":"2022-01-03","objectID":"/asp.net-core/:4:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 執行流程 使用者在瀏覽器輸入URL網址後，會發出Request 請求至伺服器 中間會先經過Routing路由機制，找到對應的Controller及Action Method Action 會呼叫Model，以讀取或是更新資料 Model會先進行邏輯計算及資料庫存取，再回傳給Action Action會將Model資料丟給View作網頁呈現 View Engine 將最終HTML 結果寫入Reponse 輸出資料流，回應給使用者瀏覽器。 ","date":"2022-01-03","objectID":"/asp.net-core/:5:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["codenotes"],"content":"MVC 專案資料夾功能說明 Properties\u003elaunchSettings.json (本機開發電腦的環境組態檔) wwwroot 資料夾 (公開的靜態資源檔目錄，如css、js、images等等) Controller 資料夾 (Controller 控制項類別所在目錄) Model 資料夾 (Model 模型類別所在目錄) View 資料夾 (有Home、Shared、_ViewImports.cshtml、_ViewStart.cshtml) Home 目錄內有Index、Provacy兩個cshtml Shared 目錄內有_Layout.cshtml、_ValidationScriptsPartial.cshtml、Error.cshtml appsettings.json (供應用程式使用的組態設定) Program.cs (程式進入點，主要負責創建Host、環境及組態設定) Startup.cs (負責DI Container及Middleware 元件設定) ","date":"2022-01-03","objectID":"/asp.net-core/:6:0","tags":["ASP.NET Core","介紹"],"title":"ASP.NET Core介紹","uri":"/asp.net-core/"},{"categories":["youtube"],"content":"花蓮LongStay 就從吉安鄉開始，和家人到花蓮長達一個月的生活正式開始囉！ 旅遊各景點 1:35 佳興檸檬汁 1:46 炸彈蔥油餅 3:45 貨櫃星巴克 4:18 玉里臭豆腐(貨櫃星巴克旁) 4:57 台灣海礦館 7:07 48高地戰備坑道 8:26 單一雞湯小卷米粉 8:59 松園別館 9:36 一心泡泡冰 10:25 好客藝術村 11:14 慶修院 11:50 慶豐麵店 設備/剪輯/BGM 設備： 主攝影：：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： Travel Lovers Chasing Stars – Lesion X (No Copyright Music) Le Gang - I Don’t Need U 2 Say Anything AL’sic - Paradise 音樂版權聲明 Chasing Stars - Lesion X https://soundcloud.com/lesionxbeats Creative Commons — Attribution 3.0 Unported — CC BY 3.0 Free Download / Stream: https://bit.ly/3yeSVkb Music promoted by Audio Library https://youtu.be/WvXJm9seiJM 相關連結 影片🎬：下方請收看 👇 ","date":"2021-08-16","objectID":"/hualien-part1/:0:0","tags":["LongStay","旅遊","YouTube"],"title":"花蓮吉安鄉在地旅遊 【Part 1】 花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/hualien-part1/"},{"categories":["youtube"],"content":"想要知道花蓮該怎麼玩嗎？還不趕快訂閱加分享，下一集將在花蓮玩一個月給你看 從2021.08.01 到 2021.08.31 一個月的時間來玩遍整個花蓮 想要看哪個花蓮的景點，可以到下面留言喔🥰 設備/剪輯/BGM 設備： 主攝影：GoPro 7 and GoPro 9 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Final Cut Pro 照片後製： Canva BGM： BGM：LAKEY INSPIRED - Chill Day 相關連結 影片🎬：下方請收看 👇 ","date":"2021-08-09","objectID":"/painting/:0:0","tags":["油畫","旅遊","YouTube"],"title":"【數字油畫 - 偷看貓 【番外篇】花蓮要怎麼玩？玩一個月帶你認識你不知道的花蓮","uri":"/painting/"},{"categories":["youtube"],"content":"跟老爸老弟騎機車去巨人之手💖 設備/剪輯/BGM 設備： 主攝影：GoPro 7 空拍：DJI mini 1代 拍照：Iphone 12 Pro 剪輯： Adobe Premiere Pro 照片後製： Canva BGM： Jarico Island Vlog No Copyright Music Markvard Desire Vlog No Copyright Music 相關連結 影片🎬：下方請收看 👇 ","date":"2021-02-05","objectID":"/giant-hand/:0:0","tags":["機車","旅遊","YouTube"],"title":"【巨人之手】 家庭機車出遊VLOG","uri":"/giant-hand/"},{"categories":["documentation"],"content":"FeelIt 主題在 Hugo 內置的 shortcode 的基礎上提供多個擴展的 shortcode.","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"FeelIt 主題在 Hugo 內置的 shortcode 的基礎上提供多個擴展的 shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意 Hugo extended 版本對於 style shortcode 是必需的. style shortcode 用來在你的文章中插入自定義樣式. style shortcode 有兩個位置參數. 第一個參數是自定義樣式的內容. 它支持  SASS 中的嵌套語法, 並且 \u0026 指代這個父元素. 第二個參數是包裹你要更改樣式的內容的 HTML 標簽, 默認值是 div. 一個 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈現的輸出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 鏈接語法 的替代. link shortcode 可以提供一些其它的功能並且可以在代碼塊中使用. 支持本地資源引用的完整用法. link shortcode 有以下命名參數: href [必需] (第一個位置參數) 鏈接的目標. content [可選] (第二個位置參數) 鏈接的內容, 默認值是 href 參數的值. 支持 Markdown 或者 HTML 格式. title [可選] (第三個位置參數) HTML a 標簽 的 title 屬性, 當懸停在鏈接上會顯示的提示. rel [可選] HTML a 標簽 的 rel 補充屬性. class [可選] HTML a 標簽 的 class 屬性. 一個 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈現的輸出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一個帶有標題的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈現的輸出效果如下 (將鼠標懸停在鏈接上，會有一行提示): Upstage ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 兩個依賴庫. 支持本地資源引用的完整用法. image shortcode 有以下命名參數: src [必需] (第一個位置參數) 圖片的 URL. alt [可選] (第二個位置參數) 圖片無法顯示時的替代文本, 默認值是 src 參數的值. 支持 Markdown 或者 HTML 格式. caption [可選] (第三個位置參數) 圖片標題. 支持 Markdown 或者 HTML 格式. title [可選] 當懸停在圖片上會顯示的提示. class [可選] HTML figure 標簽的 class 屬性. src_s [可選] 圖片縮略圖的 URL, 用在畫廊模式中, 默認值是 src 參數的值. src_l [可選] 高清圖片的 URL, 用在畫廊模式中, 默認值是 src 參數的值. height [可選] 圖片的 height 屬性. width [可選] 圖片的 width 屬性. linked [可選] 圖片是否需要被鏈接, 默認值是 true. rel [可選] HTML a 標簽 的 rel 補充屬性, 僅在 linked 屬性設置成 true 時有效. 一個 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈現的輸出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 種 幫助你在頁面中插入提示的橫幅. 支持 Markdown 或者 HTML 格式. 注意 一個 注意 橫幅 摘要 一個 摘要 橫幅 信息 一個 信息 橫幅 技巧 一個 技巧 橫幅 成功 一個 成功 橫幅 問題 一個 問題 橫幅 警告 一個 警告 橫幅 失敗 一個 失敗 橫幅 危險 一個 危險 橫幅 Bug 一個 Bug 橫幅 示例 一個 示例 橫幅 引用 一個 引用 橫幅 admonition shortcode 有以下命名參數: type [必需] (第一個位置參數) admonition 橫幅的類型, 默認值是 note. title [可選] (第二個位置參數) admonition 橫幅的標題, 默認值是 type 參數的值. open [可選] (第三個位置參數) 橫幅內容是否默認展開, 默認值是 true. 一個 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一個 **技巧** 橫幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一個 **技巧** 橫幅 {{\u003c /admonition \u003e}} 呈現的輸出效果如下: This is a tip 一個 技巧 橫幅 ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一個可以幫助你在文章中生成圖表和流程圖的庫, 類似 Markdown 的語法. 只需將你的 mermaid 代碼插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程圖 一個 流程圖 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 時序圖 一個 時序圖 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特圖 一個 甘特圖 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 類圖 一個 類圖 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 狀態圖 一個 狀態圖 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 圖 一個 Git 圖 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 實體關系圖 一個 erDiagram mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.8 用戶旅程圖 一個 旅行 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:8","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.9 餅圖 一個 餅圖 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:9","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一個幫助你生成交互式數據可視化的庫. ECharts 提供了常規的 折線圖, 柱狀圖, 散點圖, 餅圖, K線圖, 用於統計的 盒形圖, 用於地理數據可視化的 地圖, 熱力圖, 線圖, 用於關系數據可視化的 關系圖, treemap, 旭日圖, 多維數據可視化的 平行坐標, 還有用於 BI 的 漏鬥圖, 儀表盤, 並且支持圖與圖之間的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 選項即可. 一個 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折線統計圖\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"郵件營銷\", \"聯盟廣告\", \"視頻廣告\", \"直接訪問\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存為圖片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"郵件營銷\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"聯盟廣告\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"視頻廣告\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接訪問\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"總量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一個 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折線統計圖top:2%left:centertooltip:trigger:axislegend:data:- 郵件營銷- 聯盟廣告- 視頻廣告- 直接訪問- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存為圖片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:郵件營銷type:linestack:總量data:- 120- 132- 101- 134- 90- 230- 210- name:聯盟廣告type:linestack:總量data:- 220- 182- 191- 234- 290- 330- 310- name:視頻廣告type:linestack:總量data:- 150- 232- 201- 154- 190- 330- 410- name:直接訪問type:linestack:總量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:總量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一個 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折線統計圖\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"郵件營銷\", \"聯盟廣告\", \"視頻廣告\", \"直接訪問\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存為圖片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"郵件營銷\" type = \"line\" stack = \"總量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"聯盟廣告\" type = \"line\" stack = \"總量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"視頻廣告\" type = \"line\" stack = \"總量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接訪問\" type = \"line\" stack = \"總量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"總量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈現的輸出效果如下: echarts shortcode 還有以下命名參數: width [可選] (第一個位置參數) 數據可視化的寬度, 默認值是 100%. height [可選] (第二個位置參數) 數據可視化的高度, 默認值是 30rem. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一個 JavaScript 庫，它使用 WebGL, 以 vector tiles 和 Mapbox styles 為來源, 將它們渲染成互動式地圖. mapbox shortcode 有以下命名參數來使用 Mapbox GL JS: lng [必需] (第一個位置參數) 地圖初始中心點的經度, 以度為單位. lat [必需] (第二個位置參數) 地圖初始中心點的緯度, 以度為單位. zoom [可選] (第三個位置參數) 地圖的初始縮放級別, 默認值是 10. marked [可選] (第四個位置參數) 是否在地圖的初始中心點添加圖釘, 默認值是 true. light-style [可選] (第五個位置參數) 淺色主題的地圖樣式, 默認值是前置參數或者網站配置中設置的值. dark-style [可選] (第六個位置參數) 深色主題的地圖樣式, 默認值是前置參數或者網站配置中設置的值. navigation [可選] 是否添加 NavigationControl, 默認值是前置參數或者網站配置中設置的值. geolocate [可選] 是否添加 GeolocateControl, 默認值是前置參數或者網站配置中設置的值. scale [可選] 是否添加 ScaleControl, 默認值是前置參數或者網站配置中設置的值. fullscreen [可選] 是否添加 FullscreenControl, 默認值是前置參數或者網站配置中設置的值. width [可選] 地圖的寬度, 默認值是 100%. height [可選] 地圖的高度, 默認值是 20rem. 一個簡單的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈現的輸出效果如下: 一個帶有自定義樣式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基於 APlayer 和 MetingJS 提供了一個內嵌的響應式音樂播放器. 有三種方式使用 music shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定義音樂 URL 支持本地資源引用的完整用法. music shortcode 有以下命名參數來使用自定義音樂 URL: server [必需] 音樂的鏈接. type [可選] 音樂的名稱. artist [可選] 音樂的創作者. cover [可選] 音樂的封面鏈接. 一個使用自定義音樂 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音樂平台 URL 的自動識別 music shortcode 有一個命名參數來使用音樂平台 URL 的自動識別: auto [必需]] (第一個位置參數) 用來自動識別的音樂平台 URL, 支持 netease, tencent 和 xiami 平台. 一個使用音樂平台 URL 的自動識別的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定義音樂平台, 類型和 ID music shortcode 有以下命名參數來使用自定義音樂平台: server [必需] (第一個位置參數) [netease, tencent, kugou, xiami, baidu] 音樂平台. type [必需] (第二個位置參數) [song, playlist, album, search, artist] 音樂類型. id [必需] (第三個位置參數) 歌曲 ID, 或者播放列表 ID, 或者專輯 ID, 或者搜索關鍵詞, 或者創作者 ID. 一個使用自定義音樂平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它參數 music shortcode 有一些可以應用於以上三種方式的其它命名參數: theme [可選] 音樂播放器的主題色, 默認值是 #448aff. fixed [可選] 是否開啟固定模式, 默認值是 false. mini [可選] 是否開啟迷你模式, 默認值是 false. autoplay [可選] 是否自動播放音樂, 默認值是 false. volume [可選] 第一次打開播放器時的默認音量, 會被保存在瀏覽器緩存中, 默認值是 0.7. mutex [可選] 是否自動暫停其它播放器, 默認值是 true. music shortcode 還有一些只適用於音樂列表方式的其它命名參數: loop [可選] [all, one, none] 音樂列表的循環模式, 默認值是 none. order [可選] [list, random] 音樂列表的播放順序, 默認值是 list. list-folded [可選] 初次打開的時候音樂列表是否折疊, 默認值是 false. list-max-height [可選] 音樂列表的最大高度, 默認值是 340px. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一個內嵌的用來播放 bilibili 視頻的響應式播放器. 如果視頻只有一個部分, 則僅需要視頻的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一個 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈現的輸出效果如下: 如果視頻包含多個部分, 則除了視頻的 BV id 之外, 還需要 p, 默認值為 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一個帶有 p 參數的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基於 TypeIt 提供了打字動畫. 只需將你需要打字動畫的內容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 簡單內容 允許使用 Markdown 格式的簡單內容, 並且 不包含 富文本的塊內容, 例如圖像等等… 一個 typeit 示例: {{\u003c typeit \u003e}} 這一個帶有基於 [TypeIt](https://typeitjs.com/) 的 **打字動畫** 的 *段落*... {{\u003c /typeit \u003e}} 呈現的輸出效果如下: 另外, 你也可以自定義 HTML 標簽. 一個帶有 h4 標簽的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 這一個帶有基於 [TypeIt](https://typeitjs.com/) 的 **打字動畫** 的 *段落*... {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代碼內容 代碼內容也是允許的, 並且通過使用參數 code 指定語言類型可以實習語法高亮. 一個帶有 code 參數的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分組內容 默認情況下, 所有打字動畫都是同時開始的. 但是有時你可能需要按順序開始一組 typeit 內容的打字動畫. 一組具有相同 group 參數值的 typeit 內容將按順序開始打字動畫. 一個帶有 group 參數的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 這個段落開始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然後**, 這個段落開始 {{\u003c /typeit \u003e}} 呈現的輸出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用來在你的文章中插入  Javascript 腳本. 注意 腳本內容可以保證在所有的第三方庫加載之後按順序執行. 所以你可以自由地使用第三方庫. 一個 script 示例: {{\u003c script \u003e}} console.log('Hello FeelIt!'); {{\u003c /script \u003e}} 你可以在開發者工具的控制台中看到輸出. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12 oEmbed oEmbed endpoints allow you to get embed HTML and basic metadata for pages, posts, and videos in order to display them in another website or app. The oEmbed endpoints require either an App Access Token or Client Access Token. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:0","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.1 oEmbed Facebook a. oEmbed Facebook Pages Sample input of Facebook Pages {{\u003c oembed \"fb\" \"page\" \"https://www.facebook.com/FacebookforDevelopers\" \u003e}} Sample output of Facebook Pages URL Formats https://www.facebook.com/{page-name} https://www.facebook.com/{page-id} b. oEmbed Facebook Posts Sample input of Facebook Posts {{\u003c oembed \"fb\" \"post\" \"https://www.facebook.com/FacebookforDevelopers/photos/a.441861428552/10151617410093553\" \u003e}} Sample output of Facebook Posts URL Formats https://www.facebook.com/{page-name}/posts/{post-id} https://www.facebook.com/{username}/posts/{post-id} https://www.facebook.com/{username}/activity/{activity-id} https://www.facebook.com/photo.php?fbid={photo-id} https://www.facebook.com/photos/{photo-id} https://www.facebook.com/permalink.php?story_fbid={post-id}\u0026id={page-or-user-id} https://www.facebook.com/media/set?set={set-id} https://www.facebook.com/questions/{question-id} https://www.facebook.com/notes/{username}/{note-url}/{note-id} c. oEmbed Facebook Videos Sample input of Facebook Videos {{\u003c oembed \"fb\" \"video\" \"https://www.facebook.com/FacebookforDevelopers/videos/2201055573317594\" \u003e}} Sample output of Facebook Videos URL Formats https://www.facebook.com/{page-name}/videos/{video-id}/ https://www.facebook.com/{username}/videos/{video-id}/ https://www.facebook.com/video.php?id={video-id} https://www.facebook.com/video.php?v={video-id} ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:1","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.2 oEmbed Instagram a. oEmbed Instagram Post Sample input of Instagram Post {{\u003c oembed \"ig\" \"p\" \"BWNjjyYFxVx\" \"hidecaption\" \u003e}} Sample output of Instagram Post b. oEmbed Instagram TV Sample input of Instagram TV {{\u003c oembed \"ig\" \"tv\" \"BkQUbR8h1sp\" \"hidecaption\" \u003e}} Sample output of Instagram TV ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:2","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12.3 oEmbed Twitter Sample input of ‘oembed tweet’ {{\u003c oembed \"tweet\" \"https://twitter.com/GoHugoIO/status/877500564405444608\" \u003e}} Sample output of ‘oembed tweet’ Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:12:3","tags":["shortcodes"],"title":"主題文檔 - 擴展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"這篇文章展示了基本的 Markdown 語法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"這篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 語法示例. 注意 這篇文章借鑒了一篇很棒的來自 Grav 的文章. 如果你想了解 FeelIt 主題的擴展 Markdown 語法, 請閱讀擴展 Markdown 語法頁面. 事實上, 編寫 Web 內容很麻煩. WYSIWYG所見即所得 編輯器幫助減輕了這一任務. 但通常會導致代碼太糟, 或更糟糕的是, 網頁也會很醜. 沒有通常伴隨的所有覆雜和醜陋的問題, Markdown 是一種更好的生成 HTML 內容的方式. 一些主要好處是: Markdown 簡單易學, 幾乎沒有多余的字符, 因此編寫內容也更快. 用 Markdown 書寫時出錯的機會更少. 可以產生有效的 XHTML 輸出. 將內容和視覺顯示保持分開, 這樣就不會打亂網站的外觀. 可以在你喜歡的任何文本編輯器或 Markdown 應用程序中編寫內容. Markdown 使用起來很有趣! John Gruber, Markdown 的作者如是說: Markdown 格式的首要設計目標是更具可讀性. 最初的想法是 Markdown 格式的文檔應當以純文本形式發布, 而不會看起來像被標簽或格式說明所標記. 雖然 Markdown 的語法受到幾種現有的文本到 HTML 轉換工具的影響, 但 Markdown 語法的最大靈感來源是純文本電子郵件的格式. – John Gruber 話不多說, 我們來回顧一下 Markdown 的主要語法以及生成的 HTML 樣式! 技巧  將此頁保存為書簽，以備將來參考! ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"1 標題 從 h2 到 h6 的標題在每個級別上都加上一個 ＃: ## h2 標題 ### h3 標題 #### h4 標題 ##### h5 標題 ###### h6 標題 輸出的 HTML 看起來像這樣: \u003ch2\u003eh2 標題\u003c/h2\u003e \u003ch3\u003eh3 標題\u003c/h3\u003e \u003ch4\u003eh4 標題\u003c/h4\u003e \u003ch5\u003eh5 標題\u003c/h5\u003e \u003ch6\u003eh6 標題\u003c/h6\u003e 標題 ID 要添加自定義標題 ID, 請在與標題相同的行中將自定義 ID 放在花括號中: ### 一個很棒的標題 {#custom-id} 輸出的 HTML 看起來像這樣: \u003ch3 id=\"custom-id\"\u003e一個很棒的標題\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"2 注釋 注釋是和 HTML 兼容的： \u003c!-- 這是一段注釋 --\u003e 不能看到以下的注釋: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"3 水平線 HTML 中的 \u003chr\u003e 標簽是用來在段落元素之間創建一個 “專題間隔” 的. 使用 Markdown, 你可以用以下方式創建一個 \u003chr\u003e 標簽: ___: 三個連續的下劃線 ---: 三個連續的破折號 ***: 三個連續的星號 呈現的輸出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"4 段落 按照純文本的方式書寫段落, 純文本在呈現的 HTML 中將用 \u003cp\u003e/\u003c/p\u003e 標簽包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 輸出的 HTML 看起來像這樣: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一個空白行進行換行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"5 內聯 HTML 元素 如果你需要某個 HTML 標簽 (帶有一個類), 則可以簡單地像這樣使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 這是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"6 強調 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"加粗 用於強調帶有較粗字體的文本片段. 以下文本片段會被 渲染為粗體. **渲染為粗體** __渲染為粗體__ 輸出的 HTML 看起來像這樣: \u003cstrong\u003e渲染為粗體\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"斜體 用於強調帶有斜體的文本片段. 以下文本片段被 渲染為斜體. *渲染為斜體* _渲染為斜體_ 輸出的 HTML 看起來像這樣: \u003cem\u003e渲染為斜體\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"刪除線 按照 GFMGitHub flavored Markdown 你可以使用刪除線. ~~這段文本帶有刪除線.~~ 呈現的輸出效果如下: 這段文本帶有刪除線. 輸出的 HTML 看起來像這樣: \u003cdel\u003e這段文本帶有刪除線.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"組合 加粗, 斜體, 和刪除線可以 組合使用. ***加粗和斜體*** ~~**刪除線和加粗**~~ ~~*刪除線和斜體*~~ ~~***加粗, 斜體和刪除線***~~ 呈現的輸出效果如下: 加粗和斜體 刪除線和加粗 刪除線和斜體 加粗, 斜體和刪除線 輸出的 HTML 看起來像這樣: \u003cem\u003e\u003cstrong\u003e加粗和斜體\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e刪除線和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e刪除線和斜體\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜體和刪除線\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"7 引用 用於在文檔中引用其他來源的內容塊. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈現的輸出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 輸出的 HTML 看起來像這樣: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈現的輸出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"無序列表 一系列項的列表, 其中項的順序沒有明顯關系. 你可以使用以下任何符號來表示無序列表中的項: * 一項內容 - 一項內容 + 一項內容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 輸出的 HTML 看起來像這樣: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"有序列表 一系列項的列表, 其中項的順序確實很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 輸出的 HTML 看起來像這樣: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你對每一項使用 1., Markdown 將自動為每一項編號. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈現的輸出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"任務列表 任務列表使你可以創建帶有覆選框的列表. 要創建任務列表, 請在任務列表項之前添加破折號 (-) 和帶有空格的方括號 ([ ]). 要選擇一個覆選框，請在方括號之間添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈現的輸出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"9 代碼 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"行內代碼 用 ` 包裝行內代碼段. 在這個例子中, `\u003csection\u003e\u003c/section\u003e` 會被包裹成 **代碼**. 呈現的輸出效果如下: 在這個例子中, \u003csection\u003e\u003c/section\u003e 會被包裹成 代碼. 輸出的 HTML 看起來像這樣: \u003cp\u003e 在這個例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 會被包裹成 \u003cstrong\u003e代碼\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"縮進代碼 將幾行代碼縮進至少四個空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈現的輸出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 輸出的 HTML 看起來像這樣: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"圍欄代碼塊 使用 “圍欄” ``` 來生成一段帶有語言屬性的代碼塊. ```markdown Sample text here... ``` 輸出的 HTML 看起來像這樣: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"語法高亮 GFMGitHub Flavored Markdown 也支持語法高亮. 要激活它，只需在第一個代碼 “圍欄” 之後直接添加你要使用的語言的文件擴展名, ```js, 語法高亮顯示將自動應用於渲染的 HTML 中. 例如, 在以下 JavaScript 代碼中應用語法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈現的輸出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文檔中的 語法高亮頁面 介紹了有關語法高亮的更多信息, 包括語法高亮的 shortcode. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"10 表格 通過在每個單元格之間添加豎線作為分隔線, 並在標題下添加一行破折號 (也由豎線分隔) 來創建表格. 注意, 豎線不需要垂直對齊. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈現的輸出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 輸出的 HTML 看起來像這樣: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右對齊或居中對齊 在任何標題下方的破折號右側添加冒號將使該列的文本右對齊. 在任何標題下方的破折號兩邊添加冒號將使該列的對齊文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈現的輸出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"11 鏈接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"基本鏈接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈現的輸出效果如下 (將鼠標懸停在鏈接上，沒有提示): https://assemble.io contact@revolunet.com Assemble 輸出的 HTML 看起來像這樣: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"添加一個標題 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈現的輸出效果如下 (將鼠標懸停在鏈接上，會有一行提示): Upstage 輸出的 HTML 看起來像這樣: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"定位標記 定位標記使你可以跳至同一頁面上的指定錨點. 例如, 每個章節: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 將跳轉到這些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位標記的位置幾乎是任意的. 因為它們並不引人注目, 所以它們通常被放在同一行了. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"12 腳注 腳注使你可以添加注釋和參考, 而不會使文檔正文混亂. 當你創建腳注時, 會在添加腳注引用的位置出現帶有鏈接的上標編號. 讀者可以單擊鏈接以跳至頁面底部的腳注內容. 要創建腳注引用, 請在方括號中添加插入符號和標識符 ([^1]). 標識符可以是數字或單詞, 但不能包含空格或制表符. 標識符僅將腳注引用與腳注本身相關聯 - 在腳注輸出中, 腳注按順序編號. 在中括號內使用插入符號和數字以及用冒號和文本來添加腳注內容 ([^1]：這是一段腳注). 你不一定要在文檔末尾添加腳注. 可以將它們放在除列表, 引用和表格等元素之外的任何位置. 這是一個數字腳注[^1]. 這是一個帶標簽的腳注[^label] [^1]: 這是一個數字腳注 [^label]: 這是一個帶標簽的腳注 這是一個數字腳注1. 這是一個帶標簽的腳注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"13 圖片 圖片的語法與鏈接相似, 但包含一個在前面的感嘆號. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像鏈接一樣, 圖片也具有腳注樣式的語法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍後在文檔中提供參考內容, 用來定義 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 FeelIt 主題提供了一個包含更多功能的 圖片的 shortcode. 這是一個數字腳注 ↩︎ 這是一個帶標簽的腳注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本語法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"Hugo 和 FeelIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"Emoji 可以通過多種方式在 Hugo 項目中啟用. emojify 方法可以直接在模板中調用, 或者使用行內 Shortcodes. 要全局使用 emoji, 需要在你的網站配置中設置 enableEmoji 為 true, 然後你就可以直接在文章中輸入 emoji 的代碼. 它們以冒號開頭和結尾，並且包含 emoji 的 代碼: 去露營啦! :tent: 很快就回來. 真開心! :joy: 呈現的輸出效果如下: 去露營啦! ⛺ 很快就回來. 真開心! 😂 以下符號清單是 emoji 代碼的非常有用的參考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"表情與情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"笑臉表情 圖標 代碼 圖標 代碼 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"愛意表情 圖標 代碼 圖標 代碼 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"吐舌頭表情 圖標 代碼 圖標 代碼 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"帶手的表情 圖標 代碼 圖標 代碼 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"中性表情 圖標 代碼 圖標 代碼 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"困倦的表情 圖標 代碼 圖標 代碼 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"不適的表情 圖標 代碼 圖標 代碼 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"戴帽子的表情 圖標 代碼 圖標 代碼 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"戴眼鏡的表情 圖標 代碼 圖標 代碼 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"擔心的表情 圖標 代碼 圖標 代碼 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"否定的表情 圖標 代碼 圖標 代碼 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"特殊打扮的表情 圖標 代碼 圖標 代碼 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"貓臉表情 圖標 代碼 圖標 代碼 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"猴臉表情 圖標 代碼 圖標 代碼 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"情感 圖標 代碼 圖標 代碼 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人與身體 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"張開手掌的手勢 圖標 代碼 圖標 代碼 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"部分手指的手勢 圖標 代碼 圖標 代碼 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"一根手指的手勢 圖標 代碼 圖標 代碼 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"握緊的手勢 圖標 代碼 圖標 代碼 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"兩只手 圖標 代碼 圖標 代碼 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"握住東西的手勢 圖標 代碼 圖標 代碼 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"身體部位 圖標 代碼 圖標 代碼 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人 圖標 代碼 圖標 代碼 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"身體動作 圖標 代碼 圖標 代碼 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物角色 圖標 代碼 圖標 代碼 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"幻想的人物 圖標 代碼 圖標 代碼 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物活動 圖標 代碼 圖標 代碼 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"體育 圖標 代碼 圖標 代碼 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"休息 圖標 代碼 圖標 代碼 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"家庭 圖標 代碼 圖標 代碼 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"人物符號 圖標 代碼 圖標 代碼 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"動物與自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"哺乳動物 圖標 代碼 圖標 代碼 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"鳥類 圖標 代碼 圖標 代碼 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"兩棲動物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"爬蟲類 圖標 代碼 圖標 代碼 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"海洋動物 圖標 代碼 圖標 代碼 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"蟲類 圖標 代碼 圖標 代碼 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"花類植物 圖標 代碼 圖標 代碼 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它植物 圖標 代碼 圖標 代碼 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"食物與飲料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"水果 圖標 代碼 圖標 代碼 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"蔬菜 圖標 代碼 圖標 代碼 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"快餐 圖標 代碼 圖標 代碼 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"亞洲食物 圖標 代碼 圖標 代碼 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"海鮮 圖標 代碼 圖標 代碼 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"甜點 圖標 代碼 圖標 代碼 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"飲料 圖標 代碼 圖標 代碼 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"餐具 圖標 代碼 圖標 代碼 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旅遊與地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"地圖 圖標 代碼 圖標 代碼 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"地理現象 圖標 代碼 圖標 代碼 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"建築物 圖標 代碼 圖標 代碼 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"宗教建築 圖標 代碼 圖標 代碼 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它地點 圖標 代碼 圖標 代碼 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"陸路運輸 圖標 代碼 圖標 代碼 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"水路運輸 圖標 代碼 圖標 代碼 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"空中運輸 圖標 代碼 圖標 代碼 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旅館 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"時間 圖標 代碼 圖標 代碼 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"天空與天氣 圖標 代碼 圖標 代碼 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"活動 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"事件 圖標 代碼 圖標 代碼 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"獎杯與獎牌 圖標 代碼 圖標 代碼 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"體育運動 圖標 代碼 圖標 代碼 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"遊戲 圖標 代碼 圖標 代碼 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"藝術與工藝 圖標 代碼 圖標 代碼 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"服裝 圖標 代碼 圖標 代碼 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"聲音 圖標 代碼 圖標 代碼 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"音樂 圖標 代碼 圖標 代碼 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"樂器 圖標 代碼 圖標 代碼 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"電話 圖標 代碼 圖標 代碼 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"電腦 圖標 代碼 圖標 代碼 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"燈光與影像 圖標 代碼 圖標 代碼 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"書與紙張 圖標 代碼 圖標 代碼 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"錢 圖標 代碼 圖標 代碼 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"郵件 圖標 代碼 圖標 代碼 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"書寫 圖標 代碼 圖標 代碼 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"辦公 圖標 代碼 圖標 代碼 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"鎖 圖標 代碼 圖標 代碼 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"工具 圖標 代碼 圖標 代碼 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"科學 圖標 代碼 圖標 代碼 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"醫療 圖標 代碼 圖標 代碼 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"生活用品 圖標 代碼 圖標 代碼 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它物品 圖標 代碼 圖標 代碼 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"符號 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"交通標識 圖標 代碼 圖標 代碼 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"警告 圖標 代碼 圖標 代碼 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"箭頭 圖標 代碼 圖標 代碼 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"宗教 圖標 代碼 圖標 代碼 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"生肖 圖標 代碼 圖標 代碼 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"影像符號 圖標 代碼 圖標 代碼 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"數學 圖標 代碼 圖標 代碼 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"標點符號 圖標 代碼 圖標 代碼 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"貨幣 圖標 代碼 圖標 代碼 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"按鍵符號 圖標 代碼 圖標 代碼 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"字母符號 圖標 代碼 圖標 代碼 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"幾何符號 圖標 代碼 圖標 代碼 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"其它符合 圖標 代碼 圖標 代碼 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"旗幟 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"常用旗幟 圖標 代碼 圖標 代碼 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"國家和地區旗幟 圖標 代碼 圖標 代碼 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":null,"content":"經驗 ","date":"2022-02-19","objectID":"/about/:1:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"簡疫聊天室 參與GDSC聯合黑客松比賽 2021/05/14 - 2021/05/16  利用PWA支援各式裝置的特性以及GPS定位功能打造屬於疫情期間的專屬聊天室。 背景介紹 在疫情嚴峻下，為了保護國民健康，實施居家隔離，一個人居家隔離14天，難免會感到寂寞與無聊， 因此透過黑客松比賽，與團隊共同開發網頁聊天室，不需要下載就可以使用， 並且使用PWA支援各式裝置，配合GPS定位功能，讓使用者可以與附近的居家隔離者聊天， 當系統偵測到使用者離開定位區或是14天居家隔離到期，帳號將會被註銷，讓記憶永遠留在這裡。  從16組 Google 學生開發者社群中榮獲 第二名 成績。  只花了 三天 的時間從零到開發聊天室前後端以及宣傳影片。 簡疫聊天室首頁\" 簡疫聊天室首頁 ","date":"2022-02-19","objectID":"/about/:1:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"京緯工程有限公司(尚在開發) 承包公司首頁開發及維護 2021/05/10 - 至今  幫助京緯工程有限公司開發公司官網，依照公司需求來特製化頁面樣式以及各式各樣的功能。 ","date":"2022-02-19","objectID":"/about/:1:2","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"活動申請系統 承包學校專案 2020/08 - 至今  利用PHP+Mysql+jQuery 開發線上填單系統，並且結合線上審核功能，串接Google日曆API、線上電子章產生。 背景介紹 協助學校開發活動申請系統，將以往的紙本送單，改成線上電子化，可以先於線上進行審核，減少紙張浪費，並且可以妥善保存歷屆活動紀錄，不會交接完資料遺失。   Google Analytics 當⽉最高活躍使用者數量：967 瀏覽量：40671。   原先紙本申請的 5天 工作流程，因活動申請系統電子化後減少到 1天，縮短了80% 的活動申請流程時間。 活動申請系統管理員介面\" 活動申請系統管理員介面 ","date":"2022-02-19","objectID":"/about/:1:3","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"證照 ","date":"2022-02-19","objectID":"/about/:2:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"RED HAT CERTIFIED ENGINEER (RHCE) 紅帽認證工程師 2019/07/05  熟悉設定NFS-Server/Client、Samba-Server/Client、ISCSI-Server/Client、Apache-Server、Database。  客製化bash參數、FireWall-SSH/Port Forwarding、啟用IPv6、Link aggrigation、Mail-Server、YUM Repo。 RHCE介紹 RHCE即是Red Hat 認證系統工程師，透過嚴謹的「Performance Base」實機操作考試方式，可以證明取得認證者擁有真正的專業技術實力。 RHCE證照\" RHCE證照 ","date":"2022-02-19","objectID":"/about/:2:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"RED HAT CERTIFIED SYSTEM ADMINISTRATOR (RHCSA) 紅帽初級認證 2019/01/11  熟悉重設Root密碼、設定網路、設定SELinux、設定時區、YUM Repository。  LVM、權限管理、Crontab、建立目錄及權限、更新Kernel、LDAP、文件處理。 RHCSA介紹 擁有RHCSA認證者能夠扮演著企業內各式各樣的角色，舉凡資料庫管理員，開發人員和技術支持人員…等職務，能重建與部署企業核心Linux環境，更能代表您具備管理技術與駕馭系統的能力。 RHCSA證照\" RHCSA證照 ","date":"2022-02-19","objectID":"/about/:2:2","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"教育 ","date":"2022-02-19","objectID":"/about/:3:0","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"朝陽科技大學 資訊工程系(CSIE) 2017 - 2021  系排第一畢業。  被學校邀請擔任過系統講師。  發現學校DNS安全漏洞，並開發腳本找出漏洞。 ","date":"2022-02-19","objectID":"/about/:3:1","tags":null,"title":"關於我","uri":"/about/"},{"categories":null,"content":"新民高級中學 資訊科 2014 - 2017 ","date":"2022-02-19","objectID":"/about/:3:2","tags":null,"title":"關於我","uri":"/about/"}]