<!DOCTYPE html>
<html lang="zh-tw">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Node.js 介紹 - PinYi</title><meta name="description" content="這裡是關於一個菜鳥工程師斜槓Youtuber的部落格"><meta property="og:title" content="Node.js 介紹" />
<meta property="og:description" content="什麼是 Node.js ? Node.js 是能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台執行環境。 Node.js 的出現，讓前端網站開發人員可以使用 JaveScript 來做後端或是系統層面的工作。讓前端開發" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.pin-yi.me/node/" /><meta property="og:image" content="https://blog.pin-yi.me/node/featured-image.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-30T10:45:29+08:00" />
<meta property="article:modified_time" content="2022-04-08T15:24:34+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.pin-yi.me/node/featured-image.webp"/>
<meta name="twitter:title" content="Node.js 介紹"/>
<meta name="twitter:description" content="什麼是 Node.js ? Node.js 是能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台執行環境。 Node.js 的出現，讓前端網站開發人員可以使用 JaveScript 來做後端或是系統層面的工作。讓前端開發"/>
<meta name="application-name" content="PinYi 部落格">
<meta name="apple-mobile-web-app-title" content="PinYi 部落格"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/avatar.webp"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.pin-yi.me/node/" /><link rel="prev" href="https://blog.pin-yi.me/go-restful-api-repository-messageboard/" /><link rel="next" href="https://blog.pin-yi.me/node-restful-api-repository-messageboard/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css">
        <link href="https://www.googletagmanager.com" rel="preconnect" crossorigin>
        <link rel="dns-prefetch" href="https://www.googletagmanager.com">
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Node.js 介紹",
        "inLanguage": "zh-tw",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.pin-yi.me\/node\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/blog.pin-yi.me\/node\/featured-image.webp",
                            "width":  1920 ,
                            "height":  450 
                        }],"genre": "posts","keywords": "Node.js, 實作, 介紹","wordcount":  9390 ,
        "url": "https:\/\/blog.pin-yi.me\/node\/","datePublished": "2022-03-30T10:45:29+08:00","dateModified": "2022-04-08T15:24:34+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Zhuang,Pin-Yi","logo": "https:\/\/blog.pin-yi.me\/images\/avatar.webp"},"author": {
                "@type": "Person",
                "name": "PinYi"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EK8X0P9SDS"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-EK8X0P9SDS', { 'anonymize_ip': false });
}
</script>
</head><body data-header-desktop="fixed" data-header-mobile="fixed"><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="PinYi">PinYi 部落格</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分類 </a><a class="menu-item" href="/tags/"> 標籤 </a><a class="menu-item" href="/sideproject/"> 作品集 </a><a class="menu-item" href="/categories/youtube/"> YouTube 影片 </a><a class="menu-item" href="https://pin-yi.me" rel="noopener noreffer" target="_blank"> 關於我 </a><span class="menu-item delimiter"></span><span class="menu-item language" title="選擇語言">繁體中文<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/node/" selected>繁體中文</option></select>
                    </span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="請輸入要搜尋的標題或是內容" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜尋">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a class="menu-item" href="/index.xml" title="RSS"><i class="fas fa-rss fa-fw" title="RSS"></i> </a><a href="javascript:void(0);" class="menu-item theme-switch" title="切換主題">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="PinYi">PinYi 部落格</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="請輸入要搜尋的標題或是內容" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜尋">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分類</a><a class="menu-item" href="/tags/" title="">標籤</a><a class="menu-item" href="/sideproject/" title="">作品集</a><a class="menu-item" href="/categories/youtube/" title="">YouTube 影片</a><a class="menu-item" href="https://pin-yi.me" title="" rel="noopener noreffer" target="_blank">關於我</a><div class="menu-item"><a href="/index.xml" title="RSS"><i class="fas fa-rss fa-fw" title="RSS"></i> </a>
                <span>&nbsp;|&nbsp;</span><a href="javascript:void(0);" class="theme-switch" title="切換主題">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div><span class="menu-item language" title="選擇語言">繁體中文<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/node/" selected>繁體中文</option></select>
                </span></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目錄</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="enable"><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/node/featured-image.webp"
        data-srcset="/node/featured-image.webp, /node/featured-image.webp 1.5x, /node/featured-image.webp 2x"
        data-sizes="auto"
        alt="/node/featured-image.webp"
        title="/node/featured-image.webp" /></div><div class="single-card" data-image="true"><h2 class="single-title animated flipInX">Node.js 介紹</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="https://pin-yi.me" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>PinYi</a></span>&nbsp;<span class="post-category">出版於  <a href="/categories/codenotes/"><i class="far fa-folder fa-fw"></i>程式筆記</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-03-30">2022-03-30</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;約 9390 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;預計閱讀 19 分鐘</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目錄</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#什麼是-nodejs-">什麼是 Node.js ?</a>
      <ul>
        <li><a href="#非阻塞-non-blocking">非阻塞 (non-blocking)</a></li>
        <li><a href="#非同步-asynchronous">非同步 (asynchronous)</a>
          <ul>
            <li><a href="#callback">Callback</a>
              <ul>
                <li><a href="#什麼是-callback">什麼是 Callback</a></li>
                <li><a href="#回呼地獄-callback-hell">回呼地獄 (Callback Hell)</a></li>
                <li><a href="#分別回呼-split-callback">分別回呼 (Split Callback)</a></li>
                <li><a href="#錯誤優先處理-error-first-style">錯誤優先處理 (Error-First Style)</a></li>
              </ul>
            </li>
            <li><a href="#promise">Promise</a>
              <ul>
                <li><a href="#then-方法">.then() 方法</a></li>
                <li><a href="#catch-方法">.catch() 方法</a></li>
                <li><a href="#串接-then-方法">串接 then() 方法</a></li>
                <li><a href="#promiseall-方法">Promise.all([&hellip;.]) 方法</a></li>
              </ul>
            </li>
            <li><a href="#asyncawait">Async/Await</a>
              <ul>
                <li><a href="#asyncawait-範例">Async/Await 範例</a></li>
                <li><a href="#await-搭配-promiseall-方法">await 搭配 Promise.all([&hellip;]) 方法</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#事件驅動-event-driven">事件驅動 (event-driven)</a>
          <ul>
            <li><a href="#事件-event">事件 (event)</a></li>
            <li><a href="#事件驅動-event-driven-1">事件驅動 (event-driven)</a></li>
            <li><a href="#事件迴圈-event-loop">事件迴圈 (event loop)</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#npm">NPM</a></li>
    <li><a href="#repl">REPL</a></li>
    <li><a href="#express-框架">Express 框架</a>
      <ul>
        <li><a href="#畫面-view">畫面 (view)</a></li>
        <li><a href="#路由-router">路由 (router)</a></li>
      </ul>
    </li>
    <li><a href="#參考資料">參考資料</a></li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><h2 id="什麼是-nodejs-">什麼是 Node.js ?</h2>
<p>Node.js 是能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台執行環境。</p>
<p>Node.js 的出現，讓前端網站開發人員可以使用 JaveScript 來做後端或是系統層面的工作。讓前端開發網站開發人員使用已懂的 JavaScript 語言就可以自行設定網站伺服器。</p>
<p>Node.js 採用 Google 開發的 Chrome V8 JavaScript 引擎和 libuv 函式庫，可以用指令去執行 JavaScript，使用非阻塞輸入輸出、非同步、事件驅動等技術來提高效能，可最佳化應用程式的傳輸量和規模。這些技術通常用於資料密集的即時應用程式。</p>
<br>
<figure><a class="lightgallery" href="/images/node/main-nodejs.png" title="/images/node/main-nodejs.png" data-thumbnail="/images/node/main-nodejs.png" data-sub-html="<h2>主要的 Node.js 組件 (An Intro to Node.js That You May Have Missed)</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/node/main-nodejs.png"
            data-srcset="/images/node/main-nodejs.png, /images/node/main-nodejs.png 1.5x, /images/node/main-nodejs.png 2x"
            data-sizes="auto"
            alt="/images/node/main-nodejs.png" width="700" />
    </a><figcaption class="image-caption">主要的 Node.js 組件 (<a href="https://itnext.io/an-intro-to-node-js-that-you-may-have-missed-b175ef4277f7" target="_blank" rel="noopener noreffer">An Intro to Node.js That You May Have Missed</a>)</figcaption>
    </figure>
<br>
<p>其他開源、低級組件，主要用 C/C++ 編寫：</p>
<ul>
<li>c-ares : 用於非同步 DNS 請求的 C 函式庫，用於 Node.js 中的一些 DNS 請求。</li>
<li>http-parser：一個輕量級的 HTTP 請求/回應解析器。</li>
<li>OpenSSL：一個著名的通用密碼庫。用於 <code>tls</code> 和 <code>cryto</code> 模組。</li>
<li>zlib：無損數據壓縮庫。</li>
</ul>
<br>
<p>Node.js 能快速的原因是因為他對資源的調校不同，當程式收到一筆連線，</p>
<p>相較於 PHP 的每次連線都會新生成一個執行緒，當連線數量暴增時很快就會消耗掉系統的資源，並且容易產生阻塞 (block)，</p>
<p>而 Node.js 則是會通知作業系統透過 epoll、kqueue、/dev/poll、select 等將連線保留，並放入 heap 中配置，先讓連線進入休眠 (Sleep) 狀態，等系統通知才觸發連線的 callback。</p>
<p>這種處理方式只會佔用記憶體，並不會使用到 CPU 資源。另外因為 JavaScript 語言的特性，每一個 request 都會有一個 callback，可以避免發生阻塞的狀況發生。</p>
<br>
<p>以下會先從非阻塞輸入輸出、非同步，再談到事件驅動。</p>
<br>
<h3 id="非阻塞-non-blocking">非阻塞 (non-blocking)</h3>
<p>輸入輸出(I/O) 是程式跟系統記憶體或網路的互動，例如發送 HTTP 請求、對資料庫CRUD 操作等等。</p>
<p>以網站開發者角度來看，大部分的網站程式都不需要太多的 CPU 計算，反而是在等待大量的 I/O 處理完畢 (HTTP 請求、資料庫的取得資料或是更新資料等)，所以處理 I/O 的速度會是網頁程式效能的關鍵。</p>
<br>
<p>那要怎麼才能讓等待 I/O 的時間，不要卡住後續的程式碼呢？可以讓程式一邊等 I/O 處理，一邊繼續執行其他部分的程式碼，主要有兩種方法：</p>
<ol>
<li>多執行緒 (multi-threaded)：使用阻塞 (blocking) I/O 的設計。</li>
<li>單執行緒 (single-threaded)：使用非阻塞 (non-blocking) I/O 的設計 + 非同步 (asynchronous) 處理。</li>
</ol>
<br>
<p><strong>阻塞就是 I/O 的處理阻擋了其他後續程式碼的執行</strong>。舉個例子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阻塞 (blocking)</th>
<th style="text-align:center">非阻塞 (non-blocking)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">阻塞後續程式碼的執行，就好像是我們去附近買烤肉，交給老闆後，為了想吃到熱騰騰的食物，所以只能留在原地，不能先去其他地方</td>
<td style="text-align:center">非阻塞不會阻擋後續程式碼的執行，就好像是我們去百貨公司美食街點餐，點完餐後會拿到一個呼叫器，就可以先離開，等到呼叫器響了再回去拿即可</td>
</tr>
</tbody>
</table>
<br>
<p>像是 <strong>Python、Ruby 等語言是使用多執行緒 (multi-threaded)，使用阻塞 I/O</strong> ：</p>
<p>程式會等網路或是記憶體的作業結束後才會繼續往下，等待時間這個作業中的執行緒不會去做其他事情。</p>
<p>如果想要達到『等待 I/O 期間不要卡住其他程式碼』，的做法就是新開一個執行緒，直到任務完成，再告訴主執行緒說( 我完成囉！) 即可。</p>
<br>
<p><strong>Node.js 使用單執行緒 (single-threaded) ，非阻塞 I/O + 非同步函式</strong>：</p>
<p>Node.js 使用非阻塞設計，那要怎麼去操作資料庫或是 HTTP 請求的輸入輸出呢？就要透過非同步 (asynchronous) 來處理囉！</p>
<br>
<h3 id="非同步-asynchronous">非同步 (asynchronous)</h3>
<p>非同步也可以稱為異步，它的作用就是讓程式不要被阻擋等 I/O 處理完，才可以跑下一行程式碼，是直到函式中的 callback 被呼叫的時候再執行後續要做的事情。</p>
<br>
<p>同步 vs. 非同步</p>
<br>
<ul>
<li>非同步 (asynchronous)</li>
</ul>
<p>可以想像一下你去咖啡廳買拿鐵跟黑咖啡，可能會發生的情況是：</p>
<ol>
<li>你點了拿鐵跟黑咖啡</li>
<li>店員在收銀機上輸入點餐內容</li>
<li>店員請同事 A 準備拿鐵、請同事 B 準備黑咖啡，並告知做完後，要提醒店員</li>
<li>黑咖啡製作會比較快，B 同事會先完成，而剛好店員剛幫你結帳完沒事，所以把黑咖啡拿給你</li>
<li>拿鐵製作包含較多步驟，花費時間較久，等 A 同事完成後，店員剛好沒事，所以把拿鐵拿給你</li>
</ol>
<br>
<p>可以看到，櫃檯店員一次只能做一件事情，但為了節省時間，店員將工作分配給其他同事，在下完指令後，店員會繼續幫你結帳，等同事們各自完成後會告知店員，店員在依序把飲料交給你 - 最終等待時間減少，也不會浪費閒置的資源，這就是現實生活中非同步的情況。</p>
<br>
<ul>
<li>同步 (synchronous)</li>
</ul>
<p>一樣我們點了拿鐵跟黑咖啡，換成同步的話：</p>
<ol>
<li>店員在收銀機上輸入點餐內容</li>
<li>店員請同事 A 開始準備拿鐵</li>
<li>A 同事準備完拿鐵，店員轉交給你</li>
<li>店員請同事 B 開始準備黑咖啡</li>
<li>B 同事準備完黑咖啡，店員交給你</li>
<li>店員幫你刷載具、打統編、找錢等等</li>
</ol>
<br>
<p>同樣的餐點內容，如果是同步處理，代表要等每一件事情做完，才可以做下一步。也就是說同事 A 完成拿鐵後，店員才請 B 同事準備黑咖啡。相對於非同步來說，會花費不少時間以及浪費不少閒置資源。</p>
<br>
<p>從咖啡店的例子中可以發現：</p>
<ol>
<li>櫃檯店員手上一次能做的事情只有一件 (Single thread 單執行緒)，只是在非同步的例子中，將製作咖啡的事情委派給其他同事處理，讓自己可以繼續幫你結帳，來提高效率 — JavaScript 是 Single thread，一次只能做一件事情。</li>
<li>在非同步的例子中，櫃檯店員將製作咖啡的事情委派出去，其實店員也不知道哪一個任務會先被完成，但店員還是可以繼續完成結帳的任務，不會因為同事 A、B 還在製作咖啡，就不能接下去動作 (non-blocking) — JavaScript 一次只能做一件事，但藉由 Node 提供的 API 協助，在背後處理這些事件 (同事在背後製作咖啡)，可以等待製作同時，不會被阻塞 (blocking) 到下一件事情的執行。</li>
<li>非同步的例子中，店員委派事情的流程很簡單：就是請同事完成製作咖啡 (event) + 在收到同事通知完成後接手咖啡，並轉交給你 (callback function) — 若是採用非同步處理，會有 callback function 來指定事件完成後要接續做什麼：它不會立即被執行，而是等待委託的事情被完成後才觸發。</li>
<li>當同事 A、B 分別通知完成後，就會依序把咖啡放在店員的旁邊排成一排 (event queue)。想向店員有一個小助手 (event loop) ，他的工作內容是確認店員結帳完了沒有：如果結帳完了，就會把隊伍中第一杯咖啡叫給店員，讓店員交給你 (觸發 callback function) ; 如果店員還在結帳，就會讓隊伍中的咖啡擺在旁邊繼續等待。</li>
</ol>
<br>
<p>JaveScript 實現非同步的方法不斷演進著：從 callback、promise 到最新的 async-await 函式。</p>
<br>
<h4 id="callback">Callback</h4>
<h5 id="什麼是-callback">什麼是 Callback</h5>
<p>假設有 A、B、C 三件工作，其中 B 必須等待 C 做完才能執行。大部份的人幾乎都是做 A，再做 C，等待 C 做完以後最後做 B。但對於可多工的人來說，卻可能是同時做 A 與 C（多工），等待 C 完成後做 B。</p>
<p>Callback function 是一個被作為參數帶入另一個函式中的「函式」，這個被作為參數帶入的函式將在「未來某個時間點」被呼叫和執行 — 這是處理非同步事件的一種方式。</p>
<p>再次舉 A、B、C 三件工作的例子，其中 B 必須等待 C 做完才能執行，於是我們將 B 放到 C 的 callback 中，讓宿主環境在收到 C 完成的回應時後 B 放到佇列中準備執行。</p>
<br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">doA</span><span class="p">();</span>

<span class="nx">doC</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">doB</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>常見的例子：</p>
<ul>
<li>使用瀏覽器所提供的 <code>setTimeout()</code>或是 <code>setInterval()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;這個訊息將在三秒後被印出來&#39;</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">3000</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>提供一個匿名函式作為參數帶入 setTimeout() 函式中，目的就是請 setTimeout() 在未來某個時間點（三秒後）呼叫和執行這個匿名函式。</p>
<br>
<ul>
<li>DOM 的事件監聽</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;button&#39;</span><span class="p">)</span>
<span class="nx">btn</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">callbackFunctionName</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>callbackFunctionName 做為參數被帶入 addEventListener() 中，callbackFunctionName 不會立即被執行，而是未來按鈕被點擊時才會執行。</p>
<br>
<p>Callback 主要有一個缺點：<code>回呼地獄</code></p>
<br>
<h5 id="回呼地獄-callback-hell">回呼地獄 (Callback Hell)</h5>
<p>回呼地獄 (Callback Hell) 又稱為「毀滅金字塔」，指的是層次太深的巢狀 Callback，讓程式變的更複雜且難以預測或是追蹤。</p>
<p>向遠端伺服器發出請求並獲得資訊後，執行 Callback，再發出請求，獲得資訊後執行 Callback，再發出請求，獲得資訊後執行 Callback，就會不小心一層包一層，變成所謂的 Callback Hell。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">doA</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doB</span><span class="p">();</span>

  <span class="nx">doC</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">doD</span><span class="p">();</span>
  <span class="p">});</span>

  <span class="nx">doE</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">doF</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>缺點：</p>
<ol>
<li>可讀性低：如果程式碼出錯，要回頭慢慢找錯誤的地方</li>
<li>可維護性低：如果要修改其中一組函式，牽一髮而動全身</li>
</ol>
<br>
<p>那在同步執行情況下，可以使用 <code>try...catch</code> 來捕捉錯誤訊息，但如果是在非同步情況下，要怎麼處理錯誤或是例外訊息呢！？ 主要有兩種方式：</p>
<br>
<h5 id="分別回呼-split-callback">分別回呼 (Split Callback)</h5>
<p>分別的回呼要設定兩個 Callback，一個用於成功通知，另一個則用於錯誤通知。如下，第一個參數是用於成功的 Callback，第二個參數是用於失敗的 Callback：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">success</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">failure</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;http://sample.url&#39;</span><span class="p">,</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">failure</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>那如果在 Callback 中發生錯誤，要怎麼辦呢!?</p>
<br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">success</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">failure</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;http://sample.url&#39;</span><span class="p">,</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">failure</span><span class="p">);</span>

<span class="c1">// Uncaught (in promise) ReferenceError: x is not defined
</span></code></pre></td></tr></table>
</div>
</div><p>會直接報錯，並不會進入到 failure 這個 Callback 裡面，也就是說，如果是在 Callback 內發生錯誤，是不會被捕捉到的。</p>
<br>
<h5 id="錯誤優先處理-error-first-style">錯誤優先處理 (Error-First Style)</h5>
<p>Node.js 的 API 常見這樣的設計方式，第一個參數是 error ，第二個參數是回應的資料 (data)。檢查 error 是否有值或是 true，否則就接續處理 data。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">response</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;http://sample.url&#39;</span><span class="p">,</span> <span class="nx">response</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>接下來我們來看 Promise，可以解決 callback 可讀性低的 Callback Hell 問題。</p>
<br>
<h4 id="promise">Promise</h4>
<p>Promise：Callback 以外的另一種方式來處理非同步事件，且可讀性與可維護性比 Callback 好很多。
Promise 是一個物件，代表著一個尚未完成，但最終會完成的一個動作 - 在一個非同步處理流程中，它只是一個暫存的值。</p>
<p>我們一樣來說剛剛咖啡店的例子：
當我們點完拿鐵跟黑咖啡後，店員會給你一張印有號碼的收據，然後告訴你等等聽到號碼，就可以來領咖啡了，而這張收據就是 Promise，代表這個任務完成後，就可以接著執行接下來的動作了。</p>
<p>在等待過程中，其實無法百分百確定最後一定會拿到咖啡 (Promise) ; 店員可能順利做完咖啡交到你手上 (Resolved) ; 可能牛奶或是咖啡豆沒了，所以店員告訴你今天做不出來咖啡 (Rejected)。</p>
<p>Promise 就像上面的例子中，會處在三個任意階段中：</p>
<ul>
<li>Pedning：等待事情完成中，但不確定最終會順利完成或失敗</li>
<li>Resolved（或稱 Fulfilled）：代表順利完成了，並轉交結果</li>
<li>Rejectesd：代表失敗了，並告知失敗原因</li>
</ul>
<br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">getData</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 製作咖啡.....
</span><span class="c1"></span>    
    <span class="c1">// 作業完成，並回傳錯誤訊息時
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;牛奶或是咖啡豆沒了&#39;</span><span class="p">)</span>
    <span class="p">}</span> 
    <span class="c1">// 作業成功完成
</span><span class="c1"></span>    <span class="nx">resolve</span><span class="p">({</span>
        <span class="nx">data</span><span class="o">:</span> <span class="s1">&#39;咖啡交到你手上&#39;</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>resolve 函式：當非同步作業成功完成時，將結果做為參數帶入執行。</li>
<li>reject 函式：當非同步作業失敗時，將錯誤訊息作為參數帶入執行。</li>
</ul>
<br>
<p>創建出來的 Promise 物件在實例上有兩個重要的方法：</p>
<h5 id="then-方法">.then() 方法</h5>
<p>當成功從 <code>resolve()</code> 獲得結果時 - 狀態會由 Pending 轉為 Resolved - <code>then()</code> 方法就會被調用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">getData</span>
  <span class="c1">// 使用 then 方法，並將成功訊息印出來
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功資料&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)})</span>
</code></pre></td></tr></table>
</div>
</div><p>以剛剛咖啡店的例子來看， <code>then()</code> 方法就像你會去聽咖啡人員是否叫號，並確認咖啡是否成功準備好了，就領取咖啡來喝。</p>
<br>
<h5 id="catch-方法">.catch() 方法</h5>
<p>當從 <code>reject()</code> 獲得錯誤訊息時 - 狀態由 Pending 轉為 Rejected - <code>catch()</code> 方法就會被調用來處理錯誤。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">getData</span>
  <span class="c1">// 使用 then 方法，並將成功訊息印出來
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;成功資料&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)})</span>
  <span class="c1">// 使用 catch 方法，並將錯誤訊息印出來
</span><span class="c1"></span>  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;錯誤訊息&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>一樣以剛剛咖啡店的例子來看， <code>catch()</code> 方法就像你會去聽咖啡店店員是否有告知咖啡做不出來的訊息，如果有，你就會去櫃檯退錢或是改其他產品代替。</p>
<br>
<h5 id="串接-then-方法">串接 then() 方法</h5>
<p>還記得上面我們示範的 callback hell ，因為我們依序要向不同的伺服器或資料庫取得資料，也要依序處理多個非同步的作業，所以會有一層一層的 callback 去達成。</p>
<p>從上面 <code>then()</code> 和 <code>catch()</code> 方法例子中可以發現，非同步作業執行完成後的處理步驟被獨立開來，這樣程式碼的可讀性就會高很多 - 在依序處理多個非同步作業時會更為明顯，我們可以看到下面我們用 <code>then()</code> 方法做串接：</p>
<br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">getData</span>
  <span class="c1">// 使用 then 方法，並將成功訊息印出來
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">data1</span><span class="p">)</span> <span class="c1">// abc
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">data1</span> <span class="o">+</span> <span class="s1">&#39;def&#39;</span>
  <span class="p">})</span>
  <span class="c1">// 獲得前一個 then() 回傳的結果
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// abcdef
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">data</span> <span class="o">+</span> <span class="s1">&#39;ghi&#39;</span>
  <span class="p">})</span>
  <span class="c1">// 獲得前一個 then() 回傳的結果
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// abcdefghi
</span><span class="c1"></span>  <span class="p">})</span>
  <span class="c1">// 使用 catch 方法，並將錯誤訊息印出來
</span><span class="c1"></span>  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;錯誤訊息&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h5 id="promiseall-方法">Promise.all([&hellip;.]) 方法</h5>
<p>當在處理「多個非同步事件」時，Promise.all() 方法會等所有 Promise 都被順利完成 (Resolved) 後，才會執行接下去的動作 ; 一旦收到某一個 Promise 回傳錯誤 (Rejected)，就會立即執行後續的錯誤處理流程。</p>
<p>我們以剛剛咖啡店的例子來說，我們點完咖啡後，又因為嘴饞，多買了一個麵包來吃，這時我們手上就有兩個領餐號碼，那 <code>Promise.all([...])</code> 就是當你等到兩個號碼都被叫到後，才會去領餐。</p>
<br>
<p>那 <code>Promise.all([....])</code> 的好處什麼呢!? 它可以縮短等待時間：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">oneSecond</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 一秒後回傳資料
</span><span class="c1"></span>    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;one second&#39;</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">})</span>

<span class="kr">const</span> <span class="nx">twoSecond</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 兩秒後回傳資料
</span><span class="c1"></span>    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;two second&#39;</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">})</span>

<span class="kr">const</span> <span class="nx">threeSecond</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 三秒後回傳資料
</span><span class="c1"></span>    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;three second&#39;</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>
<span class="p">})</span>

<span class="c1">// 等到三個 Promise 都成功回傳後，才執行接下去的流程
</span><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">oneSecond</span><span class="p">,</span> <span class="nx">twoSecond</span><span class="p">,</span> <span class="nx">threeSecond</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">oneSecond</span><span class="p">,</span> <span class="nx">twoSecond</span><span class="p">,</span> <span class="nx">threeSecond</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oneSecond</span><span class="p">,</span> <span class="nx">twoSecond</span><span class="p">,</span> <span class="nx">threeSecond</span><span class="p">)</span>
  <span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>我們模擬一下我們要分別向三個資料庫請求資料 (我們以 <code>setTimeout()</code> 示意非同步處理事件)，可以看到我們要先等第一個資料庫成功回傳資料後，才展開第二次請求，等到成功收到回傳後才開始第三次請求。而使用 <code>Promise.all()</code> 方法，我們能先依序向資料庫發出請求，並在成功獲得全部回傳資料後，才會做後續的動作。</p>
<br>
<h4 id="asyncawait">Async/Await</h4>
<p>那我們剛剛透過 Promise 包裝和使用，的確避免了 callback hell 讓整個流程變得很清楚，提升了程式碼的易讀性與可維護性。</p>
<p>Async/Await 是所謂的語法糖衣，是一種新的語法撰寫方式，來處理「非同步事件」，讓非同步的程式碼讀起來更像在寫「同步程式碼」。</p>
<p>Async/Await 是用來簡單化和清楚化 Promise 串連 then 這種相對複雜的結構，他回傳的一樣也是 Promise 物件，只是針對 promise-based 寫法進行包裝。</p>
<br>
<p>Async 關鍵字</p>
<p><code>async</code> 關鍵字可以放在任意函式前面，它代表「我們正宣告一個非同步的函式，且這個函式會回傳一個 Promise 物件」：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 一般函式
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">getGroupInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>

<span class="c1">// 使用 async 函式
</span><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getGroupInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span>  <span class="nx">data</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>Await 關鍵字</p>
<p>在 <code>async</code> 函式中使用 <code>await</code> 關鍵字，代表「我們請 JavaScript 等待這個非同步的作業完成後，才展開後續的動作」，換句話說：await 讓 async 函式的執行動作暫停，等到它獲得回傳的 Promise 物件後 - 無論執行成功 (resolve) 或是失敗 (rejected) -才會恢復執行 async 函式。</p>
<ul>
<li>優點：可以直接使用 await 後獲得的回傳值存於一個變數中做後續使用，而不是在呼叫 <code>then()</code> 方法一個一個串，讓程式碼看起來像是在處裡一般的同步程式碼，提升了易讀性與可維護性。</li>
</ul>
<br>
<h5 id="asyncawait-範例">Async/Await 範例</h5>
<p>我們在後續的範例，一樣使用 <code>setTimeout()</code> 來模擬資料庫請求和等待資料的非同步：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">getFirstInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;first data&#39;</span><span class="p">)</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getSecondInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;second data&#39;</span><span class="p">)</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kr">async</span> <span class="kd">function</span> <span class="nx">getGroupInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 代表等到第一筆資料回傳後，才印出結果和請求第二筆資料
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">firstInfo</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getFirstInfo</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstInfo</span><span class="p">)</span>
  <span class="c1">// 代表等到第二筆資料回傳後，才印出結果
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">secondInfo</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getSecondInfo</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">secondInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">getGroupInfo</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在 <code>getGroupInfo()</code>  函式前加上 <code>async</code> 關鍵字，來告知值這是一個非同步函示， <code>getFirstInfo()</code> 跟 <code>getSecondInfo()</code> 是兩個要處理非同步的地方，因此分別在兩個呼叫函式前加上 <code>await</code> 關鍵字。</p>
<br>
<h5 id="await-搭配-promiseall-方法">await 搭配 Promise.all([&hellip;]) 方法</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js">
<span class="kd">function</span> <span class="nx">getFirstInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 1秒後回傳結果
</span><span class="c1"></span>      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;first data&#39;</span><span class="p">)</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getSecondInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 2秒後回傳結果
</span><span class="c1"></span>      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;second data&#39;</span><span class="p">)</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kr">async</span> <span class="kd">function</span> <span class="nx">getGroupInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">firstInfo</span> <span class="o">=</span> <span class="nx">getFirstInfo</span><span class="p">()</span>
    <span class="kr">const</span> <span class="nx">secondInfo</span> <span class="o">=</span> <span class="nx">getSecondInfo</span><span class="p">()</span>
    <span class="c1">// 同步發出非同步請求，並等到兩秒後（非三秒）成功獲得兩筆回傳後，才印出結果
</span><span class="c1"></span>    <span class="kr">const</span> <span class="p">[</span><span class="nx">firstData</span><span class="p">,</span> <span class="nx">secondData</span><span class="p">]</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">firstInfo</span><span class="p">,</span> <span class="nx">secondInfo</span><span class="p">])</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstData</span><span class="p">,</span> <span class="nx">secondData</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 處理錯誤回傳
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">getGroupInfo</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>透過 <code>await</code> 關鍵字搭配 <code>Promise.all()</code> 方法，同步向兩個資料庫獲取資料，並等到兩筆資料都成功回傳後，才印出結果 - 省時效率提高！</p>
<br>
<p>我們可以看到下面這張圖，他是 Node.js 運行時的縮圖，一旦你的 Node.js 應用程序啟動，它會先開始一個初始化階段，運行啟動腳本，包括請求模組和註冊事件 callback。然後應用程序進入事件循環（也稱為主線程、事件線程等），從概念上講，它是為通過執行適當的 JS callback 來響應傳入的客戶端請求而構建的。</p>
<br>
<figure><a class="lightgallery" href="/images/node/run-nodejs.png" title="/images/node/run-nodejs.png" data-thumbnail="/images/node/run-nodejs.png" data-sub-html="<h2>Node.js 運行時的圖示 (An Intro to Node.js That You May Have Missed)</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/node/run-nodejs.png"
            data-srcset="/images/node/run-nodejs.png, /images/node/run-nodejs.png 1.5x, /images/node/run-nodejs.png 2x"
            data-sizes="auto"
            alt="/images/node/run-nodejs.png" width="700" />
    </a><figcaption class="image-caption">Node.js 運行時的圖示 (<a href="https://itnext.io/an-intro-to-node-js-that-you-may-have-missed-b175ef4277f7" target="_blank" rel="noopener noreffer">An Intro to Node.js That You May Have Missed</a>)</figcaption>
    </figure>
<br>
<p>libuv 是非同步處理的函式庫（以 C 語言為主)，在面對非同步作業時，會開啟執行緒池 (thread pool / worker pool) ，預設共有四個執行緒 (也就是 worker threads)，運算這些 I/O 用的方式是事件迴圈 (event loop)。</p>
<p>所以就算 V8 處理程式碼是單執行緒，一但進入到 libuv 手上，它還是會幫你把會阻塞的 I/O 分工到執行緒池中交給不同的執行緒去處理，直到 callback 發生才會丟回應讓程式知道。</p>
<p>那我們來看看 libuv 如何透過事件迴圈有效的處理非同步 I/O。</p>
<br>
<h3 id="事件驅動-event-driven">事件驅動 (event-driven)</h3>
<p>在講事件驅動前，我們先來了解一下什麼是事件：</p>
<br>
<h4 id="事件-event">事件 (event)</h4>
<p>事件是指用戶或是系統作出的動作，例如使用者點選按鈕，或是檔案讀取完成、某種錯誤產生等等，都叫做事件。</p>
<br>
<h4 id="事件驅動-event-driven-1">事件驅動 (event-driven)</h4>
<p>事件驅動是一種程式執行模型，表示程式的進行是依據事件的發生而定，監聽到事件就處理、處理完就執行 callback ，透過不斷的監聽跟回應事件執行程式。</p>
<p>而事件驅動在不同的地方有不同的實現。瀏覽器 (前端) 和 Node.js (後端) 基於不同的技術實現了各自的事件迴圈。就 Ndoe.js 來說，事件就是交給 libuv 去處理 ; 至於瀏覽器的事件迴圈在 HTML 5 的規範中有定義。</p>
<br>
<h4 id="事件迴圈-event-loop">事件迴圈 (event loop)</h4>
<p>因為 Node.js 只有一個執行緒，所以當 libuv 把非同步事件處理完後，callback 要被丟回應用程式中排隊，等待主執行緒的 stack 為空的時候，才會開始執行。這個排隊的地方就是事件佇列 (event queue)。</p>
<p>libuv 會不斷檢查有沒有 callback 需要被執行，有的話分配到主執行緒結束手邊的程式後處理，因此這個過程稱為 『事件迴圈』。</p>
<br>
<figure><a class="lightgallery" href="/images/node/event-loop.png" title="/images/node/event-loop.png" data-thumbnail="/images/node/event-loop.png" data-sub-html="<h2>事件迴圈(event loop) (Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈)</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/node/event-loop.png"
            data-srcset="/images/node/event-loop.png, /images/node/event-loop.png 1.5x, /images/node/event-loop.png 2x"
            data-sizes="auto"
            alt="/images/node/event-loop.png" width="700" />
    </a><figcaption class="image-caption">事件迴圈(event loop) (<a href="https://medium.com/wenchin-rolls-around/node-js-101-%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92-%E9%9D%9E%E5%90%8C%E6%AD%A5-%E9%9D%9E%E9%98%BB%E5%A1%9E-i-o-%E8%88%87%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88-ef94f8359eee" target="_blank" rel="noopener noreffer">Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈</a>)</figcaption>
    </figure>
<br>
<p>libuv 事件迴圈有哪些階段呢？</p>
<figure><a class="lightgallery" href="/images/node/libuv.png" title="/images/node/libuv.png" data-thumbnail="/images/node/libuv.png" data-sub-html="<h2>libuv 事件迴圈 (nexocode)</h2>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/node/libuv.png"
            data-srcset="/images/node/libuv.png, /images/node/libuv.png 1.5x, /images/node/libuv.png 2x"
            data-sizes="auto"
            alt="/images/node/libuv.png" width="700" />
    </a><figcaption class="image-caption">libuv 事件迴圈 (<a href="https://nexocode.com/blog/posts/behind-nodejs-event-loop/" target="_blank" rel="noopener noreffer">nexocode</a>)</figcaption>
    </figure>
<br>
<p>libuv 的事件迴圈共有六個階段，每個階段的作用如下：</p>
<ol>
<li>
<p>Timers：等計時器 (setTimeout、setInterval) 的時間一到，會把他們的 callback 放到這裡等待執行。</p>
</li>
<li>
<p>Pending callbacks：會把作業系統層級的錯誤給callback (TCP errors、sockets 連線被拒絕)。</p>
</li>
<li>
<p>Idle, prepare：內部使用。</p>
</li>
<li>
<p>Poll：最重要的一個階段。</p>
<ol>
<li>如果 Queue 不為空，依次取出 callback 函數執行，直到 Queue 為空或是抵達系統最大限制。</li>
<li>如果 Queue 為空但有設置 「setImmediate」，就進入 check 階段。</li>
<li>如果 Queue 為空但沒有設置 「setImmediate」，就會在 Poll 階段等到直到 Queue 有東西或是 Timers 時間抵達。</li>
</ol>
</li>
<li>
<p>Check：處理 setImmediate 的 callback。</p>
</li>
<li>
<p>Close callbacks：執行 close 事件的 callback，利如 socket.destroy()。</p>
</li>
</ol>
<br>
<p>事件迴圈就是不斷重複以上階段。每個階段都有自己的 callback 佇列，在進入某個階段時，都會從所屬的佇列中取出 callback 來執行，當佇列為空或者被執行 callback 的數量達到系統的最大數量時，就會進入下一階段。</p>
<br>
<p>根據以上提到事件驅動、單執行緒和非同步、非阻塞的 I/O 處理特性，Node.js 很適合拿來開發 I/O 密集型應用程式，如影音串流、即時互動、在線聊天、遊戲、協作工具、股票行情等軟體。</p>
<br>
<h2 id="npm">NPM</h2>
<p>NPM 是跟 Node.js 一起安裝的線上套件庫，可以下載各式各樣的 JavaScript 套件來使用，能解決 Node.js 代碼部署上的很多問題。</p>
<br>
<p>安裝好後，可以使用 <code>npm -v</code> 來檢查版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ npm -v
8.5.0
</code></pre></td></tr></table>
</div>
</div><br>
<p>跟 NPM 息息相關的是 <code>package.json</code> 這個檔案，他是掌管專案資訊的重要檔案，我們可以使用 <code>init</code> 指令來設定 package.json：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.
.... 省略 ....

Press ^C at any <span class="nb">time</span> to quit.
package name: <span class="o">(</span>message<span class="o">)</span> demo
version: <span class="o">(</span>1.0.0<span class="o">)</span> 
description: 
entry point: <span class="o">(</span>index.js<span class="o">)</span> 
<span class="nb">test</span> command: 
git repository: 
keywords: 
author: ian &lt;880831ian@gmail.com&gt;
license: <span class="o">(</span>ISC<span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>name: 就是該專案的名字，它預設就是該目錄名。</li>
<li>description: 專案描述。</li>
<li>entry point: 專案切入點，這有點複雜，之後再說。</li>
<li>test command: 專案測試指令，之後說。</li>
<li>git repository: 專案原始碼的版本控管位置。</li>
<li>keywoard: 專案關鍵字</li>
<li>author: 專案作者，以 author-name <a href="mailto:author@email.com" rel="">author@email.com</a> 寫之。</li>
<li>license: 專案版權。</li>
</ul>
<br>
<p>設定好後，專案資料夾就會多一個 <code>package.json</code> 的檔案，打開後可以看到，是我們剛剛所設定好的資訊：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;demo&#34;</span><span class="p">,</span>
  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span><span class="p">,</span>
  <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;main&#34;</span><span class="p">:</span> <span class="s2">&#34;index.js&#34;</span><span class="p">,</span>
  <span class="nt">&#34;scripts&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;test&#34;</span><span class="p">:</span> <span class="s2">&#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;author&#34;</span><span class="p">:</span> <span class="s2">&#34;ian &lt;880831ian@gmail.com&gt;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;license&#34;</span><span class="p">:</span> <span class="s2">&#34;ISC&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>接下來，要如何下載網路上的模組，要使用 <code>install</code> 指令來下載，我們下載 Node.js 最小又靈活的 Web 應用程式框架 express 來做示範：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ npm install express

added <span class="m">50</span> packages, and audited <span class="m">51</span> packages in 1s

<span class="m">2</span> packages are looking <span class="k">for</span> funding
  run <span class="sb">`</span>npm fund<span class="sb">`</span> <span class="k">for</span> details

found <span class="m">0</span> vulnerabilities
</code></pre></td></tr></table>
</div>
</div><br>
<p>下載好後，可以看到剛剛 <code>package.json</code> 檔案多了 <code>dependencies</code> 欄位，它裡面會紀錄我們安裝了哪些套件，所以未來我們想知道專案使用了哪些套件，我們可以從 <code>dependencies</code> 這個欄位知道。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;demo&#34;</span><span class="p">,</span>
  <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span><span class="p">,</span>
  <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;main&#34;</span><span class="p">:</span> <span class="s2">&#34;index.js&#34;</span><span class="p">,</span>
  <span class="nt">&#34;scripts&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;test&#34;</span><span class="p">:</span> <span class="s2">&#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;author&#34;</span><span class="p">:</span> <span class="s2">&#34;ian &lt;880831ian@gmail.com&gt;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;license&#34;</span><span class="p">:</span> <span class="s2">&#34;ISC&#34;</span><span class="p">,</span>
  <span class="nt">&#34;dependencies&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;express&#34;</span><span class="p">:</span> <span class="s2">&#34;^4.17.3&#34;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>除此之外，還會多一個 <code>node_modules</code> 資料夾，這個資料夾就會存放我們所下載的套件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ls node_modules/
accepts             cookie-signature    etag                inherits            mime-types          qs                  setprototypeof
array-flatten       debug               express             ipaddr.js           ms                  range-parser        statuses
body-parser         depd                finalhandler        media-typer         negotiator          raw-body            toidentifier
bytes               destroy             forwarded           merge-descriptors   on-finished         safe-buffer         type-is
content-disposition ee-first            fresh               methods             parseurl            safer-buffer        unpipe
content-type        encodeurl           http-errors         mime                path-to-regexp      send                utils-merge
cookie              escape-html         iconv-lite          mime-db             proxy-addr          serve-static        vary
</code></pre></td></tr></table>
</div>
</div><br>
<p>當我們都安裝好後，express 已經包在 <code>node_modules</code> 目錄內，在專案裡面，就可以使用 require(&lsquo;套件名稱‘) 來使用套件囉！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>因為這些套件都可以直接在網路上下載到，所以在推送 git 專案時，可以使用 <code>.gitignore</code> 來隱藏不想被 push 的檔案，當我們想要下載套件回來時，只要使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ npm install
</code></pre></td></tr></table>
</div>
</div><p>就可以依照 <code>package.json</code> 裡面的 <code>dependencies</code> 來下載套件！</p>
<h2 id="repl">REPL</h2>
<p>Node.js REPL  (交互式解釋器)：表示一個電腦環境，類似 Windoes 系統的終端或是 Unix/Linux 的 Shell，我們可以在終端機上輸入命令，並接收系統的響應。</p>
<p>Node 自帶了交互式解釋器，可以執行以下任務：</p>
<ul>
<li>讀取：讀取用戶輸入，解析輸入的 JavaScript 數據結構並儲存在內存中。</li>
<li>執行：執行輸入的數據結構。</li>
<li>顯示：輸出結果。</li>
<li>循環：循環以上任務直到用戶按下兩次的 ctrl+c 按鈕退出。</li>
</ul>
<br>
<p>我們可以輸入以下命令來啟動 Node 的終端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ node
Welcome to Node.js v16.14.2.
Type <span class="s2">&#34;.help&#34;</span> <span class="k">for</span> more information.
&gt;
</code></pre></td></tr></table>
</div>
</div><br>
<p>可以執行簡單的數學運算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ node

Welcome to Node.js v16.14.2.
Type <span class="s2">&#34;.help&#34;</span> <span class="k">for</span> more information.
&gt; 1+4
<span class="m">5</span>
&gt; 5/2
2.5
&gt; 3*7
<span class="m">21</span>
&gt; 4-3
<span class="m">1</span>
&gt; <span class="m">1</span> + <span class="o">(</span>2*4<span class="o">)</span> -5
<span class="m">4</span>
&gt;
</code></pre></td></tr></table>
</div>
</div><br>
<p>也可以將數據存在變數中，在需要時使用它。變數宣告需要使用 <code>var</code> 關鍵字，如果沒有使用關鍵字，會直接顯示出來。也可以使用 <code>console.log()</code> 來輸出變數</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ node

Welcome to Node.js v16.14.2.
Type <span class="s2">&#34;.help&#34;</span> <span class="k">for</span> more information.
&gt; <span class="nv">x</span> <span class="o">=</span> <span class="m">19</span>
<span class="m">19</span>
&gt; var <span class="nv">y</span> <span class="o">=</span> <span class="m">10</span>
undefined
&gt; x + y
<span class="m">29</span>
&gt; console.log<span class="o">(</span><span class="s2">&#34;Hello&#34;</span><span class="o">)</span>
Hello
undefined
&gt;
</code></pre></td></tr></table>
</div>
</div><br>
<p>Node REPL 也支持輸入多行程式，我們試著寫一個 do-while 迴圈：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">Welcome to Node.js v16.14.2.
Type <span class="s2">&#34;.help&#34;</span> <span class="k">for</span> more information.
&gt; var <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>
undefined
&gt; <span class="k">do</span> <span class="o">{</span>
... x++<span class="p">;</span>
... console.log<span class="o">(</span><span class="s2">&#34;x:&#34;</span> + x<span class="o">)</span><span class="p">;</span>
... <span class="o">}</span> <span class="k">while</span> <span class="o">(</span>x&lt;5<span class="o">)</span><span class="p">;</span>
x:1
x:2
x:3
x:4
x:5
undefined
&gt;
</code></pre></td></tr></table>
</div>
</div><br>
<p>也可以使用下底線(_)來獲得上一個程式的運算結果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ node

Welcome to Node.js v16.14.2.
Type <span class="s2">&#34;.help&#34;</span> <span class="k">for</span> more information.
&gt; var <span class="nv">x</span> <span class="o">=</span> <span class="m">10</span>
undefined
&gt; var <span class="nv">y</span> <span class="o">=</span> <span class="m">20</span>
undefined
&gt; x + y
<span class="m">30</span>
&gt; var <span class="nv">sum</span> <span class="o">=</span> _
undefined
&gt; console.log<span class="o">(</span>sum<span class="o">)</span>
<span class="m">30</span>
undefined
&gt;
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="express-框架">Express 框架</h2>
<p>Node.js 在實作上不會單獨使用，通常會搭配框架去使用，像是 <a href="https://expressjs.com/" target="_blank" rel="noopener noreffer">Express JS 後端框架</a>，可以讓開發人員在寫同一個功能時，少寫很多程式的工具。</p>
<p>Express 是 Node.js 環境下提供的輕量後端架構，自由度極高，透過豐富的 HTTP 工具，能快速發開後端應用程式，它提供：</p>
<ul>
<li>替不同 HTTP Method、不同 URL 路徑的 requests 編寫不同的處理方法。</li>
<li>透過整合「畫面」的渲染引擎來達到插入資料到樣板產生 response。</li>
<li>設定常見的 web 應用程式，例如：連線用的 Port 和產生 response 樣板的位置。</li>
<li>在 request 的處理流程中增加而外的中間層 (Middleware) 進行處理。</li>
</ul>
<br>
<p>第一個 Express Hello world 程式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">()</span>
<span class="kr">const</span> <span class="nx">port</span> <span class="o">=</span> <span class="mi">3000</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Hello World!&#39;</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Example app listening on port </span><span class="si">${</span><span class="nx">port</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ node app.js

Example app listening on port <span class="m">3000</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>node</code> 來啟動伺服器，並使用 Port 3000 來連線。應用程式指向 URL (/) 的路由，以 &ldquo;Hello World!&rdquo; 回應如果是其他路徑，res 就會回應 404 找不到。</p>
<br>
<h3 id="畫面-view">畫面 (view)</h3>
<p>剛剛有提到說它可以使用整合「畫面」的渲染引擎來顯示到樣板，我們可以透過 <code>--view</code> 指令來產生樣板以及應用程式的目錄：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ express --view<span class="o">=</span>pub
   create : public/
   create : public/javascripts/
   create : public/images/
   create : public/stylesheets/
   create : public/stylesheets/style.css
   create : routes/
   create : routes/index.js
   create : routes/users.js
   create : views/
   create : app.js
   create : package.json
   create : bin/
   create : bin/www
</code></pre></td></tr></table>
</div>
</div><br>
<h3 id="路由-router">路由 (router)</h3>
<p>路由是判斷應用程式如何回應用戶端對特定端點的要求，而特定端點是一個 URL 或是路徑，與一個特定的 HTTP 要求方法 (GET、POST) 等，路由定義的結構如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">METHOD</span><span class="p">(</span><span class="nx">PATH</span><span class="p">,</span> <span class="nx">HANDLER</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其中</p>
<ul>
<li>app 是 express 的實例。</li>
<li>METHOD 是 HTTP 要求的方法。</li>
<li>PATH 是伺服器上的路徑。</li>
<li>HANDLER 是當路由相符時要執行的函數。</li>
</ul>
<br>
<p>以下範例簡單說明不同 HTTP 要求的方法：</p>
<p>首頁中以 Hello World! 回應。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Hello World!&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>對根路由 (/)（應用程式的首頁）發出 POST 要求時的回應：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Got a POST request&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>對 /user 路由發出 PUT 要求時的回應：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Got a PUT request at /user&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>對 /user 路由發出 DELETE 要求時的回應：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Got a DELETE request at /user&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="參考資料">參考資料</h2>
<p><a href="https://nodejs.dev/learn/introduction-to-nodejs" target="_blank" rel="noopener noreffer">Node.js 官網</a></p>
<p><a href="https://medium.com/wenchin-rolls-around/node-js-101-%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92-%E9%9D%9E%E5%90%8C%E6%AD%A5-%E9%9D%9E%E9%98%BB%E5%A1%9E-i-o-%E8%88%87%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88-ef94f8359eee" target="_blank" rel="noopener noreffer">Node.js 101 — 單執行緒、非同步、非阻塞 I/O 與事件迴圈</a></p>
<p><a href="https://itnext.io/an-intro-to-node-js-that-you-may-have-missed-b175ef4277f7" target="_blank" rel="noopener noreffer">An Intro to Node.js That You May Have Missed
</a></p>
<p><a href="https://sequelize.org/v6/index.html" target="_blank" rel="noopener noreffer">Sequelize
</a></p>
<p><a href="https://hackmd.io/@TSMI_E7ORNeP8YBbWm-lFA/ryCtaVW_M?print-pdf#%E4%BD%BF%E7%94%A8sequelize%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%BC%B5user-table" target="_blank" rel="noopener noreffer">透過 sequelize 來達成 DB Schema Migration
</a></p>
<p><a href="https://medium.com/%E9%BA%A5%E5%85%8B%E7%9A%84%E5%8D%8A%E8%B7%AF%E5%87%BA%E5%AE%B6%E7%AD%86%E8%A8%98/%E5%BF%83%E5%BE%97-%E8%AA%8D%E8%AD%98%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5-callback-promise-async-await-640ea491ea64" target="_blank" rel="noopener noreffer">認識同步與非同步 — Callback + Promise + Async/Await
</a>
<a href="https://ithelp.ithome.com.tw/articles/10206555" target="_blank" rel="noopener noreffer">你懂 JavaScript 嗎？#23 Callback</a></p>
<p><a href="https://sebhastian.com/sequelize-join/" target="_blank" rel="noopener noreffer">How to create JOIN queries with Sequelize
</a></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/node.js/">Node.js</a>
                </span><span><a href="/tags/%E5%AF%A6%E4%BD%9C/">實作</a>
                </span><span><a href="/tags/%E4%BB%8B%E7%B4%B9/">介紹</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新於 2022-04-08&nbsp;<a class="git-hash" href="https://github.com/880831ian/blog/commit/4bafb62a16ffd908e4e33ef16e2aa41a0d07021c" target="_blank" title="committed&nbsp;by&nbsp;ian_zhuang(880831ian@gmail.com)&nbsp;4bafb62:&nbsp;# 修改 Node">
                            <i class="fas fa-hashtag fa-fw"></i>4bafb62</a></span>
            </div><div class="post-info-mod"><span>
                            <a class="link-to-markdown" href="/node/index.md" target="_blank">閱讀原始文檔</a>
                        </span><span>
                        &nbsp;|&nbsp;
                        <a class="link-to-markdown" href="https://github.com/880831ian/blog/tree/main/content/posts/Node/index.zh-tw.md" target="_blank">Improve Article</a>
                    </span></div>
        </div><div class="post-info-share">
            <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.pin-yi.me/node/" data-title="Node.js 介紹" data-hashtags="Node.js,實作,介紹"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.pin-yi.me/node/" data-hashtag="Node.js"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.pin-yi.me/node/"><i class="fab fa-linkedin fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://blog.pin-yi.me/node/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://blog.pin-yi.me/node/" data-title="Node.js 介紹"><i class="fab fa-line fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://blog.pin-yi.me/node/" data-title="Node.js 介紹"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Skype" data-sharer="skype" data-url="https://blog.pin-yi.me/node/" data-title="Node.js 介紹"><i class="fab fa-skype fa-fw"></i></a></span>
        </div></div><div class="post-nav"><a href="/go-restful-api-repository-messageboard/" class="prev" rel="prev" title="用 Go 寫一個 Repository Restful API 的留言板 (gin、gorm 套件)"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/node-restful-api-repository-messageboard/" class="next" rel="next" title="用 Node.js寫一個 Repository Restful API 的留言板 (express、sequelize 套件)">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div><div id="comments" class="single-card"><div id="disqus_thread"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">此 Blog 多數程式文章都是參考網路大神，加上自己的見解與實作內容編寫而成的筆記，若有侵權，請聯繫我。</div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://pin-yi.me">PinYi</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
</div>
<script>
if ('serviceWorker' in navigator) {
    navigator.serviceWorker
        .register('/sw.min.js?version=1.0.1', { scope: '/' })
        .then(() => {
            console.info('PinYi\u00A0Service Worker Registered');
        }, err => console.error('PinYi\u00A0Service Worker registration failed: ', err));

    navigator.serviceWorker
        .ready
        .then(() => {
            console.info('PinYi\u00A0Service Worker Ready');
        });
}
</script>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到頂部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看評論">
                <i class="fas fa-comment-alt fa-fw"></i>
            </a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.4.1-beta.0/dist/css/lightgallery.min.css"><script src="https://pin-yi.disqus.com/embed.js" defer></script><script src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.0/dist/autocomplete.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.4.1-beta.0/dist/js/lightgallery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.3.0/dist/lg-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.1/sharer.min.js"></script><script>window.config={"code":{"copyTitle":"複製到剪貼板","maxShownLines":120},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"找不到你輸入的資料🥲","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
